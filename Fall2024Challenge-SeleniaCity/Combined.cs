/**************************************************************
  This file was generated by FileConcatenator.
  It combined all classes in the project to work in Codingame.
***************************************************************/

using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Drawing;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Collections;

internal enum ActionType
{
    POD,
    TUBE,
    WAIT
}

internal static class Display 
{
    internal static void Summary(Game game, bool verbose)
    {
        Console.Error.WriteLine("==================================");
        Console.Error.WriteLine($"Resources: {game.Resources}");
        Console.Error.WriteLine();

        // Landing Pads
        Console.Error.WriteLine($"Landing Pads: {game.LandingPads.Count}");
        if (verbose)
        {
            LandingPads(game.LandingPads);
        }
        Console.Error.WriteLine();

        // Modules
        Console.Error.WriteLine($"Modules: {game.Modules.Count}");
        if (verbose)
        {
            Modules(game.Modules);
        }
        Console.Error.WriteLine();

        // Tubes
        Console.Error.WriteLine($"Tubes: {game.Tubes.Count}");
        if (verbose)
        {
            Tubes(game.Tubes);
        }
        Console.Error.WriteLine();

        // Pods
        Console.Error.WriteLine($"Pods: {game.Pods.Count}");
        if (verbose)
        {
            Pods(game.Pods);
        }
        Console.Error.WriteLine();

        Console.Error.WriteLine("==================================");
    }

    internal static void LandingPads(List<LandingPad> landingPads)
    {
        if (landingPads.Count == 0)
            return;

        Console.Error.WriteLine("");
        foreach (LandingPad landingPad in landingPads)
        {
            Console.Error.WriteLine($"{landingPad.Id}: ({landingPad.Position}) - Astronauts: {landingPad.Astronauts}");
        }
        Console.Error.WriteLine("");
    }

    internal static void Modules(List<Module> modules)
    {
        if (modules.Count == 0)
            return;

        Console.Error.WriteLine("");
        foreach (Module module in modules)
        {
            Console.Error.WriteLine($"{module.Id}: ({module.Position}) - Type: {module.Type}");
        }
        Console.Error.WriteLine("");
    }

    internal static void Tubes(List<Tube> tubes)
    {
        if (tubes.Count == 0)
            return;

        Console.Error.WriteLine("");
        foreach (Tube tube in tubes)
        { 
            Console.Error.WriteLine($"{tube.Building1Id} -> {tube.Building2Id} Capacity:{tube.Capacity}");
        }
        Console.Error.WriteLine("");
    }

    internal static void Pods(List<Pod> pods)
    {
        if (pods.Count == 0)
            return;

        Console.Error.WriteLine("");
        foreach (Pod pod in pods)
        {
            Console.Error.WriteLine($"{pod.Id}- Stops:{pod.NumberOfStops} - {string.Join(" ", pod.Path)}");
        }
        Console.Error.WriteLine("");
    }    
}


internal sealed partial class Game
{
    public int Resources { get; private set; }
    internal List<Tube> Tubes { get; private set; }
    internal List<Teleporter> Teleporters { get; private set; }
    internal List<Pod> Pods { get; private set; }
    public List<LandingPad> LandingPads { get; private set; } = new List<LandingPad>();
    public List<Module> Modules { get; private set; } = new List<Module>();

    internal void SetResources(int resources) => Resources = resources;

    internal void SetTubes(List<Tube> tubes) => Tubes = tubes;

    internal void SetTubes(List<Teleporter> teleporters) => Teleporters = teleporters;

    internal void SetPods(List<Pod> pods) => Pods = pods;

    internal void AddLandingPads(List<LandingPad> landingPads) => LandingPads.AddRange(landingPads);

    internal void AddModules(List<Module> modules) => Modules.AddRange(modules);

    private const int TELEPORTER_COST = 5000;
    private const int POD_COST = 5000;
    private const int DESTROY_REFUND = 750;

    private int currentPodId = 0;
   
    // TUBE | UPGRADE | TELEPORT | POD | DESTROY | WAIT
    // Example - "TUBE 0 1;TUBE 0 2;POD 42 0 1 0 2 0 1 0 2"
    internal string GetActions()
    {
        Display.Summary(this, true);

        //int cost0 = CalculateTubeCost(LandingPads[0], Modules[0]);
        //int cost1 = CalculateTubeCost(LandingPads[0], Modules[1]);

        // Bare minimum implementation
        // Create a tube from every landing pod to every building (that doesn't already exist)

        string actions = string.Empty;

        // Define tubes
        string tubesActions = string.Empty;
        string podsActions = string.Empty;

        foreach (LandingPad landingPad in LandingPads)
        {
            string podPath = string.Empty;

            foreach (Module module in Modules)
            {
                Console.Error.WriteLine($"podPath: {podPath}");
                // If the landing pad has astronauts of the module type
                if (landingPad.Astronauts.Contains(module.Type))
                {
                   // If the tube does not exist (TODO: Later we'll want to check teleporters too)
                   if (!Tubes.Any(a => a.Building1Id == landingPad.Id && a.Building2Id == module.Id))
                    {
                        tubesActions += ($"{nameof(ActionType.TUBE)} {landingPad.Id} {module.Id};");

                        podPath += $"{landingPad.Id} {module.Id} ";
                    }
                }
                Console.Error.WriteLine($"podPath: {podPath}");
            }

            if (podPath != string.Empty)
            {
                podPath = podPath.TrimEnd();
                string podAction = $"{ActionType.POD} {currentPodId} {podPath} {landingPad.Id};";
                currentPodId++;

                podsActions += podAction;
            }
        }

        if (tubesActions != string.Empty)
        {
            actions += tubesActions;
        }

        if (podsActions != string.Empty)
        {
            actions += podsActions;
        }

        if (actions != string.Empty)
        {
            return actions;
        }

        return nameof(ActionType.WAIT);
    }

    private static int CalculateTubeCost(IBuilding building1, IBuilding building2)
    {
        Point point1 = building1.Getposition();
        Point point2 = building2.Getposition();

        double distance = Math.Sqrt(Math.Pow(point1.X-point2.X, 2) + Math.Pow(point1.Y - point2.Y, 2));

        int cost = (int)(Math.Round((distance), MidpointRounding.ToZero) * 10);

        return cost;
    }
}


internal interface IBuilding
{
    internal int GetId();
    internal Point Getposition();
}


internal sealed class LandingPad(int id, Point position, int[] astronauts) : IBuilding
{
    internal int Id { get; } = id;
    internal Point Position { get; } = position;
    internal int[] Astronauts { get; } = astronauts;

    int IBuilding.GetId()
    {
        return Id;
    }

    Point IBuilding.Getposition()
    {
        return Position;
    }
}

internal sealed class Module(int id, int type, Point position): IBuilding
{
    internal int Id { get; } = id;
    public int Type { get; } = type;
    internal Point Position { get; } = position;

    int IBuilding.GetId()
    {
        return Id;
    }

    Point IBuilding.Getposition()
    {
        return Position;
    }
}


class Player
{   
    static void Main(string[] args)
    {
        Game game = new Game();

        // game loop
        while (true)
        {
            int resources = int.Parse(Console.ReadLine());
            game.SetResources(resources);

            ParseTravelRoutes(game);
            ParsePods(game);
            ParseBuildings(game);

            string actions = game.GetActions();

            // Write an action using Console.WriteLine()
            // To debug: Console.Error.WriteLine("Debug messages...");

            Console.WriteLine(actions);
        }
    }

    private static void ParseTravelRoutes(Game game)
    {
        List<Tube> tubes = new List<Tube>();
        List<Teleporter> teleporters = new List<Teleporter>();

        int numTravelRoutes = int.Parse(Console.ReadLine());

        for (int i = 0; i < numTravelRoutes; i++)
        {
            string[] inputs = Console.ReadLine().Split(' ');
            int buildingId1 = int.Parse(inputs[0]);
            int buildingId2 = int.Parse(inputs[1]);
            int capacity = int.Parse(inputs[2]);

            if (capacity == 0)
            {
                teleporters.Add(new Teleporter(buildingId1, buildingId2));

            }
            else
            {
                tubes.Add(new Tube(buildingId1, buildingId2, capacity));
            }
        }

        game.SetTubes(tubes);
    }

    private static void ParsePods(Game game)
    {
        List<Pod> pods = new List<Pod>();
        int numPods = int.Parse(Console.ReadLine());
        for (int i = 0; i < numPods; i++)
        {
            string podProperties = Console.ReadLine();

            string[] properties = podProperties.Split(" ");

            int[] path = new int[properties.Length - 2];

            for (int j = 0; j < path.Length; j++)
            {
                path[j] = int.Parse(properties[j + 2]);
            }

            pods.Add(new Pod(int.Parse(properties[0]), int.Parse(properties[1]), path));
        }

        game.SetPods(pods);
    }

    private static void ParseBuildings(Game game)
    {
        List<Module> modules = new List<Module>();
        List<LandingPad> landingPads = new List<LandingPad>();

        int numNewBuildings = int.Parse(Console.ReadLine());
        for (int i = 0; i < numNewBuildings; i++)
        {
            string buildingProperties = Console.ReadLine();

            string[] props = buildingProperties.Split(" ");

            int type = int.Parse(props[0]);
            int id = int.Parse(props[1]);
            Point position = new Point(int.Parse(props[2]), int.Parse(props[3]));

            if (type == 0)
            {
                int[] astronauts = new int[props.Length - 4];

                for (int j = 0; j < astronauts.Length; j++)
                {
                    astronauts[j] = int.Parse(props[j + 4]);
                }

                landingPads.Add(new LandingPad(id, position, astronauts));
            }
            else
            {
                modules.Add(new Module(id, type, position));
            }
        }

        game.AddLandingPads(landingPads);
        game.AddModules(modules);
    }
}


internal sealed class Pod(int id, int numberOfStops, int[] path)
{
    internal int Id { get; private set; } = id;
    internal int NumberOfStops { get; private set; } = numberOfStops;
    internal int[] Path { get; private set; } = path;
}

internal sealed class Teleporter(int building1Id, int building2Id)
{
    public int Building1Id { get; private set; } = building1Id;
    public int Building2Id { get; private set; } = building2Id;
}

internal sealed class Tube(int building1Id, int building2Id, int capacity)
{
    public int Building1Id { get; private set; } = building1Id;
    public int Building2Id { get; private set; } = building2Id;
    public int Capacity { get; private set; } = capacity;
}

