/**************************************************************
  This file was generated by FileConcatenator.
  It combined all classes in the project to work in Codingame.
***************************************************************/

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Runtime.CompilerServices;
using static System.Runtime.InteropServices.JavaScript.JSType;
using System.Text;
using System.Collections;

internal static class Display
{
    internal static void DisplayRecipes(List<Recipe> recipes)
    {
        Console.Error.WriteLine("Recipes");

        foreach (Recipe recipe in recipes)
        {
            DisplayRecipe(recipe);
        }
    }

    internal static void DisplayRecipe(Recipe recipe)
    {
        Console.Error.WriteLine("actionId: " + recipe.Id);
        DisplayIngredients(recipe.Ingredients);
        Console.Error.WriteLine("Price: " + recipe.Price);
        Console.Error.WriteLine();
    }

    internal static void DisplayIngredients(int[] ingredients)
    {
        Console.Error.WriteLine("blueIngredients:   " + ingredients[0]);
        Console.Error.WriteLine("greenIngredients:  " + ingredients[1]);
        Console.Error.WriteLine("orangeIngredients: " + ingredients[2]);
        Console.Error.WriteLine("yellowIngredients: " + ingredients[3]);
    }

    internal static void DisplaySpells(List<Spell> spells)
    {
        foreach (Spell spell in spells)
        {
            DisplaySpell(spell);
        }
    }

    internal static void DisplaySpell(Spell spell)
    {
        Console.Error.WriteLine($"actionId: {spell.Id}");
        Console.Error.WriteLine($"Castable: {spell.Castable}");
        Console.Error.WriteLine($"Repeatable: {spell.Repeatable}");
        DisplayIngredients(spell.IngredientsChange);
        Console.Error.WriteLine();        
    }

    internal static void DisplayMoves(List<string> moves)
    {
        foreach (string move in moves)
        {
            Console.Error.WriteLine(move);
        }
    }
}


internal sealed class Game
{   
    internal List<Recipe> Recipes { get; private set; }
    internal List<Spell> Spells { get; private set; }
    internal List<Spell> TomeSpells { get; private set; }
    internal Inventory PlayerInventory { get; private set; }
    internal Inventory OpponentInventory { get; private set; }

    private List<string> currentPath = new List<string>();
    private int currentRecipe = -1;

    private int maxDepth = 10;

    private int turnCount = 0;
    
    public Game()
    {
        Recipes = new List<Recipe>();
    }
    
    public void SetRecipes(List<Recipe> recipes)
    {
        Recipes = recipes;
    }
    
    public void SetSpells(List<Spell> spells)
    {
        Spells = spells;
    }

    public void SetTomeSpells(List<Spell> tomeSpells)
    {
        TomeSpells = tomeSpells;
    }

    public void SetPlayerInventory(Inventory inventoryItems)
    {
        PlayerInventory = inventoryItems;
    }
    
    public void SetOpponentInventory(Inventory inventoryItems)
    {
        OpponentInventory = inventoryItems;
    }
    public string GetAction()
    {
        // Display.DisplaySpells(TomeSpells);

        // Very naieve but lets just get the first 6 spells
        if (turnCount < 6)
        {
            turnCount++;
            return $"LEARN {TomeSpells[0].Id}";
        }

        if (currentRecipe == -1 || !Recipes.Exists(r => r.Id == currentRecipe))
        {
            currentRecipe = -1;

            List<string>[] paths = new List<string>[Recipes.Count];

            // Go through each recipe, starting with the best scoring one
            for (int i = 0; i < Recipes.Count; i++)
            {  
                Recipe currentRecipe = Recipes[i];

                // If it can be brewed then brew it
                if (CanRecipeBeBrewed(currentRecipe))
                    return $"{Recipe.ActionType} {currentRecipe.Id}";

                // Find shortest path to ingredients
                paths[i] = FindShortestPath(PlayerInventory.Ingredients, currentRecipe.Ingredients, Spells);
            }

            // int bestIndex = GetQuickestPathIndex(paths);
            int bestIndex = GetMostExpensivePathIndex(paths);

            if (bestIndex >= 0)
            {
                List<string> bestPath = paths[bestIndex];

                if (bestPath.Count > 0)
                {
                    currentRecipe = Recipes[bestIndex].Id; ;
                    currentPath = bestPath;
                }
            }
        }

        string action = string.Empty;

        if (currentRecipe != -1)
        {
            if (currentPath.Count > 0)
            {
                action = currentPath[0];
                currentPath.RemoveAt(0);
            }
            else
            {
                action = $"BREW {currentRecipe}";
                currentPath = new List<string>();
                currentRecipe = -1;

            }
        }

        // If we haven't found an action just do something
        if (action == "")
        {
            for (int i = 0; i < Spells.Count; i++)
            {
                if (Spells[i].Castable && CanSpellBeCast(Spells[i].IngredientsChange, PlayerInventory.Ingredients))
                {
                    action = $"CAST {Spells[i].Id}";
                }
            }
        }

        if (action == "")
        {
            action = "REST";
        }

        turnCount++;

        return action;
    }

    private static int GetQuickestPathIndex(List<string>[] paths)
    {
        int quickest = int.MaxValue;
        int quickestIndex = -1;

        for (int i = 0; i < paths.Length; i++)
        {
            if (paths[i].Count > 0 && paths[i].Count < quickest)
            {
                quickest = paths[i].Count;

                quickestIndex = i;
            }
        }

        return quickestIndex;
    }

    private int GetMostExpensivePathIndex(List<string>[] paths)
    {
        int mostExpensive = int.MinValue;
        int mostExpensiveIndex = -1;

        for (int i = 0; i < paths.Length; i++)
        {
            var price = Recipes[i].Price;

            // The implementation of this bonus isn't 100% right. I'll fix it at some point:
            // Brewing a potion for the very first client awards a + 3 rupee bonus, but this can only happen 4 times during the game.
            // Brewing a potion for the second client awards a + 1 rupee bonus, but this also can only happen 4 times during the game.
            // If all + 3 bonuses have been used up, the + 1 bonus will be awarded by the first client instead of the second client.
            if (i == 0)
            {
                price += 3;
            }
            else if (i == 1)
            {
                price += 1;
            }

            if (paths[i].Count > 0 && price > mostExpensive)
            {
                mostExpensive = price;

                mostExpensiveIndex = i;
            }
        }

        return mostExpensiveIndex;
    }

    private bool CanRecipeBeBrewed(Recipe recipe)
    {
        return CanRecipeBeBrewed(recipe.Ingredients, PlayerInventory.Ingredients);
    }

    private static bool CanRecipeBeBrewed(int[] needed, int[] have)
    {
        if (have[0] >= needed[0]
            && have[1] >= needed[1]
            && have[2] >= needed[2]
            && have[3] >= needed[3])
        {
            return true;
        }

        return false;
    }

    private static bool CanSpellBeCast(int[] spellIngredientsChange, int[] inventoryIngredients)
    {
        int total = GetTotal(spellIngredientsChange, inventoryIngredients);

        bool haveIngredients = AreNeededIngredientsPresent(spellIngredientsChange, inventoryIngredients);
        

        if (total > 10 || !haveIngredients)
        {
            return false;
        }

        return true;

    }

    private static int GetTotal(int[] spellIngredientsChange, int[] inventoryIngredients)
    {
        int total = 0;

        for (int i = 0; i < 4; i++)
        {
            if (inventoryIngredients[i] + spellIngredientsChange[i] >= 0)
            {
                total += inventoryIngredients[i] + spellIngredientsChange[i];
            }
        }

        return total;
    }

    private static bool AreNeededIngredientsPresent(int[] spellIngredientsChange, int[] inventoryIngredients)
    {
        return inventoryIngredients[0] + spellIngredientsChange[0] >= 0
            && inventoryIngredients[1] + spellIngredientsChange[1] >= 0
            && inventoryIngredients[2] + spellIngredientsChange[2] >= 0
            && inventoryIngredients[3] + spellIngredientsChange[3] >= 0;
    }

    private List<string> FindShortestPath(int[] currentIngredients, int[] neededIngredients, List<Spell> availableSpells)
    {
        List<string> moves = new List<string>();

        for (int i = 0; i <= maxDepth; i++)
        {
            moves.Clear();
            int turns = DepthFirstSearch(currentIngredients, neededIngredients, availableSpells, 0, moves, i);

            if (turns != int.MaxValue)
            {
                break;
            }
        }

        return moves;
    }

    public int DepthFirstSearch(int[] currentIngredients, int[] neededIngredients, List<Spell> availableSpells, int depth, List<string> moves, int maxDepth)
    {
        if (CanRecipeBeBrewed(neededIngredients, currentIngredients))
            return 0;
        
        if (depth == maxDepth)
        {
            return int.MaxValue;
        }

        int minTurns = int.MaxValue;

        string madeMove = string.Empty;
        bool[] castableBefore = new bool[availableSpells.Count];
        int[] ingredientsBefore = new int[4];

        // Get all possible actions
        for (int i = 0; i <= availableSpells.Count(); i++)
        {
            madeMove = string.Empty;

            if (i == availableSpells.Count())
            {
                if (availableSpells.Count(s => !s.Castable) > 0)
                {
                    // Make move
                    for (int k = 0; k < availableSpells.Count(); k++)
                    {
                        Spell spellToChange = availableSpells[k];

                        castableBefore[k] = availableSpells[k].Castable;

                        availableSpells[k].Castable = true;
                    }

                    madeMove = "REST";

                    moves.Add("REST");
                }
                else
                {
                    // if all spells are active don't try this
                    continue;
                }
            }
            else
            {
                // do the changes from casting the spell
                if (availableSpells[i].Castable == true && CanSpellBeCast(availableSpells[i].IngredientsChange, currentIngredients))
                {
                    availableSpells[i].Castable = false;

                    for (int j = 0; j < 4; j++)
                    {
                        ingredientsBefore[j] = currentIngredients[j];
                    }

                    for (int j = 0; j < 4; j++)
                    {
                        currentIngredients[j] += availableSpells[i].IngredientsChange[j];
                        if (currentIngredients[j] < 0)
                            currentIngredients[j] = 0;
                    }

                    madeMove = "CAST";
                    moves.Add($"CAST {availableSpells[i].Id}");
                }
                else
                {
                    continue;
                }
            }

            int turns = DepthFirstSearch(currentIngredients, neededIngredients, availableSpells, depth + 1, moves, maxDepth);

            // unmake move
            if (madeMove == "REST")
            {
                for (int j = 0; j < availableSpells.Count(); j++)
                {
                    availableSpells[j].Castable = castableBefore[j];
                }
            } 
            else if (madeMove == "CAST")
            {
                for (int j = 0; j < 4; j++)
                {
                    currentIngredients[j] = ingredientsBefore[j];
                }
            }

            if (turns == 0)
            {
                return 0;
            }

            if (turns != int.MaxValue && turns + 1 < minTurns)
            {
                minTurns = turns + 1;
            } 
            else
            {
                moves.RemoveAt(depth);
            }            
        }

        return minTurns;
    }
}

internal sealed class Inventory
{
    public int[] Ingredients { get; }
    internal int Score { get; }
    
    internal Inventory(int[] ingredients,
        int score)
    {
        Ingredients = ingredients;
        Score = score;
    }
}

internal sealed class Player
{
    static void Main(string[] args)
    {
        Game game = new Game();
        
        // game loop
        while (true)
        {
            ParseActions(game);

            game.SetPlayerInventory(GetInventoryItems());
            game.SetOpponentInventory(GetInventoryItems());

            string action = game.GetAction();
            Console.WriteLine(action);
        }
    }

    private static void ParseActions(Game game)
    {
        int actionCount = int.Parse(Console.ReadLine()); // the number of spells and recipes in play

        List<Recipe> recipes = new List<Recipe>();
        List<Spell> spells = new List<Spell>();
        List<Spell> tomeSpells = new List<Spell>();

        for (int i = 0; i < actionCount; i++)
        {
            string input = Console.ReadLine();
            string[] inputs = input.Split(' ');
            
            if(inputs[1] == "BREW")
            {
                recipes.Add(new Recipe(int.Parse(inputs[0]),
                                       new int[] { Math.Abs(int.Parse(inputs[2])),
                                                   Math.Abs(int.Parse(inputs[3])),
                                                   Math.Abs(int.Parse(inputs[4])),
                                                   Math.Abs(int.Parse(inputs[5]))},
                                       int.Parse(inputs[6])));   
            }
            else if(inputs[1] == "CAST")
            {
                spells.Add(new Spell(int.Parse(inputs[0]),
                                     new int[] { int.Parse(inputs[2]),
                                                 int.Parse(inputs[3]),
                                                 int.Parse(inputs[4]),
                                                 int.Parse(inputs[5])},
                                     int.Parse(inputs[9]) == 1,
                                     int.Parse(inputs[10]) == 1));   
            }
            else if (inputs[1] == "LEARN")
            {
                tomeSpells.Add(new Spell(int.Parse(inputs[0]),
                                     new int[] { int.Parse(inputs[2]),
                                                 int.Parse(inputs[3]),
                                                 int.Parse(inputs[4]),
                                                 int.Parse(inputs[5])},
                                     int.Parse(inputs[9]) == 1,
                                     int.Parse(inputs[10]) == 1));
            }
        }
        
        game.SetRecipes(recipes);
        game.SetSpells(spells);
        game.SetTomeSpells(tomeSpells);
    }
    
    private static Inventory GetInventoryItems()
    {
        string input = Console.ReadLine();
        string[] inputs = input.Split(' ');

        Inventory inventory = new Inventory(new int[] {Math.Abs(int.Parse(inputs[0])),
                                      Math.Abs(int.Parse(inputs[1])),
                                      Math.Abs(int.Parse(inputs[2])),
                                      Math.Abs(int.Parse(inputs[3]))},
                                      int.Parse(inputs[4]));

        return inventory;
    }

    private static void DisplayInventory (Inventory inventory, bool mine)
    {
        Console.Error.WriteLine(mine ? "My inventory" : "Opponent inventory");
        Console.Error.WriteLine("-----------");
        
        Console.Error.WriteLine("blueIngredients: " + inventory.Ingredients[0]);   
        Console.Error.WriteLine("greenIngredients: " + inventory.Ingredients[1]);   
        Console.Error.WriteLine("orangeIngredients: " + inventory.Ingredients[2]);   
        Console.Error.WriteLine("yellowIngredients: " + inventory.Ingredients[3]); 
    }
}

// for (int i = 0; i < actionCount; i++)
// {
//     inputs = Console.ReadLine().Split(' ');
//     int actionId = int.Parse(inputs[0]); // the unique ID of this spell or recipe
//     string actionType = inputs[1]; // in the first league: BREW; later: CAST, OPPONENT_CAST, LEARN, BREW
//     int delta0 = int.Parse(inputs[2]); // tier-0 ingredient change
//     int delta1 = int.Parse(inputs[3]); // tier-1 ingredient change
//     int delta2 = int.Parse(inputs[4]); // tier-2 ingredient change
//     int delta3 = int.Parse(inputs[5]); // tier-3 ingredient change
//     int price = int.Parse(inputs[6]); // the price in rupees if this is a potion
//     int tomeIndex = int.Parse(inputs[7]); // in the first two leagues: always 0; later: the index in the tome if this is a tome spell, equal to the read-ahead tax; For brews, this is the value of the current urgency bonus
//     int taxCount = int.Parse(inputs[8]); // in the first two leagues: always 0; later: the amount of taxed tier-0 ingredients you gain from learning this spell; For brews, this is how many times you can still gain an urgency bonus
//     bool castable = inputs[9] != "0"; // in the first league: always 0; later: 1 if this is a castable player spell
//     bool repeatable = inputs[10] != "0"; // for the first two leagues: always 0; later: 1 if this is a repeatable player spell
// }
// for (int i = 0; i < 2; i++)
// {
//     inputs = Console.ReadLine().Split(' ');
//     int inv0 = int.Parse(inputs[0]); // tier-0 ingredients in inventory
//     int inv1 = int.Parse(inputs[1]);
//     int inv2 = int.Parse(inputs[2]);
//     int inv3 = int.Parse(inputs[3]);
//     int score = int.Parse(inputs[4]); // amount of rupees
// }

internal sealed class Recipe
{
    public const string ActionType = "BREW";
    
    internal int Id { get; }
    public int[] Ingredients { get; }
    internal int Price { get; }
    
    internal Recipe(int id,
        int[] ingredients,
        int price)
    {
        Id = id;
        Ingredients = ingredients;
        Price = price;
    }

    
}

internal sealed class Spell
{
    internal const string ActionType = "CAST";
    
    internal int Id { get; }
    public int[] IngredientsChange { get; }
    internal bool Castable { get; set; }
    internal bool Repeatable { get; set; }

    internal Spell(int id,
        int[] ingredientsChange,
        bool castable,
        bool repeatable)
    {
        Id = id;
        IngredientsChange = ingredientsChange;
        Castable = castable;
        Repeatable = repeatable;

    }
}

