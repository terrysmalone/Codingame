/**************************************************************
  This file was generated by FileConcatenator.
  It combined all classes in the project to work in Codingame.
***************************************************************/

using System;
using System.Collections.Generic;
using System.IO;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Collections;

internal class Cell
{
    internal int Index { get; private set; }
    internal int[] NeighbourIds { get; private set; }
    internal CellType CellType { get; private set; }
    internal int EggCount { get; set; }
    internal int CrystalCount { get; set; }

    internal int playerAntsCount { get; set; } = 0;
    internal int opponentAntsCount { get; set; } = 0;

    internal Cell(int index, int[] neighbourIds, CellType cellType, int eggCount, int crystalCount)
    {
        Index = index;
        NeighbourIds = neighbourIds;
        CellType = cellType;
        EggCount = eggCount;
        CrystalCount = crystalCount;
    }
}


internal enum CellType
{
    Empty = 0,
    Egg = 1,
    Crystal = 2
}


internal static class Display
{
    internal static void Path(string message, List<int> path)
    {
        if (path.Count == 0)
        {
            return;
        }

        Console.Error.WriteLine(message);
        Console.Error.WriteLine($"Path to {path[path.Count - 1]}: {string.Join("->", path)}");
    }

    internal static void Paths(string message, List<List<int>> paths)
    {
        Console.Error.WriteLine(message);
        foreach (var path in paths)
        {
            if (path.Count == 0)
            {
                continue;
            }

            Console.Error.WriteLine($"Path to {path[path.Count-1]}: {string.Join("->", path)}");
        }
    }

    internal static void ResourcePaths(string message, List<ResourcePath> resourcePaths)
    {
        Console.Error.WriteLine(message);

        foreach (var resourcePath in resourcePaths)
        {
            Console.Error.WriteLine($"Path ({resourcePath.CellType}) - Id:{resourcePath.PathId} ParentId:{resourcePath.ParentPathId} - {string.Join("->", resourcePath.Path)}");
        }


    }
}




internal class Game
{
    private readonly int _numberOfCells;

    private List<int> _playerBases = new List<int>();
    private List<int> _opponentBases = new List<int>();

    private Dictionary<int, Cell> _cells = new Dictionary<int, Cell>();

    private PathFinder _pathFinder;

    // Keep track of cell counts at the start of every loop for fast search
    private List<SimpleCell> _resourceCells = new List<SimpleCell>();

    private int _totalEggCount = 0;
    private int _totalCrystalCount = 0;

    private int _totalEggCells = 0;
    private int _totalCrystalCells = 0;

    private int _playerAntCount = 0;
    private int _opponentAntCount = 0;

    private Dictionary<int, int> _resourcesToClosestBase = new Dictionary<int, int>();

    public Game(int numberOfCells)
    {
        this._numberOfCells = numberOfCells;
        _pathFinder = new PathFinder(_cells);
    }

    internal void AddCell(int index, Cell cell)
    {
        _cells.Add(index, cell);
    }

    internal void AddPlayerBase(int myBaseIndex)
    {
        _playerBases.Add(myBaseIndex);
    }

    internal void AddOpponentBase(int oppBaseIndex)
    {
        _opponentBases.Add(oppBaseIndex);
    }

    internal void UpdateCell(int i, int resources, int myAnts, int oppAnts)
    {
        if (_cells.ContainsKey(i))
        {
            var cell = _cells[i];

            if (cell.CellType == CellType.Egg)
            {
                cell.EggCount = resources;
                if (resources > 0)
                {
                    _resourceCells.Add(new SimpleCell(i, cell.CellType, resources));
                    _totalEggCount += resources;
                    _totalEggCells++;
                }
            }
            else if (cell.CellType == CellType.Crystal)
            {
                cell.CrystalCount = resources;
                if (resources > 0)
                {
                    _resourceCells.Add(new SimpleCell(i, cell.CellType, resources));
                    _totalCrystalCount += resources;
                    _totalCrystalCells++;
                }
            }

            cell.playerAntsCount = myAnts;
            cell.opponentAntsCount = oppAnts;
        }
        else
        {
            Console.Error.WriteLine($"ERROR: Cell {i} not found");
        }
    }

    internal void ResetCounts()
    {
        _resourceCells.Clear();

        _playerAntCount = 0;
        _opponentAntCount = 0;
        _totalEggCount = 0;
        _totalCrystalCount = 0;
        _totalEggCells = 0;
        _totalCrystalCells = 0;
    }

    internal List<string> GetActions()
    {
        var totalResourceCells = (_totalEggCells + _totalCrystalCells) / _playerBases.Count;

        var pathLimit = 10;

        Console.Error.WriteLine($"_totalEggCells: {_totalEggCells}, _totalCrystalCells: {_totalCrystalCells}");
        if (_totalEggCells + _totalCrystalCells <= 15)
        {
            pathLimit = 5; // If there are not many resources, limit the paths
        }

        if (_totalEggCells + _totalCrystalCells <= 10)
        {
            pathLimit = 3; // If there are not many resources, limit the paths
        }

        var actions = new List<string>();

        var antsPerBase = _playerAntCount / _playerBases.Count;

        var targetedCells = new Dictionary<int, int>();
        var targetedResources = new List<int>();

        // TODO: I need to start assigning resource first rather than base first. 
        // I currently target resources closer to other bases


        foreach (int playerBase in _playerBases)
        {
            Console.Error.WriteLine($"Processing base {playerBase}");
            // Display the targetedResources
            Console.Error.WriteLine($"Targeted Resources for base {playerBase}: {string.Join(", ", targetedResources)}");

            var startPoints = new List<StartReference> { new StartReference(playerBase, -1, -1) };

            // exclude targetedResources and resources that are closeer to other bases
            List<int> excludeResources = new List<int>();
            foreach (var targetedResource in targetedResources)
            {
                excludeResources.Add(targetedResource);
            }
            foreach(var resourceToClosestBase in _resourcesToClosestBase)
            {
                if (resourceToClosestBase.Value != playerBase)
                {
                    Console.Error.WriteLine($"Excluding resource {resourceToClosestBase.Key} as it is closer to base {playerBase}");
                    excludeResources.Add(resourceToClosestBase.Key);
                }
            }


            List<ResourcePath> resourcePaths = CalculateBestResourcePaths(startPoints, _resourceCells, pathLimit, excludeResources);
            Display.ResourcePaths("Resource Paths", resourcePaths);

            // We want to minimise number of ants while maximising resources
            var availableAnts = antsPerBase;
            var eggCellCount = 0;
            var crystalCellCount = 0;
            
            Console.Error.WriteLine($"Available Ants:{availableAnts}");

            List<int> parentPaths = new List<int>();

            while (resourcePaths.Count > 0 && availableAnts >= resourcePaths.First().Path.Count)
            { 
                // Get closest base to resource
                var closestResourcePath = GetClosestBaseToResourcePath(resourcePaths, parentPaths);

                // Display.ResourcePaths("Closest Resource Path", new List<ResourcePath> { closestResourcePath });
                if (closestResourcePath == null)
                {
                    break; // No resource paths available
                }

                Display.ResourcePaths("Closest Resource Path", new List<ResourcePath> { closestResourcePath });

                targetedResources.Add(closestResourcePath.Path[closestResourcePath.Path.Count - 1]);

                (List<int> fullPath, int neededStrength) = CalculateFullPathAndNeededStrength(closestResourcePath, targetedCells);


                if (neededStrength == 1)
                { 
                    foreach (int cellId in closestResourcePath.Path)
                    {
                        if (!targetedCells.ContainsKey(cellId))
                        {
                            targetedCells.Add(cellId, 1);
                            availableAnts--;
                        }
                    }

                    if (closestResourcePath.CellType == CellType.Egg)
                    {
                        eggCellCount++;
                    }
                    else if (closestResourcePath.CellType == CellType.Crystal)
                    {
                        crystalCellCount++;
                    }

                    parentPaths.Add(closestResourcePath.PathId);
                }
                else
                {
                    // TODO: Do it for full path....


                    Console.Error.WriteLine($"We need to increase chain strength to {neededStrength} for chain to {fullPath[fullPath.Count-1]}");


                    // Calculate the cost to increate the whole thing to chainStrength + 1
                    int neededAnts = 0;
                    foreach (int cell in fullPath)
                    {
                        if (_cells.ContainsKey(cell))
                        {
                            if (targetedCells.ContainsKey(cell) && targetedCells[cell] < neededStrength)
                            {
                                neededAnts += neededStrength - targetedCells[cell];
                            }
                            else
                            {
                                neededAnts += neededStrength;
                            }
                        }
                    }

                    // If we have enough, do it, otherwise skip this path
                    if (neededAnts <= availableAnts)
                    {
                        Console.Error.WriteLine($"Increasing chain strength to {neededStrength} for chain to {fullPath[fullPath.Count - 1]} - needed:{neededAnts} available:{availableAnts}");
                        foreach (int cellId in fullPath)
                        {
                            if (!targetedCells.ContainsKey(cellId))
                            {
                                targetedCells.Add(cellId, neededStrength);
                                availableAnts -= (neededStrength);
                            }
                            else
                            {
                                // If the cell is already targeted, increase the strength
                                var currentStrength = targetedCells[cellId];
                                targetedCells[cellId] = neededStrength;

                                availableAnts -= neededStrength - currentStrength;
                            }
                        }

                        if (closestResourcePath.CellType == CellType.Egg)
                        {
                            eggCellCount++;
                        }
                        else if (closestResourcePath.CellType == CellType.Crystal)
                        {
                            crystalCellCount++;
                        }

                        parentPaths.Add(closestResourcePath.PathId);

                    }
                    else
                    {
                        Console.Error.WriteLine($"Not enough ants to increase chain strength to {neededStrength} for chain to {fullPath[fullPath.Count - 1]} - needed:{neededAnts} available:{availableAnts}");
                    }
                }

                // Console.Error.WriteLine($"Available Ants:{availableAnts}-eggCellCount:{eggCellCount}-crystalCellCount:{crystalCellCount}");
            }

            Console.Error.WriteLine($"Spare ants: {availableAnts}");

            // As a first pass just redistribute the remaining ants to the targeted cells
            var counter = 0;
            while (availableAnts > 0 && targetedCells.Count > 0)
            {
                var index = targetedCells.ElementAt(counter).Key;
                targetedCells[index] = targetedCells[index] + 1;

                counter++;
                if (counter >= targetedCells.Count)
                {
                    counter = 0;
                }

                availableAnts--;
            }

            Console.Error.WriteLine($"Spare ants: {availableAnts}");
        }

        actions = GetBeaconActions(targetedCells);

        return actions;
    }

    // Calculates the shortest path to a base and what strength is needed to be stronger than the opponent 
    private (List<int>, int) CalculateFullPathAndNeededStrength(ResourcePath closestResourcePath, Dictionary<int, int> targetedCells)
    {
        var fullPath = new List<int>();

        // Copy closestResourcePath in reverse order
        for (int i = closestResourcePath.Path.Count-1; i >= 0; i--)
        {
            fullPath.Add(closestResourcePath.Path[i]);
        }

        if (!closestResourcePath.IsBasePath)
        {
            List<int> pathToBase = _pathFinder.FindShortestTargetedPathToBase(fullPath[fullPath.Count - 1], _playerBases, targetedCells);

            if (pathToBase.Count >= 1)
            {
                for (int i = 1; i < pathToBase.Count; i++)
                {
                    fullPath.Add(pathToBase[i]);
                }
            }
        }

        int strongestEnemyChain = 0;

        foreach (var cell in fullPath)
        {
            if (_cells.ContainsKey(cell))
            {
                if (_cells[cell].opponentAntsCount > 0)
                {
                    int chainStrength = CalculateEnemyChainStrengthFrom(cell);

                    if (chainStrength > strongestEnemyChain)
                    {
                        strongestEnemyChain = chainStrength;
                    }
                }
            }
        }

        return (fullPath, strongestEnemyChain + 1);
    }

    private int CalculateEnemyChainStrengthFrom(int cell)
    {
        List<int> chain = _pathFinder.FindShortestOpponentPathToBase(cell, _opponentBases);

        if (chain.Count == 0)
        {
            return 0;
        }

        var strength = GetChainStrength(chain, false);

        return strength;
    }

    private int GetChainStrength(List<int> path, bool forPlayer)
    {
        var strength = int.MaxValue;

        foreach (var cell in path)
        {
            if (_cells.ContainsKey(cell))
            {
                if (forPlayer)
                {
                    if (_cells[cell].playerAntsCount < strength)
                    {
                        strength = _cells[cell].playerAntsCount;
                    }
                }
                else
                {
                    if (_cells[cell].opponentAntsCount < strength)
                    {
                        strength = _cells[cell].opponentAntsCount;

                    }
                }
            }
        }

        return strength;
    }

    private ResourcePath GetClosestBaseToResourcePath(List<ResourcePath> resourcePaths, List<int> parentPathsToInclude)
    {
        var possiblePaths = resourcePaths.Where(rp => rp.IsBasePath || parentPathsToInclude.Contains(rp.ParentPathId)).ToList();

        if (possiblePaths.Count == 0)
        {
            return null; // No paths available
        }

        var closestPath = possiblePaths.First();

        resourcePaths.Remove(closestPath);
        return closestPath;
    }

    private List<ResourcePath> CalculateBestResourcePaths(List<StartReference> startPoints, 
                                                          List<SimpleCell> resourceCells,                                                    
                                                          int resourcePathLimit,
                                                          List<int> excludedResources)
    {
        var resourcePathCount = 0;

        var resourcePaths = new List<ResourcePath>();

        // Get resource paths
        var targetedResource = new List<int>();

        foreach (var excludedResource in excludedResources)
        {
            targetedResource.Add(excludedResource);
        }
        while (resourcePathCount < resourcePathLimit)
        {
            List<ResourcePath> pathsToResources = _pathFinder.GetShortestPaths(startPoints, resourceCells, targetedResource);

            ResourcePath shortestResourcePath = GetShortestPath(pathsToResources);

            if (shortestResourcePath == null || shortestResourcePath.Path.Count == 0)
            {
                break; // No path found, stop looking
            }

            int targetId = shortestResourcePath.Path[shortestResourcePath.Path.Count - 1];

            startPoints.Add(new StartReference(targetId, shortestResourcePath.PathId, shortestResourcePath.ParentPathId));
            targetedResource.Add(targetId);

            resourcePaths.Add(shortestResourcePath);


            resourcePathCount++;
        }

        resourcePaths.Sort((a, b) => a.Path.Count.CompareTo(b.Path.Count));

        return resourcePaths;
    }

    private static ResourcePath GetShortestPath(List<ResourcePath> paths)
    {
        if (paths.Count == 0)
        {
            return null;
        }

        // Find the shortest path
        ResourcePath shortestPath = paths[0];
        foreach (ResourcePath path in paths)
        {
            if (path.Path.Count < shortestPath.Path.Count)
            {
                shortestPath = path;
            }
        }
        return shortestPath;
    }

    private static List<string> GetBeaconActions(Dictionary<int, int> targetedCells)
    {
        var actions = new List<string>();

        foreach (KeyValuePair<int, int> targetedCell in targetedCells)
        {
            actions.Add($"BEACON {targetedCell.Key} {targetedCell.Value}");
        }

        return actions;
    }    

    internal void IncreasePlayerAntCount(int count)
    {
        _playerAntCount += count;
    }

    internal void IncreaseOpponentAntCount(int count)
    {
        _opponentAntCount += count;
    }

    // For each resource find the closest base and store it in _resourcesToClosestBase
    internal void CountResourcesToBases()
    {
        foreach (var cell in _cells)
        {
            if (cell.Value.CellType == CellType.Egg || cell.Value.CellType == CellType.Crystal)
            {
                // Check which base is closest to this cell
                int closestBase = -1;
                int shortestDistance = int.MaxValue;

                foreach (var playerBase in _playerBases)
                {
                    List<int> path = _pathFinder.FindShortestPath(cell.Key, playerBase, shortestDistance);
                    if (path.Count > 0 && path.Count < shortestDistance)
                    {
                        closestBase = playerBase;
                        shortestDistance = path.Count;
                    }
                }

                if (closestBase != -1)
                {
                    if (!_resourcesToClosestBase.ContainsKey(cell.Key) || _resourcesToClosestBase[cell.Key] != closestBase)
                    {
                        _resourcesToClosestBase[cell.Key] = closestBase;
                    }
                }
            }

        }
    }
}


internal class PathFinder
{
    private int idCounter = 0;
    private readonly Dictionary<int, Cell> _cells;    

    public PathFinder(Dictionary<int, Cell> cells)
    {
        _cells = cells;
    }

    internal List<ResourcePath> GetShortestPaths(List<StartReference> startReferences, List<SimpleCell> targetCells)
    {
        return GetShortestPaths(startReferences, targetCells, new List<int>());
    }

    internal List<ResourcePath> GetShortestPaths(List<StartReference> startReferences, List<SimpleCell> targetCells, List<int> targetCellsToExclude)
    {
        var paths = new List<ResourcePath>();

        foreach (StartReference startReference in startReferences)
        {
            foreach (var targetCell in targetCells)
            {
                if (startReference.CellId == targetCell.Id)
                {
                    continue; // Skip if start and target are the same
                }

                if (targetCellsToExclude.Contains(targetCell.Id))
                {
                    continue; // Skip excluded target cells
                }

                List<int> path = FindShortestPath(startReference.CellId, targetCell.Id, int.MaxValue);
                if (path.Count > 0)
                {
                    bool isBase = startReference.PathId == -1;
                    paths.Add(new ResourcePath(idCounter, startReference.PathId, path, 1, isBase, targetCell.CellType));
                    idCounter++;
                }
            }
        }

        return paths;
    }

    internal List<int> FindShortestPath(int start, List<int> targets)
    {
        var shortestPath = new List<int>();
        var shortestLength = int.MaxValue;

        foreach (var target in targets)
        {
            var path = FindShortestPath(start, target, shortestLength);
            if (path.Count > 0 && path.Count < shortestLength)
            {
                shortestPath = path;
                shortestLength = path.Count;
            }
        }

        return shortestPath;
    }

    internal List<int> FindShortestPath(int start, int target, int cutoff)
    {
        var path = new List<int>();
        var visited = new HashSet<int>();
        var parent = new Dictionary<int, int>();

        var queue = new Queue<int>();
        queue.Enqueue(start);
        visited.Add(start);
        
        while (queue.Count > 0)
        {
            var current = queue.Dequeue();
            if (current == target)
            {
                while (current != start)
                {
                    path.Add(current);

                    if (path.Count > cutoff)
                    {
                        Console.Error.WriteLine($"Path from {start} to {target} exceeds cutoff of {cutoff}");
                        return new List<int>();
                    }

                    current = parent[current];
                }

                path.Add(start);
                path.Reverse();

                return path;
            }
            if (_cells.ContainsKey(current))
            {
                foreach (var neighbourId in _cells[current].NeighbourIds)
                {
                    if (!visited.Contains(neighbourId))
                    {
                        visited.Add(neighbourId);
                        queue.Enqueue(neighbourId);
                        parent[neighbourId] = current;
                    }
                }
            }
        }

        Console.Error.WriteLine($"ERROR: No path found from {start} to {target}");
        return new List<int>();
    }

    internal List<int> FindShortestTargetedPathToBase(int start, List<int> playerBases, Dictionary<int, int> targetedCells)
    {
        var shortestPath = new List<int>();
        var shortestLength = int.MaxValue;

        foreach (var playerBase in playerBases)
        {
            var path = FindShortestTargetedPath(start, playerBase, targetedCells, shortestLength);
            if (path.Count > 0 && path.Count < shortestLength)
            {
                shortestPath = path;
                shortestLength = path.Count;
            }
        }

        if (shortestPath.Count == 0)
        {
            Console.Error.WriteLine($"ERROR: No path found from {start} to any of the targets: {string.Join(", ", playerBases)}");
        }

        return shortestPath;
    }

    // Finds the shortest path in targetedCells
    private List<int> FindShortestTargetedPath(int start, int target, Dictionary<int, int> targetedCells, int cutoff)
    {
        var path = new List<int>();
        var visited = new HashSet<int>();
        var parent = new Dictionary<int, int>();

        var queue = new Queue<int>();
        queue.Enqueue(start);
        visited.Add(start);

        while (queue.Count > 0)
        {
            var current = queue.Dequeue();
            if (current == target)
            {
                while (current != start)
                {
                    path.Add(current);

                    if (path.Count > cutoff)
                    {
                        Console.Error.WriteLine($"Path from {start} to {target} exceeds cutoff of {cutoff}");
                        return new List<int>();
                    }

                    current = parent[current];
                }

                path.Add(start);
                path.Reverse();

                return path;
            }
            if (targetedCells.ContainsKey(current))
            {
                foreach (var neighbourId in _cells[current].NeighbourIds)
                {
                    if (!visited.Contains(neighbourId))
                    {
                        visited.Add(neighbourId);
                        queue.Enqueue(neighbourId);
                        parent[neighbourId] = current;
                    }
                }
            }
        }

        Console.Error.WriteLine($"ERROR: No path found from {start} to {target}");
        return new List<int>();
    }

    internal List<int> FindShortestOpponentPathToBase(int start, List<int> targets)
    {
        var shortestPath = new List<int>();
        var shortestLength = int.MaxValue;

        foreach (var target in targets)
        {
            var path = FindShortestOpponentPath(start, target, shortestLength);
            if (path.Count > 0 && path.Count < shortestLength)
            {
                shortestPath = path;
                shortestLength = path.Count;
            }
        }

        if (shortestPath.Count == 0)
        {
            Console.Error.WriteLine($"No path found from {start} to any of the targets: {string.Join(", ", targets)}");
        }

        return shortestPath;
    }

    private List<int> FindShortestOpponentPath(int start, int target, int cutoff)
    {
        var path = new List<int>();
        var visited = new HashSet<int>();
        var parent = new Dictionary<int, int>();

        var queue = new Queue<int>();
        queue.Enqueue(start);
        visited.Add(start);

        while (queue.Count > 0)
        {
            var current = queue.Dequeue();
            if (current == target)
            {
                while (current != start)
                {
                    path.Add(current);

                    if (path.Count > cutoff)
                    {
                        Console.Error.WriteLine($"Path from {start} to {target} exceeds cutoff of {cutoff}");
                        return new List<int>();
                    }

                    current = parent[current];
                }

                path.Add(start);
                path.Reverse();

                return path;
            }
            if (_cells.ContainsKey(current) && _cells[current].opponentAntsCount > 0)
            {
                foreach (var neighbourId in _cells[current].NeighbourIds)
                {
                    if (!visited.Contains(neighbourId))
                    {
                        visited.Add(neighbourId);
                        queue.Enqueue(neighbourId);
                        parent[neighbourId] = current;
                    }
                }
            }
        }

        return new List<int>();
    }
}





class Player
{
    static void Main(string[] args)
    {
        string[] inputs;
        int numberOfCells = int.Parse(Console.ReadLine()); // amount of hexagonal cells in this map
                
        Game game = new Game(numberOfCells);

        for (int i = 0; i < numberOfCells; i++)
        {
            inputs = Console.ReadLine().Split(' ');
            int type = int.Parse(inputs[0]); // 0 for empty, 1 for eggs, 2 for crystal
            int initialResources = int.Parse(inputs[1]); // the initial amount of eggs/crystals on this cell
            int neigh0 = int.Parse(inputs[2]); // the index of the neighbouring cell for each direction
            int neigh1 = int.Parse(inputs[3]);
            int neigh2 = int.Parse(inputs[4]);
            int neigh3 = int.Parse(inputs[5]);
            int neigh4 = int.Parse(inputs[6]);
            int neigh5 = int.Parse(inputs[7]);

            int[] neighbourIds = new int[] { neigh0, neigh1, neigh2, neigh3, neigh4, neigh5 };

            var cellType = (CellType)type;

            var eggCount = 0;
            var crystalCount = 0;

            if (cellType == CellType.Egg)
            {
                eggCount = initialResources;
            }
            else if (cellType == CellType.Crystal)
            {
                crystalCount = initialResources;
            }

            var cell = new Cell(i, neighbourIds, cellType, eggCount, crystalCount);

            game.AddCell(i, cell);

        }

        int numberOfBases = int.Parse(Console.ReadLine());
        inputs = Console.ReadLine().Split(' ');
        for (int i = 0; i < numberOfBases; i++)
        {
            int myBaseIndex = int.Parse(inputs[i]);
            game.AddPlayerBase(myBaseIndex);
        }
        inputs = Console.ReadLine().Split(' ');
        for (int i = 0; i < numberOfBases; i++)
        {
            int oppBaseIndex = int.Parse(inputs[i]);
            game.AddOpponentBase(oppBaseIndex);
        }

        game.CountResourcesToBases();

        // game loop
        while (true)
        {
            Console.Error.WriteLine(Console.ReadLine());

            game.ResetCounts();

            for (int i = 0; i < numberOfCells; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                int resources = int.Parse(inputs[0]); // the current amount of eggs/crystals on this cell
                int myAnts = int.Parse(inputs[1]); // the amount of your ants on this cell
                int oppAnts = int.Parse(inputs[2]); // the amount of opponent ants on this cell

                game.UpdateCell(i, resources, myAnts, oppAnts);
                game.IncreasePlayerAntCount(myAnts);
                game.IncreaseOpponentAntCount(oppAnts);
            }

            List<string> actions = game.GetActions();

            // Write an action using Console.WriteLine()
            // To debug: Console.Error.WriteLine("Debug messages...");


            // WAIT | LINE <sourceIdx> <targetIdx> <strength> | BEACON <cellIdx> <strength> | MESSAGE <text>
            var actionList = String.Join("; ", actions);
            Console.WriteLine(actionList);
        }
    }
}

internal class ResourcePath
{
    internal int PathId { get; set; }
    internal int ParentPathId { get; set; } = -1;
    internal List<int> Path { get; set; } = new List<int>();
    public int BeaconStrength { get; }
    internal bool IsBasePath { get; set; } = false; // If the path is from a base to a resource
    internal CellType CellType { get; set; } = CellType.Empty; // Type of the resource at the end of the path

    internal ResourcePath(int pathId, int parentPathId, List<int> path, int beaconStrength, bool isBasePath, CellType cellType)
    {
        PathId = pathId;
        ParentPathId = parentPathId;
        Path = path;
        BeaconStrength = beaconStrength;
        IsBasePath = isBasePath;
        CellType = cellType;
    }
}





internal struct SimpleCell
{
    public int Id { get; set; }
    public CellType CellType { get; set; }
   internal int Resources { get; set; }

    public SimpleCell(int id, CellType cellType, int resources)
    {
        Id = id;
        CellType = cellType;
        Resources = resources;
    }
}

internal struct StartReference
{
    public int CellId;
    public int PathId;
    public int ParentPathId;

    public StartReference(int cellId, int pathId, int parentPathId)
    {
        CellId = cellId;
        ParentPathId = parentPathId;
        PathId = pathId;
    }
}



