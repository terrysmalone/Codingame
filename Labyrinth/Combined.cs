/**************************************************************
  This file was generated by FileConcatenator.
  It combined all classes in the project to work in Codingame.
  This hasn't been put in a namespace to allow for class 
  name duplicates.
***************************************************************/
using System.Drawing;
using System;

    internal enum Content
    {
        Unknown,
        Wall,
        Hollow,
        ControlRoom,
        StartPosition
    }

    internal static class ContentConverter
    {
        internal static char[,] ToCharacterGrid(Content[,] worldGrid)
        {
            var characterGrid = new char[worldGrid.GetLength(0), worldGrid.GetLength(1)];

            for (var y = 0; y < worldGrid.GetLength(1); y++)
            {
                for (var x = 0; x < worldGrid.GetLength(0); x++)
                {
                    characterGrid[x, y] = ToCharacter(worldGrid[x, y]);
                }
            }

            return characterGrid;
        }

        private static char ToCharacter(Content content)
        {
            return content switch
            {
                Content.Unknown       => '?',
                Content.Wall          => '#',
                Content.StartPosition => 'T',
                Content.Hollow        => '.',
                Content.ControlRoom   => 'C',
                _                     => '?'
            };
        }

        internal static Content ToContent(char contentChar)
        {
            return contentChar switch
            {
                '?' => Content.Unknown,
                '#' => Content.Wall,
                'T' => Content.StartPosition,
                '.' => Content.Hollow,
                'C' => Content.ControlRoom,
                _   => Content.Unknown
            };
        }
    }

    internal static class DebugViewer
    {
        internal static void PrintWorld(Content[,] worldGrid, Point characterLocation)
        {
            var characterView = ContentConverter.ToCharacterGrid(worldGrid);
            for (var y = 0; y < worldGrid.GetLength(1); y++)
            {
                for (var x = 0; x < worldGrid.GetLength(0); x++)
                {
                    if (characterLocation.X == x && characterLocation.Y == y)
                    {
                        Console.Error.Write('+');
                    }
                    else
                    {
                        Console.Error.Write(characterView[x, y]);
                    }
                }

                Console.Error.WriteLine();
            }
        }
    }


    internal sealed class Game
    {
        private int _worldWidth;
        private int _worldHeight;

        private Content[,] _worldGrid;
        private Point _characterLocation;

        private readonly int _alarmCountDown;

        private readonly Size _leftMove = new Size(-1, 0);
        private readonly Size _rightMove = new Size(1, 0);
        private readonly Size _upMove = new Size(0, -1);
        private readonly Size _downMove = new Size(0, 1);

        private readonly Size _leftLook = new Size(-3, 0);
        private readonly Size _rightLook = new Size(3, 0);
        private readonly Size _upLook = new Size(0, -3);
        private readonly Size _downLook = new Size(0, 3);

        public Game(int worldWidth, int worldHeight, int alarmCountDown)
        {
            _worldWidth = worldWidth;
            _worldHeight = worldHeight;

            _alarmCountDown = alarmCountDown;
            _worldGrid = new Content[worldWidth, worldHeight];
        }

        internal void UpdateCharacterLocation(int xPos, int yPos)
        {
            _characterLocation = new Point(xPos, yPos);
        }

        internal void UpdateWorld(Content[,] world)
        {
             _worldGrid = world.Clone() as Content[,];
        }

        public MoveDirection GetMove()
        {
             DebugViewer.PrintWorld(_worldGrid, _characterLocation);

             // if we know where the control room is
                // if we have a path back faster than the timer
                    // move back on that path
            // else

            // move to an unexplored area
            var exploreMove = GetExploreMove();

            return exploreMove;
        }
        private MoveDirection GetExploreMove()
        {
            if (ShouldMove(_characterLocation + _leftLook,
                           _characterLocation + _leftMove))
            {
                return MoveDirection.Left;
            }

            if (ShouldMove(_characterLocation + _rightLook,
                           _characterLocation + _rightMove))
            {
                return MoveDirection.Right;
            }

            if (ShouldMove(_characterLocation + _upLook,
                           _characterLocation + _upMove))
            {
                return MoveDirection.Up;
            }

            if (ShouldMove(_characterLocation + _downLook,
                           _characterLocation + _downMove))
            {
                return MoveDirection.Down;
            }

            return MoveDirection.Right;
        }

        private bool ShouldMove(Point lookPoint, Point movePoint)
        {
            // If we havent explored here
            if (lookPoint.X >= 0 && lookPoint.X <= _worldWidth-1 && lookPoint.Y >= 0 && lookPoint.Y <= _worldHeight-1
                && _worldGrid[lookPoint.X, lookPoint.Y] == Content.Unknown)
            {
                // If we can move here
                if (_worldGrid[movePoint.X, movePoint.Y] == Content.Hollow)
                {
                    return true;
                }
            }

            return false;
        }
    }

    internal enum MoveDirection
    {
        Left,
        Right,
        Up,
        Down
    }

    internal class Player
    {
        static void Main(string[] args)
        {
            string[] inputs;
            inputs = Console.ReadLine().Split(' ');
            var rows = int.Parse(inputs[0]); // number of rows.
            var columns = int.Parse(inputs[1]); // number of columns.
            var alarmCountdown = int.Parse(inputs[2]); // number of rounds between the time the alarm countdown is activated and the time the alarm goes off.

            var game = new Game(columns, rows, alarmCountdown);

            // game loop
            while (true)
            {
                inputs = Console.ReadLine().Split(' ');
                var characterLocationRow = int.Parse(inputs[0]); // row where Rick is located.
                var characterColumn = int.Parse(inputs[1]); // column where Rick is located.

                game.UpdateCharacterLocation(characterColumn, characterLocationRow);

                var world = new Content[columns, rows];

                for (var y = 0; y < rows; y++)
                {
                    var row = Console.ReadLine().ToCharArray(); // C of the characters in '#.TC?' (i.e. one line of the ASCII maze).

                    for (var x = 0; x < columns; x++)
                    {
                        world[x, y] = ContentConverter.ToContent(row[x]);
                    }
                }

                game.UpdateWorld(world);

                var moveDirection = game.GetMove() switch
                {
                    MoveDirection.Right => "RIGHT",
                    MoveDirection.Left => "LEFT",
                    MoveDirection.Up => "UP",
                    MoveDirection.Down => "DOWN",
                    _ => "RIGHT"
                };

                // Write an action using Console.WriteLine()
                // To debug: Console.Error.WriteLine("Debug messages...");

                Console.WriteLine(moveDirection); // Rick's next move (UP DOWN LEFT or RIGHT).
            }
        }
    }
