/**************************************************************
  This file was generated by FileConcatenator.
  It combined all classes in the project to work in Codingame.
***************************************************************/

using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Net;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Linq;
using System.Diagnostics;
using System.IO;
using System.Threading;
using static System.Collections.Specialized.BitVector32;
using static System.Formats.Asn1.AsnWriter;
using System.ComponentModel;

internal sealed class AStar
{
    private int _diagnosticCount = 0;

    private readonly Game _game;

    private List<Node> _nodes = new List<Node>();

    internal AStar(Game game)
    {
        _game = game;
    }

    internal List<Point> GetShortestPath(Point startPoint, Point targetPoint, int maxDistance)
    {
        return GetShortestPath(startPoint, targetPoint, maxDistance, GrowStrategy.NO_PROTEINS);
    }

    internal List<Point> GetShortestPath(Point startPoint, Point targetPoint, int maxDistance, GrowStrategy growStrategy)
    {
        _diagnosticCount = 0;
        _nodes = new List<Node>();

        // Create a node for the start Point
        Node currentNode = new Node(startPoint);

        _nodes.Add(currentNode);

        bool targetFound = false;

        int timeToSearch = 0;
        while (!targetFound)
        {
            if (_nodes.Count(n => n.Closed == false) == 0)
            {
                return new List<Point>();
            }

            Point[] pointsToCheck = new Point[4];

            pointsToCheck[0] = new Point(currentNode.Position.X, currentNode.Position.Y + 1);
            pointsToCheck[1] = new Point(currentNode.Position.X + 1, currentNode.Position.Y);
            pointsToCheck[2] = new Point(currentNode.Position.X, currentNode.Position.Y - 1);
            pointsToCheck[3] = new Point(currentNode.Position.X - 1, currentNode.Position.Y);

            // for each adjacent square
            foreach (Point pointToCheck in pointsToCheck)
            {
                _diagnosticCount++;
                Node? existingNode = _nodes.SingleOrDefault(n => n.Position == pointToCheck);

                // If a node doesnt exists  
                if (existingNode == null)
                {
                    // Create a node if the position is walkable
                    if (pointToCheck == startPoint || pointToCheck == targetPoint || MapChecker.CanGrowOn(pointToCheck, _game, growStrategy))
                    {                        
                        Node node = new Node(pointToCheck);

                        node.Parent = currentNode.Position;

                        node.G = currentNode.G + 1;

                        if (node.G > maxDistance)
                            continue;

                        node.H = MapChecker.CalculateManhattanDistance(pointToCheck, targetPoint);
                        node.F = node.G + node.H;

                        _nodes.Add(node);
                    }
                }
                else
                {
                    if (!existingNode.Closed)
                    {
                        int g = currentNode.G + 1;

                        if (g < existingNode.G)
                        {
                            existingNode.G = g;

                            if (existingNode.G > maxDistance)
                                continue;

                            existingNode.F = existingNode.G + existingNode.H;

                            existingNode.Parent = currentNode.Position;
                        }
                    }
                }
            }

            currentNode.Closed = true;

            if (currentNode.Position == targetPoint)
            {
                targetFound = true;
            }
            else
            {
                // Sort nodes
                _nodes = _nodes.OrderBy(n => n.Closed == true).ThenBy(n => n.F).ToList();

                currentNode = _nodes.First();
            }

            timeToSearch++;

            if (timeToSearch > 1000)
            {
                Console.Error.WriteLine("Warning: Time to search hit 1000");
            }
        }

        int numberOfSteps = currentNode.G;

        List<Point> shortestPath = new List<Point>();
        shortestPath.Add(currentNode.Position);

        bool atStart = false;

        while (!atStart)
        {
            currentNode = _nodes.Single(n => n.Position == currentNode.Parent);

            if (currentNode.Position == startPoint)
            {
                atStart = true;
            }
            else
            {
                shortestPath.Insert(0, currentNode.Position);
            }
        }

        return shortestPath;
    }

    internal int GetDiagnosticCount()
    {
        return _diagnosticCount;
    }
}


internal static class CostCalculator
{
    internal static bool CanProduceOrgan(OrganType organ, ProteinStock proteinStock)
    {
        return CanProduceOrgan(organ, proteinStock, 1);
    }

    internal static bool CanProduceOrgan(OrganType organ, ProteinStock proteinStock, int amount)
    {
        switch (organ)
        {
            case OrganType.BASIC:
                if (proteinStock.A >= (1 * amount))
                {
                    return true;
                }
                return false;
            case OrganType.HARVESTER:
                if (proteinStock.C >= (1 * amount) &&
                    proteinStock.D >= (1 * amount))
                {
                    return true;
                }
                return false;
            case OrganType.ROOT:
                if (proteinStock.A >= (1 * amount) &&
                    proteinStock.B >= (1 * amount) &&
                    proteinStock.C >= (1 * amount) &&
                    proteinStock.D >= (1 * amount))
                {
                    return true;
                }
                return false;
            case OrganType.SPORER:
                if (proteinStock.B >= (1 * amount) &&
                    proteinStock.D >= (1 * amount))
                {
                    return true;
                }
                return false;
            case OrganType.TENTACLE:
                if (proteinStock.B >= (1 * amount) &&
                    proteinStock.C >= (1 * amount))
                {
                    return true;
                }
                return false;
        }

        return false;
    }
}


internal static class Display
{
    internal static void Summary(Game game)
    {
        Console.Error.WriteLine($"PROTEINS");
        Proteins(game.Proteins);
        Console.Error.WriteLine("==================================");

        Console.Error.WriteLine($"ORGANISMS");
        Console.Error.WriteLine("----------------------------------");
        Console.Error.WriteLine($"Player organisms");
        Organisms(game.PlayerOrganisms);
        Console.Error.WriteLine("----------------------------------");
        Console.Error.WriteLine($"Opponent organisms");
        Organisms(game.OpponentOrganisms);
        Console.Error.WriteLine("==================================");

        Console.Error.WriteLine($"PROTEIN STOCK");
        Console.Error.WriteLine("----------------------------------");
        Console.Error.WriteLine($"Player protein stock");
        ProteinStock(game.PlayerProteinStock);
        Console.Error.WriteLine("----------------------------------");
        Console.Error.WriteLine($"Opponent protein stock");
        ProteinStock(game.OpponentProteinStock);
        Console.Error.WriteLine("==================================");
    }

    internal static void ProteinStock(ProteinStock proteinStock)
    {
        Console.Error.WriteLine($"A: {proteinStock.A}");
        Console.Error.WriteLine($"B: {proteinStock.B}");
        Console.Error.WriteLine($"C: {proteinStock.C}");
        Console.Error.WriteLine($"D: {proteinStock.D}");
    }

    internal static void Proteins(List<Protein> proteins)
    {
        Console.Error.WriteLine($"Proteins");

        proteins.ForEach(p =>
            Console.Error.WriteLine($"Type:{p.Type} - Position:({p.Position.X},{p.Position.Y}) - BeingHarvested:{p.IsHarvested}"));
    }

    internal static void Organisms(List<Organism> organisms)
    {
        foreach (Organism organism in organisms)
        {
            Organism(organism);
            Console.Error.WriteLine("-----------------------------------");
        }
    }

    internal static void Organism(Organism organism)
    {
        foreach (Organ organ in organism.Organs)
        {
            switch (organ.Type)
            {
                case OrganType.BASIC:
                case OrganType.ROOT:
                    Console.Error.WriteLine($" ID:{organ.Id} - Type:{organ.Type.ToString()} - Position:({organ.Position.X},{organ.Position.Y})");
                    break;

                case OrganType.HARVESTER:
                case OrganType.SPORER:
                    Console.Error.WriteLine($" ID:{organ.Id} - Type:{organ.Type.ToString()} - Position:({organ.Position.X},{organ.Position.Y}) - Direction:{organ.Direction.ToString()}");
                    break;
            }
        }
    }

    internal static void Nodes(List<Node> nodes)
    {
        nodes.ForEach(n =>
            Console.Error.WriteLine($"Position:({n.Position.X},{n.Position.Y}) - Closed:{n.Closed}"));
    }

    internal static void Map(Game game)
    {
        string[,] map = new string[game.Width, game.Height];

        for (int y = 0; y < game.Height; y++)
        {
            for (int x = 0; x < game.Width; x++)
            {
                map[x, y] = " ";
            }
        }

        foreach (Point wall in game.Walls)
        {
            map[wall.X, wall.Y] = "X";
        }

        foreach (Protein protein in game.Proteins)
        {
            map[protein.Position.X, protein.Position.Y] = protein.Type.ToString();
        }

        foreach (Organism organism in game.PlayerOrganisms)
        {
            foreach (Organ organ in organism.Organs)
            {
                map[organ.Position.X, organ.Position.Y] = "O";
            }
        }

        foreach (Organism organism in game.OpponentOrganisms)
        {
            foreach (Organ organ in organism.Organs)
            {
                map[organ.Position.X, organ.Position.Y] = "o";
            }
        }

        Console.Error.WriteLine("----------");
        for (int y = 0; y < game.Height; y++)
        {
            string row = "|";

            for (int x = 0; x < game.Width; x++)
            {
                row += map[x, y];
            }

            row += "|";

            Console.Error.WriteLine(row);
        }
        Console.Error.WriteLine("----------");
    }

    internal static void Path(List<Point> path)
    {
        string pathText = string.Empty;

        foreach (Point point in path)
        {
            pathText += $"({point.X},{point.Y}) ->";
        }

        Console.Error.WriteLine(pathText);
    }

    internal static void TimeStamp(long totalTime, long segmentTime, string task)
    {
        TimeSpan total = TimeSpan.FromTicks(totalTime);
        TimeSpan segment = TimeSpan.FromTicks(segmentTime);
        Console.Error.WriteLine($"{total.Milliseconds}ms-{segment.Milliseconds}ms-{task}");
    }
}


internal sealed class Game
{
    internal int Width { get; private set; }
    internal int Height { get; private set; }

    internal List<Organism> PlayerOrganisms { get; private set; }
    internal List<Organism> OpponentOrganisms { get; private set; }

    internal ProteinStock PlayerProteinStock { get; private set; }
    internal ProteinStock OpponentProteinStock { get; private set; }
    
    public List<Point> Walls { get; private set; }
    public List<Protein> Proteins { get; private set; }

    private bool[,] _sporerPoints;

    internal bool[,] isBlocked;
    internal bool[,] hasAnyProtein;
    internal bool[,] hasHarvestedProtein;
    internal bool[,] opponentOrgans;
    internal bool[,] opponentOrganEdges;

    private Stopwatch _timer;
    private long _totalTime;
    private long _segmentTime;

    private List<int> _createdSporer = new List<int>();
    
    private readonly List<Point> _directions = new List<Point>
    {
        new Point(0, 1),
        new Point(0, -1),
        new Point(1, 0),
        new Point(-1, 0)
    };

    internal Game(int width, int height)
    {
        Width = width;
        Height = height;

        PlayerOrganisms = new List<Organism>();
        OpponentOrganisms = new List<Organism>();

        Walls = new List<Point>();
        Proteins = new List<Protein>();
    }

    internal void SetPlayerProteinStock(ProteinStock playerProteins) => PlayerProteinStock = playerProteins;

    internal void SetOpponentProteinStock(ProteinStock opponentProteins) => OpponentProteinStock = opponentProteins;

    internal void SetPlayerOrganisms(List<Organism> playerOrganisms) => PlayerOrganisms = playerOrganisms;

    internal void SetOpponentOrganisms(List<Organism> opponentOrganisms) => OpponentOrganisms = opponentOrganisms;

    internal void SetWalls(List<Point> walls) => Walls = walls;

    internal void SetProteins(List<Protein> proteins) => Proteins = proteins;

    internal List<string> GetActions()
    {
        _totalTime = 0;
        _timer = new Stopwatch();
        _timer.Start();

        _sporerPoints = new bool[Width, Height];

        UpdateMaps();

        DisplayTime("Updated maps");
        
        // TODO: Add an Action struct to prioritise different actions and choose
        // between them

        CheckForHarvestedProtein();
        DisplayTime("Updated check for harvested protein");
   
        List<string> actions = new List<string>();

        // TODO: I still think Harvesting should be the top priority.
        // //    It's currently after sporing

        int maxProteinDistance = 5;
        int minRootSporerDistance = 4;

        if (PlayerOrganisms.Count < 2)
        {
            maxProteinDistance = 1;
            minRootSporerDistance = 3;
        }
        else if (PlayerOrganisms.Count < 3)
        {
            maxProteinDistance = 3;
        }

        foreach (Organism organism in PlayerOrganisms)
        {
            Console.Error.WriteLine("-------------------------------------");
            Console.Error.WriteLine($"Checking organism: {organism.RootId}");
            string action = string.Empty;

            if (string.IsNullOrEmpty(action))
            {
                action = CheckForTentacleAction(organism);
                DisplayTime("Checked for tentacle action");
            }

            (int closestOrgan, List<Point> shortestPath) = 
                GetShortestPathToProtein(organism, Proteins, 2, 10, GrowStrategy.NO_PROTEINS);

            DisplayTime("Checked for shortest path to protein");

            Console.Error.WriteLine($"Closest organ:{closestOrgan}");
            Console.Error.WriteLine($"Shortest path:{shortestPath.Count}");
            if (shortestPath.Count > 0)
            {
                Display.Path(shortestPath);
            }

            if (string.IsNullOrEmpty(action) && !_createdSporer.Contains(organism.RootId))
            {
                action = CheckForHarvestAction(closestOrgan, shortestPath, maxProteinDistance);
                DisplayTime("Checked for harvest action");
            }

            if (string.IsNullOrEmpty(action))
            {
                Console.Error.WriteLine("Update sporer spawn points");
                UpdateSporerSpawnPoints();
                DisplayTime("Updated sporer spawn points");
                action = CheckForSporeRootAction(organism, minRootSporerDistance);
                DisplayTime("Checked for spore root action");
            }

            // We skipped this earlier to check for a sporer action.
            // We obviously didn't find one. Try it now.
            if (string.IsNullOrEmpty(action) && _createdSporer.Contains(organism.RootId))
            {
                action = CheckForHarvestAction(closestOrgan, shortestPath, maxProteinDistance);
                DisplayTime("Checked for harvest action");
            }

            _createdSporer.Remove(organism.RootId);

            if (string.IsNullOrEmpty(action))
            {
                action = CheckForSporerAction(organism, minRootSporerDistance);
                DisplayTime("Checked for sporer action");
            }

            if (string.IsNullOrEmpty(action))
            {
                // We've already pretty much tried this as part of the 
                // Harvester check but do it again now since we're willing 
                // to go a further now
                action = CheckForMovementAction(closestOrgan, shortestPath);
                DisplayTime("Checked for movement action");
            }

            // If we've gotten this far without getting a move things are 
            // desterate. We're either truly blocked or we've blocked ourselves
            // by not wanting to grow over proteins. Try that now
            if (string.IsNullOrEmpty(action))
            {
                action = GetDesperateDestructiveMove(organism, GrowStrategy.UNHARVESTED);
                DisplayTime("Checked for desperate action");
            }

            // We're even more desperate now. Lets consider growing on harvested 
            // proteins
            if (string.IsNullOrEmpty(action))
            {
                action = GetDesperateDestructiveMove(organism, GrowStrategy.ALL_PROTEINS);
                DisplayTime("Checked for very desperate action");
            }

            // If there wasn't a protein to go to just spread randomly...for now
            if (string.IsNullOrEmpty(action) &&
                CostCalculator.CanProduceOrgan(OrganType.BASIC, PlayerProteinStock))
            {                
                action = GetRandomBasicGrow(organism);
                DisplayTime("Checked for random move action");
            }

            if (string.IsNullOrEmpty(action))
            {
                action = "WAIT";
            }

            actions.Add(action);
        }

        DisplayTime("Done");

        _timer.Stop();

        return actions;
    }

    private void DisplayTime(string message)
    {
        long segmentTime = _timer.ElapsedTicks;
        _totalTime += segmentTime;
        Display.TimeStamp(_totalTime, segmentTime, message);
        _timer.Restart();
    }

    private string CheckForTentacleAction(Organism organism)
    {
        if (CostCalculator.CanProduceOrgan(OrganType.TENTACLE, PlayerProteinStock))
        {    
            foreach (Organ organ in organism.Organs)
            {
                // Console.Error.WriteLine($"Checking organ: {organ.Id}");

                Point organPoint = organ.Position;

                foreach (Point direction in _directions)
                {
                    Point checkPoint = new Point(organPoint.X + direction.X,
                                                 organPoint.Y + direction.Y);

                    // Console.Error.WriteLine($"Checking point {checkPoint.X},{checkPoint.Y}");

                    // TODO: I can't grow a tentacle in front of an opponent tentacle
                    //       THis can be updated in the opponent edges map
                    if (MapChecker.CanGrowOn(checkPoint,
                                             this,
                                             GrowStrategy.ALL_PROTEINS))
                    {
                        // Console.Error.WriteLine("Can grow");
                        if (opponentOrganEdges[checkPoint.X, checkPoint.Y])
                        {
                            // Console.Error.WriteLine("FOUND OPPONENT EDGE");

                            string dir = string.Empty;

                            if (checkPoint.Y - 1 >= 0 && opponentOrgans[checkPoint.X, checkPoint.Y - 1])
                            {
                                dir = "N";
                            }
                            else if (checkPoint.X + 1 < Width && opponentOrgans[checkPoint.X + 1, checkPoint.Y])
                            {
                                dir = "E";
                            }
                            else if (checkPoint.Y + 1 < Height && opponentOrgans[checkPoint.X, checkPoint.Y + 1])
                            {
                                dir = "S";
                            }
                            else if (checkPoint.X - 1 >= 0 && opponentOrgans[checkPoint.X-1, checkPoint.Y])
                            {
                                dir = "W";
                            }

                            return $"GROW {organ.Id} {checkPoint.X} {checkPoint.Y} TENTACLE {dir}";
                        }
                    }
                }
            }
        }

        return string.Empty;
    }

    internal void UpdateMaps()
    {
        // Reset them all at the start because some of the calculation 
        // will make changes to the others.
        isBlocked = new bool[Width, Height];

        hasHarvestedProtein = new bool[Width, Height];
        hasAnyProtein = new bool[Width, Height];

        opponentOrgans = new bool[Width, Height];
        opponentOrganEdges = new bool[Width, Height];

        UpdateIsBlocked();
        UpdateHasProteins();
        UpdateOpponentOrgans();
    }

    private void UpdateOpponentOrgans()
    {
        foreach (Organism organism in OpponentOrganisms)
        {
            foreach (Organ organ in organism.Organs)
            {
                opponentOrgans[organ.Position.X, organ.Position.Y] = true;

                // We can't walk on an outward facing tentacle
                // So add these to the isBlocked list and not to the valid edges

                // North
                if (organ.Position.Y - 1 >= 0)
                {
                    if (organ.Type == OrganType.TENTACLE && organ.Direction == OrganDirection.N)
                    {
                        isBlocked[organ.Position.X, organ.Position.Y - 1] = true;
                    }
                    else
                    {
                        opponentOrganEdges[organ.Position.X, organ.Position.Y - 1] = true;
                    }
                }

                // East
                if (organ.Position.X + 1 < Width)
                {
                    if (organ.Type == OrganType.TENTACLE && organ.Direction == OrganDirection.E)
                    {
                        isBlocked[organ.Position.X + 1, organ.Position.Y] = true;
                    }
                    else
                    {
                        opponentOrganEdges[organ.Position.X + 1, organ.Position.Y] = true;
                    }
                }

                // South
                if (organ.Position.Y + 1 < Height)
                {
                    if (organ.Type == OrganType.TENTACLE && organ.Direction == OrganDirection.S)
                    {
                        isBlocked[organ.Position.X, organ.Position.Y + 1] = true;
                    }
                    else
                    {
                        opponentOrganEdges[organ.Position.X, organ.Position.Y + 1] = true;
                    }
                }

                // WEST
                if (organ.Position.X - 1 >= 0)
                {
                    if (organ.Type == OrganType.TENTACLE && organ.Direction == OrganDirection.W)
                    {
                        isBlocked[organ.Position.X - 1, organ.Position.Y] = true;
                    }
                    else
                    {
                        opponentOrganEdges[organ.Position.X - 1, organ.Position.Y] = true;
                    }
                }
            }
        }
    }

    private void UpdateIsBlocked()
    {
        // Not walkable if player organ on that spot
        foreach (Organism organism in PlayerOrganisms)
        {
            foreach (Organ organ in organism.Organs)
            {
                isBlocked[organ.Position.X, organ.Position.Y] = true;
            }
        }

        // Not walkable if opponent organ on that spot
        foreach (Organism organism in OpponentOrganisms)
        {
            foreach (Organ organ in organism.Organs)
            {
                isBlocked[organ.Position.X, organ.Position.Y] = true;
            }
        }

        // Not walkable if wall on that spot
        foreach (Point wall in Walls)
        {
            isBlocked[wall.X, wall.Y] = true;
        }
    }

    private void UpdateHasProteins()
    {
        foreach (Protein protein in Proteins)
        {
            if (protein.IsHarvested)
            {
                hasHarvestedProtein[protein.Position.X, protein.Position.Y] = true;
                hasAnyProtein[protein.Position.X, protein.Position.Y] = true;
            }
            else
            {
                hasAnyProtein[protein.Position.X, protein.Position.Y] = true;
            }
        }
    }

    private void UpdateSporerSpawnPoints()
    {
        foreach (Protein protein in Proteins.Where(p => !p.IsHarvested))
        {
            List<Point> possibleRootPoints = MapChecker.GetRootPoints(protein.Position, this);
            foreach (var possPoint in possibleRootPoints)
            {
                if (!MapChecker.HasNearbyOrgan(possPoint, PlayerOrganisms))
                {
                    _sporerPoints[possPoint.X, possPoint.Y] = true;
                }
            }

            // Console.Error.WriteLine($"{possibleRootPoints.Count} possible root points added for protein {protein.Position.X},{protein.Position.Y}");
        }
    }

    // Check to see if any protein is being harvested and mark it as such
    private void CheckForHarvestedProtein()
    {
        foreach (Organism organism in PlayerOrganisms)
        {
            foreach (Organ organ in organism.Organs)
            {
                if (organ.Type == OrganType.HARVESTER)
                {
                    Point harvestedPosition = GetHarvestedPosition(organ);

                    if(Proteins.Any(p => p.Position == harvestedPosition))
                    {
                        Protein havestedProtein = Proteins.Single(p => p.Position == harvestedPosition);

                        havestedProtein.IsHarvested = true;
                    }
                }
            }
        }

        // We don't care about enemy harvested proteins because
        // we're still happy to consume them.
    }

    private string CheckForHarvestAction(int closestOrgan, List<Point> shortestPath, int maxProteinDistance)
    {
        string action = string.Empty;

        if (closestOrgan != -1)
        {
            // TODO: If we can't harvest, check if we can consume the organisms needed
            //       to create a harvester

            // See if we can make a harvester
            if (CostCalculator.CanProduceOrgan(OrganType.HARVESTER, PlayerProteinStock) &&
                Proteins.Exists(p => p.IsHarvested == false))
            {
                if (shortestPath.Count == 2)
                {
                    string dir = GetDirection(shortestPath[0], shortestPath[1]);

                    action = $"GROW {closestOrgan} {shortestPath[0].X} {shortestPath[0].Y} HARVESTER {dir}";
                }
            }

            int maxWalkingDistance = Math.Min(maxProteinDistance, PlayerProteinStock.A);

            if (string.IsNullOrEmpty(action) && (shortestPath.Count <= maxWalkingDistance))
            {
                // Grow towards the nearest protein
                // Grow towards the nearest protein
                string direction = CalculateClosestOpponentDirection(OpponentOrganisms, shortestPath[0]);

                // If we can make it a tentacle and still have some spare proteins then do it
                if (CostCalculator.CanProduceOrgan(OrganType.TENTACLE, PlayerProteinStock, 5))
                {
                    action = $"GROW {closestOrgan} {shortestPath[0].X} {shortestPath[0].Y} TENTACLE {direction}";
                }
                else if (CostCalculator.CanProduceOrgan(OrganType.BASIC, PlayerProteinStock))
                {
                    action = $"GROW {closestOrgan} {shortestPath[0].X} {shortestPath[0].Y} BASIC";
                }
            }
        }

        return action;
    }

    private string CheckForSporerAction(Organism organism, int minRootSporerDistance)
    {
        string action = string.Empty;

        if (CostCalculator.CanProduceOrgan(OrganType.ROOT, PlayerProteinStock) &&
            CostCalculator.CanProduceOrgan(OrganType.SPORER, PlayerProteinStock))
        {
            int furthestDistance = -1;
            int furthestOrgan = -1;
            Point furthestSporerPoint = new Point(0, 0);
            string furthestDirection = string.Empty;

            // for each organ
            foreach (Organ organ in organism.Organs)
            {
                Point organPoint = organ.Position;
                List<Point> directions = new List<Point>();

                // Check south
                if (organPoint.Y <= Height - minRootSporerDistance - 1)
                {
                    directions.Add(new Point(0, 1));
                }

                // Check North
                if (organPoint.Y >= minRootSporerDistance)
                {
                    directions.Add(new Point(0, -1));
                }

                // Check East
                if (organPoint.X <= Width - minRootSporerDistance - 1)
                {
                    directions.Add(new Point(1, 0));
                }

                // Check West
                if (organPoint.X >= minRootSporerDistance)
                {
                    directions.Add(new Point(-1, 0));
                }

                // Check the four points around the organ
                foreach (Point side in directions)
                {
                    Point sporerPoint = new Point(organPoint.X + side.X,
                                                  organPoint.Y + side.Y);

                    if (!MapChecker.CanGrowOn(sporerPoint, this, GrowStrategy.NO_PROTEINS))
                    {
                        continue;
                    }

                    // Check in all 4 directions
                    foreach (Point direction in directions)
                    {
                        Point checkPoint = new Point(sporerPoint.X,
                                                     sporerPoint.Y);

                        int distance = 1;
                        bool pathClear = true;
                        while (pathClear)
                        {
                            checkPoint = new Point(checkPoint.X + direction.X,
                                                   checkPoint.Y + direction.Y);

                            // Console.Error.WriteLine($"Checking point {checkPoint.X},{checkPoint.Y}");

                            if (checkPoint.X < 0) { break; }

                            if (checkPoint.X >= Width) { break; }

                            if (checkPoint.Y < 0) { break; }

                            if (checkPoint.Y >= Height) { break; }

                            if (distance >= minRootSporerDistance)
                            {
                                // Console.Error.WriteLine($"Distance viable");
                                //    if it's on a spawn point 
                                if (_sporerPoints[checkPoint.X, checkPoint.Y])
                                {
                                    // Console.Error.WriteLine($"There's a spore point");
                                    string dir = string.Empty;

                                    if (direction.X == 1)
                                    {
                                        dir = "E";
                                    }
                                    else if (direction.X == -1)
                                    {
                                        dir = "W";
                                    }
                                    else if (direction.Y == -1)
                                    {
                                        dir = "N";
                                    }
                                    else if (direction.Y == 1)
                                    {
                                        dir = "S";
                                    }

                                    if (distance > furthestDistance)
                                    {
                                        //Console.Error.WriteLine("Added to furthestDistance");
                                        furthestDistance = distance;
                                        furthestOrgan = organ.Id;
                                        furthestSporerPoint = new Point(sporerPoint.X, sporerPoint.Y);
                                        furthestDirection = dir;
                                    }
                                }
                            }

                            if (!MapChecker.CanGrowOn(checkPoint, this, GrowStrategy.ALL_PROTEINS))
                            {
                                pathClear = false;
                            }

                            distance++;
                        }
                    }
                }
            }

            if (furthestDistance != -1)
            {
                _createdSporer.Add(organism.RootId);
                return $"GROW {furthestOrgan} {furthestSporerPoint.X} {furthestSporerPoint.Y} SPORER {furthestDirection}";
            }
        }

        return string.Empty;
    }

    private string CheckForSporeRootAction(Organism organism, int minRootSporerDistance)
    {
        if (organism.Organs.Any(o => o.Type == OrganType.SPORER) &&
                CostCalculator.CanProduceOrgan(OrganType.ROOT, PlayerProteinStock))
        {
            List<Organ> sporers = organism.Organs.Where(o => o.Type == OrganType.SPORER).ToList();

            int furthestDistance = -1;
            int furthestSporerId = -1;
            Point furthestRootPoint = new Point(0, 0);

            foreach (Organ sporer in sporers)
            {
                Point direction = new Point(0, 0);

                switch (sporer.Direction)
                {
                    case OrganDirection.N:
                        direction = new Point(0, -1);
                        break;
                    case OrganDirection.E:
                        direction = new Point(1, 0);
                        break;
                    case OrganDirection.S:
                        direction = new Point(0, 1);
                        break;
                    case OrganDirection.W:
                        direction = new Point(-1, 0);
                        break;
                }

                if (direction == new Point(0, 0))
                {
                    Console.Error.WriteLine($"ERROR: Couldn't get sporer direction for {sporer.Position.X}{sporer.Position.Y}");
                }

                Point checkPoint = new Point(sporer.Position.X, sporer.Position.Y);

                int distance = 1;
                bool pathClear = true;
                while (pathClear)
                {
                    checkPoint = new Point(checkPoint.X + direction.X,
                                           checkPoint.Y + direction.Y);

                    // Console.Error.WriteLine($"checkPoint {checkPoint.X},{checkPoint.Y}");

                    if (checkPoint.X < 0) { break; }

                    if (checkPoint.X >= Width) { break; }

                    if (checkPoint.Y < 0) { break; }

                    if (checkPoint.Y >= Height) { break; }

                    if (distance >= minRootSporerDistance)
                    {
                        Console.Error.WriteLine($"Distance viable");
                        //    if it's on a spawn point 
                        if (_sporerPoints[checkPoint.X, checkPoint.Y])
                        {
                            if (distance > furthestDistance)
                            {
                                furthestDistance = distance;
                                furthestSporerId = sporer.Id;
                                furthestRootPoint = checkPoint;
                            }
                        }
                    }

                    if (!MapChecker.CanGrowOn(checkPoint, this, GrowStrategy.ALL_PROTEINS))
                    {
                        Console.Error.WriteLine($"Path not clear");

                        pathClear = false;
                    }

                    distance++;
                }
            }

            if (furthestDistance != -1)
            {
                return $"SPORE {furthestSporerId} {furthestRootPoint.X} {furthestRootPoint.Y}";
            }
        }

        return string.Empty;
    }

    private string CheckForMovementAction(int closestOrgan, List<Point> shortestPath)
    {
        string action = string.Empty;

        if (closestOrgan != -1)
        {
            // Grow towards the nearest protein
            string direction = CalculateClosestOpponentDirection(OpponentOrganisms, shortestPath[0]);

            // If we can make it a tentacle and still have some spare proteins then do it
            if (CostCalculator.CanProduceOrgan(OrganType.TENTACLE, PlayerProteinStock, 5))
            {
                action = $"GROW {closestOrgan} {shortestPath[0].X} {shortestPath[0].Y} TENTACLE {direction}";
            }
            else if (CostCalculator.CanProduceOrgan(OrganType.BASIC, PlayerProteinStock))
            {
                action = $"GROW {closestOrgan} {shortestPath[0].X} {shortestPath[0].Y} BASIC";
            }
            else if (CostCalculator.CanProduceOrgan(OrganType.SPORER, PlayerProteinStock))
            {
                action = $"GROW {closestOrgan} {shortestPath[0].X} {shortestPath[0].Y} SPORER {direction}";
            }
            else if (CostCalculator.CanProduceOrgan(OrganType.HARVESTER, PlayerProteinStock))
            {
                action = $"GROW {closestOrgan} {shortestPath[0].X} {shortestPath[0].Y} HARVESTER {direction}";
            }
        }

        return action;
    }

    private static Point GetHarvestedPosition(Organ organ)
    {
        switch (organ.Direction)
        {
            case OrganDirection.N:
                return new Point(organ.Position.X, organ.Position.Y-1);
            case OrganDirection.E:
                return new Point(organ.Position.X+1, organ.Position.Y);
            case OrganDirection.S:
                return new Point(organ.Position.X, organ.Position.Y+1);
            case OrganDirection.W:
                return new Point(organ.Position.X-1, organ.Position.Y);
        }

        return new Point(-1,-1);
    }

    private string GetDirection(Point from, Point to)
    {
        string dir = "N";

        if (from.X < to.X)
        {
            dir = "E";
        }
        else if (from.X > to.X)
        {
            dir = "W";
        }
        else if (from.Y < to.Y)
        {
            dir = "S";
        }

        return dir;
    }

    private (int,List<Point>) GetShortestPathToProtein(Organism organism, List<Protein> proteins, int minDistance, int maxDistance, GrowStrategy growStrategy)
    {
        string action = string.Empty;

        int shortest = int.MaxValue;
        int closestId = -1;
        List<Point> shortestPath = new List<Point>();

        AStar aStar = new AStar(this);

        // Get the closest protein to Organs
        foreach (Protein protein in proteins)
        {
            // Console.Error.WriteLine($"Checking protein: {protein.Position.X},{protein.Position.Y}");
   
            if (protein.IsHarvested)
            {
                continue;
            }

            foreach (var organ in organism.Organs)
            {
                // Console.Error.WriteLine($"Checking organ: {organ.Position.X},{organ.Position.Y}");
                
                int manhattanDistance = MapChecker.CalculateManhattanDistance(organ.Position, protein.Position);

                // Console.Error.WriteLine($"Manhattan distance: {manhattanDistance}");
                // Console.Error.WriteLine($"Max distance: {maxDistance}");
                
                if (manhattanDistance > maxDistance)
                {
                    continue;
                }

                List<Point> path = aStar.GetShortestPath(organ.Position, protein.Position, maxDistance, growStrategy);

                    // Console.Error.WriteLine($"Shortest path count: {path.Count}");
                    //Display.Path(shortestPath);

                if (path.Count < shortest && path.Count >= minDistance && path.Count != 0)
                {
                    shortest = path.Count;
                    shortestPath = new List<Point>(path);

                    closestId = organ.Id;

                    if (shortest < maxDistance)
                    {
                        maxDistance = shortest;
                    }
                }
            }
        }

        return (closestId, shortestPath);
    }

    private string GetRandomBasicGrow(Organism organism)
    {
        string action = string.Empty;

        for (int i = organism.Organs.Count - 1; i >= 0; i--)
        {
            Organ current = organism.Organs[i];

            foreach (Point direction in _directions)
            {
                Point checkPoint = new Point(current.Position.X + direction.X, 
                                             current.Position.Y + direction.Y);

                if (MapChecker.CanGrowOn(checkPoint, this, GrowStrategy.ALL_PROTEINS))
                {
                    action = $"GROW {current.Id} {checkPoint.X} {checkPoint.Y} BASIC";

                    // TODO: Let us choose other nodes too
                    break;
                }
            }
        }

        return action;
    }

    private string GetDesperateDestructiveMove(Organism organism, GrowStrategy growStrategy)
    {
        // Display.Organisms(PlayerOrganisms);
        // TODO: I want max distance to be 2 here but then it bugs out
        (int closestOrgan, List<Point> shortestPath) = GetShortestPathToProtein(organism, Proteins, 1, 10, growStrategy);

        if (closestOrgan != -1)
        {
            string closestRootDirection = CalculateClosestOpponentDirection(OpponentOrganisms, shortestPath[0]);

            string organToGrow = string.Empty;
            if (CostCalculator.CanProduceOrgan(OrganType.TENTACLE, PlayerProteinStock))
            {
                organToGrow = $"{OrganType.TENTACLE.ToString()} {closestRootDirection}";
            }
            else if (CostCalculator.CanProduceOrgan(OrganType.BASIC, PlayerProteinStock))
            {
                organToGrow = OrganType.BASIC.ToString();
            }
            else if (CostCalculator.CanProduceOrgan(OrganType.SPORER, PlayerProteinStock))
            {
                organToGrow = $"{OrganType.SPORER.ToString()} {closestRootDirection}";
            }
            else if (CostCalculator.CanProduceOrgan(OrganType.HARVESTER, PlayerProteinStock))
            {
                organToGrow = $"{OrganType.HARVESTER.ToString()} {closestRootDirection}";
            }

            if (string.IsNullOrEmpty(organToGrow))
            {
                return string.Empty;
            }

            return $"GROW {closestOrgan} {shortestPath[0].X} {shortestPath[0].Y} {organToGrow}";
        
            // TODO: IF we can't afford a basic just make another organ type
        }

        return string.Empty;
    }

    // Calculates the direction of the closest enemy root to a given point.
    private string CalculateClosestOpponentDirection(List<Organism> opponentOrganisms, Point startPoint)
    {
        Point endPoint = GetClosestRoot(opponentOrganisms, startPoint);
        
        if (Math.Abs(endPoint.X - startPoint.X) >= Math.Abs(endPoint.Y - startPoint.Y))
        {
            // It's either east or west
            if (endPoint.X > startPoint.X)
            {
                return "E";
            }
            else
            {
                return "W";
            }
        }
        else
        {
            // It's either north or south
            if (endPoint.Y > startPoint.Y)
            {
                return "S";
            }
            else
            {
                return "N";
            }
        }
    }

    private Point GetClosestRoot(List<Organism> opponentOrganisms, Point startPoint)
    {
        int closestDistance = int.MaxValue;
        Point closestPoint = new Point(-1, -1);

        foreach (Organism opponentOrganism in OpponentOrganisms)
        {
            Organ root = opponentOrganism.Organs.Single(o => o.Type == OrganType.ROOT);

            int distance = MapChecker.CalculateManhattanDistance(root.Position, startPoint);

            if (distance < closestDistance)
            {
                closestDistance = distance;
                closestPoint = root.Position;
            }
        }

        return closestPoint;
    }
}


internal enum GrowStrategy
{
    NO_PROTEINS,
    UNHARVESTED,
    ALL_PROTEINS
}

internal static class MapChecker
{
    internal static int CalculateManhattanDistance(Point position1, Point position2)
    {
        return Math.Abs(position1.X - position2.X) + Math.Abs(position1.Y - position2.Y);
    }

    internal static bool CanGrowOn(Point pointToCheck, Game game)
    {
        return CanGrowOn(pointToCheck, game, GrowStrategy.NO_PROTEINS);
    }

    internal static bool CanGrowOn(Point pointToCheck, Game game, GrowStrategy growStrategy)
    {
        if (pointToCheck.X < 0 || 
            pointToCheck.Y < 0 || 
            pointToCheck.X >= game.Width || 
            pointToCheck.Y >= game.Height) 
        { 
            return false; 
        }

        if (game.isBlocked[pointToCheck.X, pointToCheck.Y])
        {
            return false;
        }

        if (growStrategy == GrowStrategy.NO_PROTEINS && game.hasAnyProtein[pointToCheck.X, pointToCheck.Y])
        {
            return false;
        }
        else if (growStrategy == GrowStrategy.UNHARVESTED && game.hasHarvestedProtein[pointToCheck.X, pointToCheck.Y])
        {
            return false;
        }

        return true;
    }

    internal static List<Point> GetRootPoints(Point position, Game game)
    {
        List<Point> rootPoints = new List<Point>();

        bool canGrowNorth = CanGrowOn(new Point(position.X, position.Y - 1), game);
        bool canGrowEast = CanGrowOn(new Point(position.X+1, position.Y), game);
        bool canGrowSouth = CanGrowOn(new Point(position.X, position.Y + 1), game);
        bool canGrowWest = CanGrowOn(new Point(position.X-1, position.Y), game);

        if (canGrowNorth)
        {
            Point farNorth = new Point(position.X, position.Y - 2);
            if (CanGrowOn(farNorth, game))
            {
                rootPoints.Add(farNorth);
            }
        }

        if (canGrowNorth || canGrowEast)
        {
            Point northEast = new Point(position.X + 1, position.Y - 1);
            if (CanGrowOn(northEast, game))
            {
                rootPoints.Add(northEast);
            }
        }

        if (canGrowEast)
        {
            Point farEast = new Point(position.X + 2, position.Y);
            if (CanGrowOn(farEast, game))
            {
                rootPoints.Add(farEast);
            }
        }

        if (canGrowEast ||canGrowSouth)
        {
            Point southEast = new Point(position.X + 1, position.Y + 1);
            if (CanGrowOn(southEast, game))
            {
                rootPoints.Add(southEast);
            }
        }

        if (canGrowSouth)
        {
            Point farSouth = new Point(position.X, position.Y + 2);
            if (CanGrowOn(farSouth, game))
            {
                rootPoints.Add(farSouth);
            }
        }

        if (canGrowSouth || canGrowWest)
        {
            Point southWest = new Point(position.X - 1, position.Y + 1);
            if (CanGrowOn(southWest, game))
            {
                rootPoints.Add(southWest);
            }
        }

        if (canGrowWest)
        {
            Point farWest = new Point(position.X - 2, position.Y);
            if (CanGrowOn(farWest, game))
            {
                rootPoints.Add(farWest);
            }
        }

        if (canGrowWest || canGrowNorth)
        {
            Point northWest = new Point(position.X - 1, position.Y - 1);
            if (CanGrowOn(northWest, game))
            {
                rootPoints.Add(northWest);
            }
        }

        return rootPoints;
    }

    internal static bool HasNearbyOrgan(Point point, List<Organism> playerOrganisms)
    {
        int maxDistance = 3;
        foreach (Organism organism in playerOrganisms)
        {
            foreach (Organ organ in organism.Organs)
            {
                if (Math.Abs(point.X - organ.Position.X) + Math.Abs(point.Y - organ.Position.Y) <= maxDistance)
                {
                    return true;
                }
            }
        }

        return false;
    }

    // If we can draw a line from the sporer to a root then it's spored
    internal static bool HasSporerSpored(Organ sporer, Game game)
    {
        Console.Error.WriteLine($"Checking if sporer on {sporer.Position.X},{sporer.Position.Y} has spored");
        int xDelta = 0;
        int yDelta = 0;

        switch(sporer.Direction)
        {
            case OrganDirection.N:
                xDelta = 0;
                yDelta = -1;
                break;
            case OrganDirection.E:
                xDelta = 1;
                yDelta = 0;
                break;
            case OrganDirection.S:
                xDelta = 0;
                yDelta = 1;
                break;
            case OrganDirection.W:
                xDelta = -1;
                yDelta = 0;
                break;
        }

        bool hitSomething = false;

        Point checkPoint = new Point(sporer.Position.X + xDelta, sporer.Position.Y + yDelta);

        while(!hitSomething)
        {
            foreach (Organism organism in game.PlayerOrganisms)
            {
                if(organism.Organs.Any(o => o.Type == OrganType.ROOT &&
                                            o.Position == checkPoint))
                {
                    return true;
                }
            }

            if (!CanGrowOn(checkPoint, game, GrowStrategy.UNHARVESTED))
            {
                hitSomething = true;    

            }

            checkPoint = new Point(checkPoint.X + xDelta, checkPoint.Y + yDelta);
        }

        return false;
    }
}


internal sealed class Node
{
    public Point Position { get; set; }

    public Point Parent { get; set; }

    public int G { get; set; }
    public int H { get; set; }
    public int F { get; set; }

    public bool Closed { get; set; }

    public Node(Point position)
    {
            Position = position;
    }
}


internal struct Organ
{
    internal int Id { get; private set; }
    internal int RootId { get; private set; }

    public OrganType Type { get; set; }

    internal Point Position { get; private set; }

    internal OrganDirection Direction { get; private set; }

    public Organ(int id, int rootId, OrganType type, Point position) : this()
    {
        Id = id;
        RootId = rootId;
        Type = type;
        Position = position;
    }

    public Organ(int id, int rootId, OrganType type, Point position, OrganDirection direction) : this(id, rootId, type, position)
    {
        Direction = direction;
    }
}

internal enum OrganDirection
{
    N,
    E,
    S,
    W
}

internal class Organism
{
    internal int RootId { get; private set; }

    internal List<Organ> Organs { get; private set; }

    internal Organism(int rootId)
    {
        Organs = new List<Organ>();
        RootId = rootId;
    }

    internal void AddOrgan(Organ organ)
    {
        Organs.Add(organ);
    }


}


internal enum OrganType
{
    BASIC,
    HARVESTER,
    ROOT,
    SPORER,
    TENTACLE,
}

partial class Player
{
    static void Main(string[] args)
    {
        string[] inputs;
        inputs = Console.ReadLine().Split(' ');
        int width = int.Parse(inputs[0]); // columns in the game grid
        int height = int.Parse(inputs[1]); // rows in the game grid

        Game game = new Game(width, height);

        // game loop
        while (true)
        {
            List<Organ> unsortedPlayerOrgans = new List<Organ>();
            List<Organ> unsortedOpponentOrgans = new List<Organ>();
            List<Point> walls = new List<Point>();
            List<Protein> proteins = new List<Protein>();

            int entityCount = int.Parse(Console.ReadLine());
            for (int i = 0; i < entityCount; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                int x = int.Parse(inputs[0]);
                int y = int.Parse(inputs[1]); // grid coordinate
                string type = inputs[2]; // WALL, ROOT, BASIC, TENTACLE, HARVESTER, SPORER, A, B, C, D
                int owner = int.Parse(inputs[3]); // 1 if your organ, 0 if enemy organ, -1 if neither
                int organId = int.Parse(inputs[4]); // id of this entity if it's an organ, 0 otherwise
                string organDir = inputs[5]; // N,E,S,W or X if not an organ
                int organParentId = int.Parse(inputs[6]);
                int organRootId = int.Parse(inputs[7]);

                OrganType organTypeEnum;
                if (Enum.TryParse(type, out organTypeEnum))
                {
                    switch (type)
                    {
                        case "BASIC":
                        case "ROOT":
                            if (owner == 1)
                            {
                                unsortedPlayerOrgans.Add(
                                    CreateOrgan(
                                        organId,
                                        organRootId,
                                        organTypeEnum,
                                        new Point(x, y)));
                            }
                            else if (owner == 0)
                            {
                                unsortedOpponentOrgans.Add(
                                    CreateOrgan(
                                        organId,
                                        organRootId,
                                        organTypeEnum,
                                        new Point(x, y)));
                            }

                            break;

                        case "HARVESTER":
                        case "SPORER":
                        case "TENTACLE":
                            OrganDirection dirEnum;
                            if (Enum.TryParse(organDir, out dirEnum))
                            {
                                if (owner == 1)
                                {
                                    unsortedPlayerOrgans.Add(
                                        CreateDirectionOrgan(
                                            organId,
                                            organRootId,
                                            organTypeEnum,
                                            new Point(x, y),
                                            dirEnum));
                                }
                                else if (owner == 0)
                                {
                                    unsortedOpponentOrgans.Add(
                                        CreateDirectionOrgan(
                                            organId,
                                            organRootId,
                                            organTypeEnum,
                                            new Point(x, y),
                                            dirEnum));
                                }
                            }
                            break;
                    }
                }
                else
                {
                    switch (type)
                    {
                        case "A":
                            proteins.Add(new Protein(ProteinType.A, new Point(x, y)));
                            break;
                        case "B":
                            proteins.Add(new Protein(ProteinType.B, new Point(x, y)));
                            break;
                        case "C":
                            proteins.Add(new Protein(ProteinType.C, new Point(x, y)));
                            break;
                        case "D":
                            proteins.Add(new Protein(ProteinType.D, new Point(x, y)));
                            break;
                        case "WALL":
                            walls.Add(new Point(x, y));
                            break;
                    }
                }
            }

            List<Organism> playerOrganisms = SortOrgans(unsortedPlayerOrgans);
            game.SetPlayerOrganisms(playerOrganisms);
            List<Organism> opponentOrganisms = SortOrgans(unsortedOpponentOrgans);
            game.SetOpponentOrganisms(opponentOrganisms);

            game.SetWalls(walls);
            game.SetProteins(proteins);

            ProteinStock playerProteins = GetProteins();
            game.SetPlayerProteinStock(playerProteins);

            ProteinStock opponentProteins = GetProteins();
            game.SetOpponentProteinStock(opponentProteins);

            List<string> actions = game.GetActions();

            int requiredActionsCount = int.Parse(Console.ReadLine()); // your number of organisms, output an action for each one in any order
            for (int i = 0; i < requiredActionsCount; i++)
            {
                Console.WriteLine(actions[i]);

                // Write an action using Console.WriteLine()
                // To debug: Console.Error.WriteLine("Debug messages...");

                // Console.WriteLine("WAIT");
            }
        }
    }

    private static ProteinStock GetProteins()
    {
        string[] inputs = Console.ReadLine().Split(' ');
        int proteinA = int.Parse(inputs[0]);
        int proteinB = int.Parse(inputs[1]);
        int proteinC = int.Parse(inputs[2]);
        int proteinD = int.Parse(inputs[3]);

        ProteinStock proteins = new ProteinStock(proteinA, proteinB, proteinC, proteinD);

        return proteins;
    }

    private static Organ CreateOrgan(int organId, int rootId, OrganType organType, Point point)
    {
        return new Organ(organId, rootId, organType, point);
    }

    private static Organ CreateDirectionOrgan(int organId, int rootId, OrganType organType, Point point, OrganDirection direction)
    {
        return new Organ(organId, rootId, organType, point, direction);
    }

    private static List<Organism> SortOrgans(List<Organ> unsortedOrgans)
    {
        List<Organism> organisms = new List<Organism>();

        unsortedOrgans = unsortedOrgans.OrderBy(o => o.Type != OrganType.ROOT).ToList();

        foreach (Organ organ in unsortedOrgans)
        {
            if (organ.Type == OrganType.ROOT)
            {
                Organism organism = new Organism(organ.Id);
                organism.AddOrgan(organ);
                organisms.Add(new Organism(organ.Id));
            }

            organisms.Single(o => o.RootId == organ.RootId).AddOrgan(organ);
        }

        return organisms;
    }
}

internal class Protein
{
    internal ProteinType Type { get; private set; }
    internal Point Position { get; private set; }

    internal bool IsHarvested { get; set; }

    internal Protein(ProteinType type, Point position)
    {
        Type = type;
        Position = position;
    }
}


internal struct ProteinStock(int a, int b, int c, int d)
{
    public int A { get; private set; } = a;
    public int B { get; private set; } = b;
    public int C { get; private set; } = c;
    public int D { get; private set; } = d;
}

internal enum ProteinType
{
    A,
    B,
    C,
    D
}

