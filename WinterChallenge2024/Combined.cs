/**************************************************************
  This file was generated by FileConcatenator.
  It combined all classes in the project to work in Codingame.
***************************************************************/

using System.Drawing;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;
using static System.Formats.Asn1.AsnWriter;
using System.Diagnostics;
using System.Reflection.Metadata.Ecma335;
using System.Text;
using System.Threading.Tasks;
using System.ComponentModel;

internal sealed class Action
{
    internal int OrganismId;

    internal ActionType ActionType;
    internal int OrganId;
    internal Point TargetPosition;
    internal OrganType? OrganType;
    internal OrganDirection? OrganDirection;    

    internal GoalType GoalType;
    internal ProteinType GoalProteinType;
    internal OrganType GoalOrganType;
    internal Point GoalPosition = new Point(-1, -1);
    internal int TurnsToGoal;

    internal int Score = 0;
    internal ActionSource Source = ActionSource.NONE;
    internal bool BlockC = false;
    internal bool BlockD = false;

    public override string ToString()
    {
        if (ActionType == ActionType.GROW)
        {
            string action = $"GROW {OrganId} {TargetPosition.X} {TargetPosition.Y} {OrganType.ToString()}";

            if (OrganDirection != null)
            {
                action += $" {OrganDirection.ToString()}";
            }

            return action;
        }
        else if (ActionType == ActionType.SPORE)
        {
            return $"SPORE {OrganId} {TargetPosition.X} {TargetPosition.Y}";
        }
        else if (ActionType == ActionType.WAIT)
        {
            return "WAIT";
        }

        return string.Empty;
    }
}

internal enum ActionSource
{
    NONE,
    FINAL_WAIT,
    CHECK_FOR_TENTACLES,
    CHECK_FOR_SPORER,
    CHECK_FOR_ROOT,
    VERY_DESPERATE_DESTRUCTIVE_MOVE,
    RANDOM_GROW_ACTIONS,
    END_GAME_DESTROY,
    CHECK_FOR_HARVESTS,
    DESPERATE_DESTRUCTIVE_MOVE,
}

internal sealed class ActionFinder
{
    private readonly Game _game;
    private readonly DirectionCalculator _directionCalculator;
    private readonly AStar _aStar;

    private List<Protein> _proteinsToCheck = new List<Protein>();

    public ActionFinder(Game game, DirectionCalculator directionCalculator)
    {
        _game = game;
        _directionCalculator = directionCalculator;
        _aStar = new AStar(game);
    }

    internal List<Action> GetProteinActions(Organism organism, List<Protein> proteins)
    {
        List<Action> actions = new List<Action>();

        _proteinsToCheck = new List<Protein>();

        foreach (Protein protein in proteins)
        {
            // If it's harvested or blocked (this can only be from a tentacle facing it) then ignore it
            if (!protein.IsHarvested && !_game.opponentTentaclePath[protein.Position.X, protein.Position.Y])
            {
                _proteinsToCheck.Add(protein.Clone());
            }
        }

        if (_proteinsToCheck.Count == 0) return actions;

        actions.AddRange(GetShortestPathsToProteins(organism, 1, GrowStrategy.ALL_PROTEINS));
        if (_proteinsToCheck.Count == 0) return actions;

        actions.AddRange(GetShortestPathsToProteins(organism, 2, GrowStrategy.NO_PROTEINS));
        if (_proteinsToCheck.Count == 0) return actions;
        actions.AddRange(GetShortestPathsToProteins(organism, 2, GrowStrategy.UNHARVESTED));
        if (_proteinsToCheck.Count == 0) return actions;

        actions.AddRange(GetShortestPathsToProteins(organism, 3, GrowStrategy.NO_PROTEINS));
        if (_proteinsToCheck.Count == 0) return actions;
        actions.AddRange(GetShortestPathsToProteins(organism, 3, GrowStrategy.UNHARVESTED));
        if (_proteinsToCheck.Count == 0) return actions;

        actions.AddRange(GetShortestPathsToProteins(organism, 4, GrowStrategy.NO_PROTEINS));
        if (_proteinsToCheck.Count == 0) return actions;
        actions.AddRange(GetShortestPathsToProteins(organism, 4, GrowStrategy.UNHARVESTED));
        if (_proteinsToCheck.Count == 0) return actions;

        actions.AddRange(GetShortestPathsToProteins(organism, 5, GrowStrategy.NO_PROTEINS));
        if (_proteinsToCheck.Count == 0) return actions;
        actions.AddRange(GetShortestPathsToProteins(organism, 5, GrowStrategy.UNHARVESTED));
        if (_proteinsToCheck.Count == 0) return actions;

        return actions;   
    }

    private IEnumerable<Action> GetShortestPathsToProteins(Organism organism, int maxDistance, GrowStrategy growStrategy)
    {
        List<Action> actions = new List<Action>();

        List<int> proteinsToRemove = new List<int>();
 
        for (int i = 0; i < _proteinsToCheck.Count; i++)
        {
            Protein protein = _proteinsToCheck[i];
            foreach (Organ organ in organism.Organs)
            {
                //Console.Error.WriteLine($"Checking protein {protein.Position} to organ {organ.Position}");
                int manhattanDistance = MapChecker.CalculateManhattanDistance(organ.Position, protein.Position);
                
                if (manhattanDistance > maxDistance)
                {
                    continue;
                }

                List<Point> path = _aStar.GetShortestPath(organ.Position, protein.Position, maxDistance, growStrategy, false);
                
               // Console.Error.WriteLine($"Path from {organ.Position} to {protein.Position} is {path.Count} long");
                if (path.Count > 0)
                {
                    //actions.Add(new Tuple<int, ProteinType, List<Point>>(organ.Id, protein.Type, path));

                    Action? action = CreateAction(organism.RootId, organ.Id, protein.Type, path);

                    if (action != null)
                    {
                        actions.Add(action);
                    }
                   
                    if (!proteinsToRemove.Contains(i) && maxDistance != 1)
                    {
                        proteinsToRemove.Add(i);
                    }
                }
            }
        }

        for (int i = proteinsToRemove.Count - 1; i >= 0; i--)
        {
            _proteinsToCheck.RemoveAt(proteinsToRemove[i]);
        }

        return actions;
    }

    // TODO: Where does it decide on using a tentacle??
    private Action? CreateAction(int organismId, int organId, ProteinType proteinType, List<Point> path)
    {
        Action? action = new Action();

        action.ActionType = ActionType.GROW;
        action.TargetPosition = path[0];
        action.OrganismId = organismId;
        action.OrganId = organId;
        
        action.GoalProteinType = proteinType;
        action.GoalPosition = path[path.Count - 1];

        action.Source = ActionSource.CHECK_FOR_HARVESTS;

        // TODO: Add longer consume actions (We might need to consume something if we 
        //       Have no stock or harvests for C or alculator.CanProduceOrgan(OrganType.H
        if (path.Count == 1)
        {
            action.TurnsToGoal = 1;
            action.GoalType = GoalType.CONSUME;

            action.OrganType = GetOrgan(path[0]);
          
            if (action.OrganType != OrganType.BASIC)
            {
                action.OrganDirection = _directionCalculator.CalculateClosestOpponentDirection(path[0]);
            }
        }
        else if (path.Count == 2)
        {
            if (!CostCalculator.CanProduceOrgan(OrganType.HARVESTER, _game.PlayerProteinStock))
            {
                return null;
            }
            
            action.TurnsToGoal = 1;
            action.GoalType = GoalType.HARVEST;

            action.OrganType = OrganType.HARVESTER;

            action.OrganDirection = _directionCalculator.GetDirection(path[0], path[1]);
        }
        else
        {
            if (!CostCalculator.CanProduceOrgan(OrganType.HARVESTER, _game.PlayerProteinStock))
            {
                return null;
            }

            action.TurnsToGoal = path.Count - 1;
            action.GoalType = GoalType.HARVEST;

            action.OrganType = GetOrgan(path[0]);

            if (action.OrganType != OrganType.BASIC)
            {
                action.OrganDirection = _directionCalculator.CalculateClosestOpponentDirection(path[0]);
            }
        }

        return action;
    }

    private OrganType GetOrgan(Point point)
    {
        bool hasProtein = _game.hasAnyProtein[point.X, point.Y];
        if (CostCalculator.CanProduceOrgan(OrganType.BASIC, _game.PlayerProteinStock))
        {
            return OrganType.BASIC;
        }
        else if (CostCalculator.CanProduceOrgan(OrganType.SPORER, _game.PlayerProteinStock))
        {
            return OrganType.SPORER;
        }
        else if (CostCalculator.CanProduceOrgan(OrganType.HARVESTER, _game.PlayerProteinStock))
        {
            return OrganType.HARVESTER;
        }
        else if (CostCalculator.CanProduceOrgan(OrganType.TENTACLE, _game.PlayerProteinStock))
        {
            return OrganType.TENTACLE;
        }

        return OrganType.BASIC;
    }
}


internal enum ActionType
{
    GROW,
    SPORE,
    WAIT
}

internal sealed class AStar
{
    private int _diagnosticCount = 0;

    private readonly Game _game;

    private List<Node> _nodes = new List<Node>();

    internal AStar(Game game)
    {
        _game = game;
    }

    internal List<Point> GetShortestPath(Point startPoint, Point targetPoint, int maxDistance)
    {
        return GetShortestPath(startPoint, targetPoint, maxDistance, GrowStrategy.NO_PROTEINS, false);
    }

    internal List<Point> GetShortestPath(Point startPoint, Point targetPoint, int maxDistance, GrowStrategy growStrategy, bool walkOnOpponentTentaclePath)
    {
        _diagnosticCount = 0;
        _nodes = new List<Node>();

        Node currentNode = new Node(startPoint);

        _nodes.Add(currentNode);

        bool targetFound = false;

        int timeToSearch = 0;
        while (!targetFound)
        {
            if (_nodes.Count(n => n.Closed == false) == 0)
            {
                return new List<Point>();
            }

            Point[] pointsToCheck =
            [
                new Point(currentNode.Position.X, currentNode.Position.Y + 1),
                new Point(currentNode.Position.X + 1, currentNode.Position.Y),
                new Point(currentNode.Position.X, currentNode.Position.Y - 1),
                new Point(currentNode.Position.X - 1, currentNode.Position.Y),
            ];

            foreach (Point pointToCheck in pointsToCheck)
            {
                _diagnosticCount++;
                Node? existingNode = _nodes.SingleOrDefault(n => n.Position == pointToCheck);
 
                if (existingNode == null)
                {
                    if (pointToCheck == startPoint || pointToCheck == targetPoint || MapChecker.CanGrowOn(pointToCheck, _game, growStrategy, walkOnOpponentTentaclePath))
                    {                        
                        Node node = new Node(pointToCheck);

                        node.Parent = currentNode.Position;

                        node.G = currentNode.G + 1;

                        if (node.G > maxDistance)
                            continue;

                        node.H = MapChecker.CalculateManhattanDistance(pointToCheck, targetPoint);
                        node.F = node.G + node.H;

                        _nodes.Add(node);
                    }
                }
                else
                {
                    if (!existingNode.Closed)
                    {
                        int g = currentNode.G + 1;

                        if (g < existingNode.G)
                        {
                            existingNode.G = g;

                            if (existingNode.G > maxDistance)
                                continue;

                            existingNode.F = existingNode.G + existingNode.H;

                            existingNode.Parent = currentNode.Position;
                        }
                    }
                }
            }

            currentNode.Closed = true;

            if (currentNode.Position == targetPoint)
            {
                targetFound = true;
            }
            else
            {
                _nodes = _nodes.OrderBy(n => n.Closed == true).ThenBy(n => n.F).ToList();

                currentNode = _nodes.First();
            }

            timeToSearch++;

            if (timeToSearch > 1000)
            {
                Console.Error.WriteLine("Warning: Time to search hit 1000");
            }
        }

        int numberOfSteps = currentNode.G;

        List<Point> shortestPath = [currentNode.Position];

        bool atStart = false;

        while (!atStart)
        {
            currentNode = _nodes.Single(n => n.Position == currentNode.Parent);

            if (currentNode.Position == startPoint)
            {
                atStart = true;
            }
            else
            {
                shortestPath.Insert(0, currentNode.Position);
            }
        }

        return shortestPath;
    }

    internal int GetDiagnosticCount()
    {
        return _diagnosticCount;
    }
}


internal static class CostCalculator
{
    internal static bool CanProduceOrgan(OrganType organ, ProteinStock proteinStock)
    {
        return CanProduceOrgan(organ, proteinStock, 1);
    }

    internal static bool CanProduceOrgan(OrganType organ, ProteinStock proteinStock, int amount)
    {
        switch (organ)
        {
            case OrganType.BASIC:
                if (proteinStock.A >= (1 * amount))
                {
                    return true;
                }
                return false;
            case OrganType.HARVESTER:
                if (proteinStock.C >= (1 * amount) &&
                    proteinStock.D >= (1 * amount))
                {
                    return true;
                }
                return false;
            case OrganType.ROOT:
                if (proteinStock.A >= (1 * amount) &&
                    proteinStock.B >= (1 * amount) &&
                    proteinStock.C >= (1 * amount) &&
                    proteinStock.D >= (1 * amount))
                {
                    return true;
                }
                return false;
            case OrganType.SPORER:
                if (proteinStock.B >= (1 * amount) &&
                    proteinStock.D >= (1 * amount))
                {
                    return true;
                }
                return false;
            case OrganType.TENTACLE:
                if (proteinStock.B >= (1 * amount) &&
                    proteinStock.C >= (1 * amount))
                {
                    return true;
                }
                return false;
        }

        return false;
    }

    internal static bool CanProduceOrgans(List<OrganType> organs, ProteinStock proteinStock)
    {
        int aNeeded = 0;
        int bNeeded = 0;
        int cNeeded = 0;
        int dNeeded = 0;

        foreach (OrganType organType in organs)
        {
            switch (organType)
            {
                case OrganType.BASIC:
                    aNeeded++;
                    break;
                case OrganType.HARVESTER:
                    cNeeded++;
                    dNeeded++;
                    break;
                case OrganType.ROOT:
                    aNeeded++;
                    bNeeded++;
                    cNeeded++;
                    dNeeded++;
                    break;
                case OrganType.SPORER:
                    bNeeded++;
                    dNeeded++;
                    break;
                case OrganType.TENTACLE:
                    bNeeded++;
                    cNeeded++;
                    break;
            }
        }

        if (proteinStock.A < aNeeded)
        {
            return false;
        }

        if (proteinStock.B < bNeeded)
        {
            return false;
        }

        if (proteinStock.C < cNeeded)
        {
            return false;
        }

        if (proteinStock.D < dNeeded)
        {
            return false;
        }

        return true;
    }
}


internal class DirectionCalculator
{
    private readonly Game _game;

    private readonly List<Point> _directions = new List<Point>
    {
        new Point(0, 1),
        new Point(0, -1),
        new Point(1, 0),
        new Point(-1, 0)
    };

    public DirectionCalculator(Game game)
    {
        _game = game;
    }


    internal OrganDirection? CalculateClosestOpponentDirection(Point startPoint)
    {
        Point endPoint = GetClosestRoot(startPoint);

        return CalculateClosestOpponentDirection(startPoint, endPoint);
    }
    internal OrganDirection? CalculateClosestOpponentDirection(Point startPoint, Point endPoint)
    {
        if (Math.Abs(endPoint.X - startPoint.X) >= Math.Abs(endPoint.Y - startPoint.Y))
        {
            // It's either east or west
            if (endPoint.X > startPoint.X)
            {
                if (startPoint.X + 1 < _game.Width && !_game.Walls[startPoint.X + 1, startPoint.Y])
                {
                    return OrganDirection.E;
                }
            }
            else
            {
                if (startPoint.X - 1 >= 0 && !_game.Walls[startPoint.X - 1, startPoint.Y])
                {
                    return OrganDirection.W;
                }
            }
        }
        else
        {
            // It's either north or south
            if (endPoint.Y > startPoint.Y)
            {
                if (startPoint.Y + 1 < _game.Height && !_game.Walls[startPoint.X, startPoint.Y + 1])
                {
                    return OrganDirection.S;
                }
            }
            else
            {
                if (startPoint.Y - 1 >= 0 && !_game.Walls[startPoint.X, startPoint.Y - 1])
                {
                    return OrganDirection.N;
                }
            }
        }

        // If we've gotten this far it means that pointing towards the 
        // opponents main root would point towards a wall. We don't want that. 
        // Grow towards an open space
        foreach (Point direction in _directions)
        {
            Point directionPoint = new Point(startPoint.X + direction.X, startPoint.Y + direction.Y);



            if (MapChecker.CanGrowOn(
                directionPoint,
                _game,
                GrowStrategy.ALL_PROTEINS,
                false))
            {
                return GetDirection(startPoint, directionPoint);
            }
        }

        // if we got this far it really doesn't matter 
        return OrganDirection.E;
    }

    internal OrganDirection? GetDirection(Point from, Point to)
    {
        OrganDirection dir = OrganDirection.N;

        if (from.X < to.X)
        {
            dir = OrganDirection.E;
        }
        else if (from.X > to.X)
        {
            dir = OrganDirection.W;
        }
        else if (from.Y < to.Y)
        {
            dir = OrganDirection.S;
        }

        return dir;
    }

    internal Point GetDelta(OrganDirection organDirection)
    {
        switch (organDirection)
        {
            case OrganDirection.N:
                return new Point(0, -1);
            case OrganDirection.E:
                return new Point(1, 0);
            case OrganDirection.S:
                return new Point(0, 1);
            case OrganDirection.W:
                return new Point(-1, 0);
            default:
                return new Point(0, 0);
        }
    }

    private Point GetClosestRoot(Point startPoint)
    {
        int closestDistance = int.MaxValue;
        Point closestPoint = new Point(-1, -1);

        foreach (Organism opponentOrganism in _game.OpponentOrganisms)
        {
            Organ root = opponentOrganism.Organs.Single(o => o.Type == OrganType.ROOT);

            int distance = MapChecker.CalculateManhattanDistance(root.Position, startPoint);

            if (distance < closestDistance)
            {
                closestDistance = distance;
                closestPoint = root.Position;
            }
        }

        return closestPoint;
    }
}


internal static class Display
{
    internal static void ProteinStock(ProteinStock proteinStock)
    {
        Console.Error.WriteLine($"A: {proteinStock.A}");
        Console.Error.WriteLine($"B: {proteinStock.B}");
        Console.Error.WriteLine($"C: {proteinStock.C}");
        Console.Error.WriteLine($"D: {proteinStock.D}");
    }

    internal static void Proteins(List<Protein> proteins)
    {
        Console.Error.WriteLine($"Proteins");

        proteins.ForEach(p =>
            Console.Error.WriteLine($"Type:{p.Type} - Position:({p.Position.X},{p.Position.Y}) - BeingHarvested:{p.IsHarvested}"));
    }

    internal static void Organisms(List<Organism> organisms)
    {
        foreach (Organism organism in organisms)
        {
            Organism(organism);
            Console.Error.WriteLine("-----------------------------------");
        }
    }

    internal static void Organism(Organism organism)
    {
        foreach (Organ organ in organism.Organs)
        {
            switch (organ.Type)
            {
                case OrganType.BASIC:
                case OrganType.ROOT:
                    Console.Error.WriteLine($" ID:{organ.Id} - Type:{organ.Type.ToString()} - Position:({organ.Position.X},{organ.Position.Y})");
                    break;

                case OrganType.HARVESTER:
                case OrganType.SPORER:
                case OrganType.TENTACLE:
                    Console.Error.WriteLine($" ID:{organ.Id} - Type:{organ.Type.ToString()} - Position:({organ.Position.X},{organ.Position.Y}) - Direction:{organ.Direction.ToString()}");
                    break;
            }
        }
    }

    internal static void Nodes(List<Node> nodes)
    {
        nodes.ForEach(n =>
            Console.Error.WriteLine($"Position:({n.Position.X},{n.Position.Y}) - Closed:{n.Closed}"));
    }

    internal static void Map(Game game)
    {
        string[,] map = new string[game.Width, game.Height];

        for (int y = 0; y < game.Height; y++)
        {
            for (int x = 0; x < game.Width; x++)
            {
                map[x, y] = " ";
            }
        }

        for (int y = 0; y < game.Height; y++)
        {
            for (int x = 0; x < game.Width; x++)
            {
                if (game.Walls[x, y])
                {
                    map[x, y] = "X";
                }
            }
        }

        foreach (Protein protein in game.Proteins)
        {
            map[protein.Position.X, protein.Position.Y] = protein.Type.ToString();
        }

        foreach (Organism organism in game.PlayerOrganisms)
        {
            foreach (Organ organ in organism.Organs)
            {
                map[organ.Position.X, organ.Position.Y] = "O";
            }
        }

        foreach (Organism organism in game.OpponentOrganisms)
        {
            foreach (Organ organ in organism.Organs)
            {
                map[organ.Position.X, organ.Position.Y] = "o";
            }
        }

        Console.Error.WriteLine("----------");
        for (int y = 0; y < game.Height; y++)
        {
            string row = "|";

            for (int x = 0; x < game.Width; x++)
            {
                row += map[x, y];
            }

            row += "|";

            Console.Error.WriteLine(row);
        }
        Console.Error.WriteLine("----------");
    }

    internal static void TimeStamp(long totalTime, long segmentTime, string task)
    {
        TimeSpan total = TimeSpan.FromTicks(totalTime);
        TimeSpan segment = TimeSpan.FromTicks(segmentTime);
        Console.Error.WriteLine($"{total.Milliseconds}ms-{segment.Milliseconds}ms-{task}");
    }

    internal static void Actions(List<Action> actions)
    {
        foreach (Action action in actions)
        {
            // Console.Error.WriteLine($"Goal type:{action.GoalType}, Protein type:{action.GoalProteinType}, Turns:{action.TurnsToGoal}, score:{action.Score}");
            Console.Error.WriteLine(action.ToString() + $" - score:{ action.Score} - from {action.Source}");
        }
    }

    internal static void ActionsDictionary(Dictionary<int, List<Action>> actionsDictionarly)
    {
        foreach (KeyValuePair<int, List<Action>> actions in actionsDictionarly)
        {
            Console.Error.WriteLine("-----------------------------------");
            Console.Error.WriteLine($"OrganismId:{actions.Key}");
            Actions(actions.Value);
        }
    }

    internal static void ActionSources(Dictionary<ActionSource, int> trackedActions)
    {
        Console.Error.WriteLine("Tracked actions count");
        foreach (KeyValuePair<ActionSource, int> trackedAction in trackedActions)
        {
            Console.Error.WriteLine($"{trackedAction.Key} - {trackedAction.Value}");
        }
    }
}


internal sealed class Game
{
    internal int Width { get; private set; }
    internal int Height { get; private set; }

    internal List<Organism> PlayerOrganisms { get; private set; }
    internal List<Organism> OpponentOrganisms { get; private set; }

    internal ProteinStock PlayerProteinStock { get; private set; }
    internal ProteinStock OpponentProteinStock { get; private set; }
    
    public bool[,] Walls { get; private set; }
    public List<Protein> Proteins { get; private set; }

    private ActionFinder _pathFinder;
    private DirectionCalculator _directionCalculator;

    private bool[,] _sporerPoints;

    internal bool[,] isBlocked;
    internal bool[,] hasAnyProtein;
    internal ProteinType[,] proteinTypes;
    internal bool[,] hasHarvestedProtein;
    internal bool[,] opponentOrgans;
    internal bool[,] opponentOrganEdges;
    internal int[,] opponentOrganChildren;

    internal bool[,] opponentTentaclePath;

    private Stopwatch _timer;
    private long _totalTime;

    private List<int> _createdSporer = new List<int>();

    private Dictionary<ActionSource, int> _trackedActions = new Dictionary<ActionSource, int>();

    private readonly List<Point> _directions = new List<Point>
    {
        new Point(0, 1),
        new Point(0, -1),
        new Point(1, 0),
        new Point(-1, 0)
    };

    private int _harvestedAProteins;
    private int _harvestedBProteins;
    private int _harvestedCProteins;
    private int _harvestedDProteins;

    private int _waitCount = 0;

    internal Game(int width, int height)
    {
        Width = width;
        Height = height;

        PlayerOrganisms = new List<Organism>();
        OpponentOrganisms = new List<Organism>();

        Walls = new bool[Width, Height];
        Proteins = new List<Protein>();
    }

    internal void SetPlayerProteinStock(ProteinStock playerProteins) => PlayerProteinStock = playerProteins;

    internal void SetOpponentProteinStock(ProteinStock opponentProteins) => OpponentProteinStock = opponentProteins;

    internal void SetPlayerOrganisms(List<Organism> playerOrganisms) => PlayerOrganisms = playerOrganisms;

    internal void SetOpponentOrganisms(List<Organism> opponentOrganisms) => OpponentOrganisms = opponentOrganisms;

    internal void SetWalls(bool[,] walls) => Walls = walls;

    internal void SetProteins(List<Protein> proteins) => Proteins = proteins;

    internal List<Action> GetActions()
    {
        _directionCalculator = new DirectionCalculator(this);
        _pathFinder = new ActionFinder(this, _directionCalculator);

        _totalTime = 0;
        _timer = new Stopwatch();
        _timer.Start();

        _sporerPoints = new bool[Width, Height];

        CheckForHarvestedProtein();
        DisplayTime("Updated check for harvested protein");

        UpdateMaps();
        DisplayTime("Updated maps");

        Dictionary<int, List<Action>> allPossibleActions = new Dictionary<int, List<Action>>();

        int maxProteinDistance = 5;
        int minRootSporerDistance = 4;
        int extraPriorityScore = 0;

        if (PlayerOrganisms.Count < 2)
        {
            maxProteinDistance = 1;
            minRootSporerDistance = 3;
            extraPriorityScore = 50;
        }
        else if (PlayerOrganisms.Count < 3)
        {
            maxProteinDistance = 2;
            extraPriorityScore = 50;
        }

        foreach (Organism organism in PlayerOrganisms)
        {   
            List<Action> possibleActions = new List<Action>();

            Console.Error.WriteLine("-------------------------------------");
            Console.Error.WriteLine($"Checking organism: {organism.RootId}");

            List<Action> tentacleActions = CheckForTentacleAction(organism);

            possibleActions.AddRange(tentacleActions);
            
            DisplayTime($"Checked for tentacle action. {possibleActions.Count} possible actions");
            
            if (possibleActions.Count == 0 && !_createdSporer.Contains(organism.RootId))
            {
                List<Action> actions = GetHarvestAndConsumeActions(organism, maxProteinDistance);
                DisplayTime($"Checked for harvest action. {actions.Count} possible actions");
                
                if (actions.Count > 0)
                {
                    possibleActions.AddRange(actions);
                }
            }

            UpdateSporerSpawnPoints();
            if(_createdSporer.Contains(organism.RootId))
            {
                extraPriorityScore = 0;
            }

            if (_createdSporer.Contains(organism.RootId) && (HasHarvestedAllProteins() || PlayerOrganisms.Count < 3))
            {
                DisplayTime("Updated sporer spawn points");
                (Action? sporeAction, int fireDistance) = CheckForSporeRootAction(organism, minRootSporerDistance);

                if (sporeAction is null)
                {
                    DisplayTime("Checked for spore root action. No possible actions");
                }
                else 
                { 
                    DisplayTime($"Checked for spore root action. 1 possible action");
                }

                if (sporeAction is not null)
                {
                    possibleActions.Add(sporeAction);
                    if (fireDistance < 10)
                    {
                        _createdSporer.Remove(organism.RootId);
                    }
                }
            }

            if (possibleActions.Count == 0 && _createdSporer.Contains(organism.RootId))
            {
                List<Action> actions = GetHarvestAndConsumeActions(organism, maxProteinDistance);
                DisplayTime($"Checked for harvest action (later than usual). {actions.Count} possible actions");

                if (actions.Count > 0)
                {
                    possibleActions.AddRange(actions);
                }

                // We hit this if we couldn't get a spore root action, even though 
                // we prioritised it. There's no point trying again.
                if (possibleActions.Count == 0)
                {
                    _createdSporer.Remove(organism.RootId);
                }
            }

            // Don't create a sporer if we already did
            if (!_createdSporer.Contains(organism.RootId) && (HasHarvestedAllProteins() || PlayerOrganisms.Count < 3))
            { 
                Action? sporerAction = CheckForSporerAction(organism, minRootSporerDistance, extraPriorityScore);
                if (sporerAction is null)
                {
                    DisplayTime("Checked for sporer action. No possible action");
                }
                else
                {
                    DisplayTime("Checked for sporer action. 1 possible action");
                }

                if (sporerAction is not null)
                {
                    possibleActions.Add(sporerAction);
                }
            }

            if (possibleActions.Count == 0)
            { 
                // Note: This is a horrible hack until i get scoring sorted. All of this has already been done above!
                List<Action> actions = GetHarvestAndConsumeActions(organism, 1000000);
               
                if (actions.Count > 0)
                {
                    possibleActions.AddRange(actions);
                }

                Console.Error.WriteLine($"Checked for Action that was rejected by CheckForHarvestOrConsumeAction. {actions.Count} possible actions");
            }

            List<Action> desperateActions = GetDesperateDestructiveMove(organism, GrowStrategy.UNHARVESTED, 4, ActionSource.DESPERATE_DESTRUCTIVE_MOVE);
            DisplayTime($"Checked for desperate actions. {desperateActions.Count} possible actions");
            possibleActions.AddRange(desperateActions);
            
            List<Action> veryDesperateActions = GetDesperateDestructiveMove(organism, GrowStrategy.ALL_PROTEINS,3, ActionSource.VERY_DESPERATE_DESTRUCTIVE_MOVE);
            DisplayTime($"Checked for very desperate actions. {veryDesperateActions.Count} possible actions");
            possibleActions.AddRange(veryDesperateActions);

            var getFloodFillScores = possibleActions.Count == 0;
            
            List<Action> randomActions = GetRandomGrowActions(organism, getFloodFillScores);
            DisplayTime($"Checked for random move action. {randomActions.Count} possible actions");
            randomActions = randomActions.OrderByDescending(a => a.Score).ToList();
            Display.Actions(randomActions);

            possibleActions.AddRange(randomActions);
            
            if (possibleActions.Count == 0)
            {
                // If we've done only WAIT moves for more than 3 moves assume that 
                // We're done and start destroying proteins
                if (_waitCount > 3)
                {
                   List<Action> endGameDestroyMoves = GetEndGameDestroyMoves(organism);
                    possibleActions.AddRange(endGameDestroyMoves);
                    DisplayTime($"Checked for end game destroy moves. {endGameDestroyMoves.Count} possible actions");
                }

                Action? waitAction = new Action()
                {
                    OrganismId = organism.RootId,
                    GoalType = GoalType.WAIT,
                    ActionType = ActionType.WAIT,

                    Source = ActionSource.FINAL_WAIT,
                    Score = -1
                };
                possibleActions.Add(waitAction);
                
            }

            possibleActions = possibleActions.OrderByDescending(p => p.Score).ToList();

            //Display.Actions(possibleActions);
            //Console.Error.WriteLine($"Possible actions: {possibleActions.Count}");

            allPossibleActions.Add(organism.RootId, possibleActions);
        }

        DisplayTime("Done scoring");

        List<Action> chosenActions = PickBestActions(allPossibleActions);

        bool allWait = true;

        foreach (Action action in chosenActions)
        {
            if (action.OrganType == OrganType.SPORER)
            {
                _createdSporer.Add(action.OrganismId);
            }

            if (action.ActionType != ActionType.WAIT)
            {
                allWait = false;
            }


            _trackedActions.TryGetValue(action.Source, out int count);
            _trackedActions[action.Source] = count + 1;
        }

        if (allWait)
        {
            _waitCount++; 
        }
        else
        {
            if (_waitCount <= 3)
                _waitCount = 0;
        }

        DisplayTime("Done picking best actions");

        // Display.ActionSources(_trackedActions);

        _timer.Stop();

        return chosenActions;
    }

    private bool HasHarvestedAllProteins()
    {
        if (_harvestedAProteins > 0 && 
            _harvestedBProteins > 0 && 
            _harvestedCProteins > 0 && 
            _harvestedDProteins > 0)
        {
            return true;
        }

        return false;
    }

    private List<Action> GetEndGameDestroyMoves(Organism organism)
    {
        foreach (Protein protein in Proteins)
        {
            foreach (Point direction in _directions)
            {
                Point checkPoint = new Point(protein.Position.X + direction.X,
                                             protein.Position.Y + direction.Y);

                if (CheckBounds(checkPoint))
                {
                    // if organ is on the check point create an action
                    if (organism.Organs.Any(organ => organ.Position == checkPoint))
                    {
                        Organ organ = organism.Organs.Single(organ => organ.Position == checkPoint);

                        Console.Error.WriteLine($"Found organ to destroy: {organ.Position.X},{organ.Position.Y}");
                        // Create 4 grow type actions for tis check point 
                        return CreateGrowActions(organism.RootId, organ.Id, protein.Position, 0, ActionSource.END_GAME_DESTROY).ToList();
                    }
                }
            }
        }

        return new List<Action>();
    }

    private bool CheckBounds(Point checkPoint)
    {
        if (checkPoint.X < 0 || checkPoint.X >= Width || checkPoint.Y < 0 || checkPoint.Y >= Height)
        {
            return false;
        }

        return true;
    }

    // Check to see if any protein is being harvested and mark it as such
    private void CheckForHarvestedProtein()
    {
        _harvestedAProteins = 0;
        _harvestedBProteins = 0;
        _harvestedCProteins = 0;
        _harvestedDProteins = 0;

        foreach (Organism organism in PlayerOrganisms)
        {
            foreach (Organ organ in organism.Organs)
            {
                if (organ.Type == OrganType.HARVESTER)
                {
                    Point harvestedPosition = GetHarvestedPosition(organ);

                    if (Proteins.Any(p => p.Position == harvestedPosition))
                    {
                        Protein havestedProtein = Proteins.Single(p => p.Position == harvestedPosition);

                        havestedProtein.IsHarvested = true;

                        if (havestedProtein.Type == ProteinType.A)
                        {
                            _harvestedAProteins++;
                        }
                        else if (havestedProtein.Type == ProteinType.B)
                        {
                            _harvestedBProteins++;
                        }
                        else if (havestedProtein.Type == ProteinType.C)
                        {
                            _harvestedCProteins++;
                        }
                        else if (havestedProtein.Type == ProteinType.D)
                        {
                            _harvestedDProteins++;
                        }
                    }
                }
            }
        }

        // We don't care about enemy harvested proteins because
        // we're still happy to consume them.
    }

    private static Point GetHarvestedPosition(Organ organ)
    {
        switch (organ.Direction)
        {
            case OrganDirection.N:
                return new Point(organ.Position.X, organ.Position.Y - 1);
            case OrganDirection.E:
                return new Point(organ.Position.X + 1, organ.Position.Y);
            case OrganDirection.S:
                return new Point(organ.Position.X, organ.Position.Y + 1);
            case OrganDirection.W:
                return new Point(organ.Position.X - 1, organ.Position.Y);
        }

        return new Point(-1, -1);
    }

    internal void UpdateMaps()
    {
        // Reset them all at the start because some of the calculation 
        // will make changes to the others.
        isBlocked = new bool[Width, Height];

        hasHarvestedProtein = new bool[Width, Height];
        hasAnyProtein = new bool[Width, Height];
        proteinTypes = new ProteinType[Width, Height];

        opponentOrgans = new bool[Width, Height];
        opponentOrganEdges = new bool[Width, Height];
        opponentTentaclePath = new bool[Width, Height];
        opponentOrganChildren = new int[Width, Height];

        UpdateIsBlocked();
        UpdateHasProteins();
        UpdateOpponentOrgans();
    }

    private void UpdateIsBlocked()
    {
        // Not walkable if player organ on that spot
        foreach (Organism organism in PlayerOrganisms)
        {
            foreach (Organ organ in organism.Organs)
            {
                isBlocked[organ.Position.X, organ.Position.Y] = true;
            }
        }

        // Not walkable if opponent organ on that spot
        foreach (Organism organism in OpponentOrganisms)
        {
            foreach (Organ organ in organism.Organs)
            {
                isBlocked[organ.Position.X, organ.Position.Y] = true;
            }
        }

        // Not walkable if wall on that spot
        for (int x = 0; x < Width; x++)
        {
            for (int y = 0; y < Height; y++)
            {
                if (Walls[x, y])
                {
                    isBlocked[x, y] = true;
                }
            }
        }
    }

    private void UpdateHasProteins()
    {
        foreach (Protein protein in Proteins)
        {
            hasAnyProtein[protein.Position.X, protein.Position.Y] = true;

            proteinTypes[protein.Position.X, protein.Position.Y] = protein.Type;

            if (protein.IsHarvested)
            {
                hasHarvestedProtein[protein.Position.X, protein.Position.Y] = true;
            }
        }
    }

    private void UpdateOpponentOrgans()
    {
        foreach (Organism organism in OpponentOrganisms)
        {
            foreach (Organ organ in organism.Organs)
            {
                opponentOrgans[organ.Position.X, organ.Position.Y] = true;

                int childCount = GetChildCount(organism.RootId, organ);
                opponentOrganChildren[organ.Position.X, organ.Position.Y] = childCount;

                // We can't walk on an outward facing tentacle
                // So add these to the isBlocked list and not to the valid edges

                // North
                if (organ.Position.Y - 1 >= 0)
                {
                    opponentOrganEdges[organ.Position.X, organ.Position.Y - 1] = true;

                    if (organ.Type == OrganType.TENTACLE && organ.Direction == OrganDirection.N)
                    {
                        opponentTentaclePath[organ.Position.X, organ.Position.Y - 1] = true;
                    }
                }

                // East
                if (organ.Position.X + 1 < Width)
                {
                    opponentOrganEdges[organ.Position.X + 1, organ.Position.Y] = true;

                    if (organ.Type == OrganType.TENTACLE && organ.Direction == OrganDirection.E)
                    {
                        opponentTentaclePath[organ.Position.X + 1, organ.Position.Y] = true;
                    }
                }

                // South
                if (organ.Position.Y + 1 < Height)
                {
                    opponentOrganEdges[organ.Position.X, organ.Position.Y + 1] = true;

                    if (organ.Type == OrganType.TENTACLE && organ.Direction == OrganDirection.S)
                    {
                        opponentTentaclePath[organ.Position.X, organ.Position.Y + 1] = true;
                    }
                }

                // WEST
                if (organ.Position.X - 1 >= 0)
                {
                    opponentOrganEdges[organ.Position.X - 1, organ.Position.Y] = true;

                    if (organ.Type == OrganType.TENTACLE && organ.Direction == OrganDirection.W)
                    { 
                        opponentTentaclePath[organ.Position.X - 1, organ.Position.Y] = true;
                    }
                }
            }   
        }
    }

    private int GetChildCount(int organismId, Organ organ)
    {
        int count = 0;
        if (OpponentOrganisms.First(o => o.RootId == organismId).Organs.Any(o => o.ParentId == organ.Id))
        {
            List<Organ> children = OpponentOrganisms.First(o => o.RootId == organismId).Organs.Where(o => o.ParentId == organ.Id).ToList();

            count += children.Count;

            foreach (Organ child in children)
            {
                count += GetChildCount(organismId, child);
            }
        }

        return count;
    }

    private void DisplayTime(string message)
    {
        long segmentTime = _timer.ElapsedTicks;
        _totalTime += segmentTime;
        Display.TimeStamp(_totalTime, segmentTime, message);
        _timer.Restart();
    }

    private (int, List<Point>) GetShortestPathToProtein(Organism organism, List<Protein> proteins, int minDistance, int maxDistance, GrowStrategy growStrategy)
    {
        string action = string.Empty;

        int shortest = int.MaxValue;
        int closestId = -1;
        List<Point> shortestPath = new List<Point>();

        AStar aStar = new AStar(this);

        // Get the closest protein to Organs
        foreach (Protein protein in proteins)
        {
            if (protein.IsHarvested || isBlocked[protein.Position.X, protein.Position.Y] || opponentTentaclePath[protein.Position.X, protein.Position.Y])
            {
                continue;
            }

            foreach (var organ in organism.Organs)
            {
                int manhattanDistance = MapChecker.CalculateManhattanDistance(organ.Position, protein.Position);

                if (manhattanDistance > maxDistance)
                {
                    continue;
                }

                List<Point> path = aStar.GetShortestPath(organ.Position, protein.Position, maxDistance, growStrategy, false);

                if (path.Count < shortest && path.Count >= minDistance && path.Count != 0)
                {
                    shortest = path.Count;
                    shortestPath = new List<Point>(path);

                    closestId = organ.Id;

                    if (shortest < maxDistance)
                    {
                        maxDistance = shortest;
                    }
                }
            }
        }

        return (closestId, shortestPath);
    }

    private List<Action> CheckForTentacleAction(Organism organism)
    {
        Console.Error.WriteLine("Checking for tentacle action");
        List<Action> tentacleActions = new List<Action>();

        if (CostCalculator.CanProduceOrgan(OrganType.TENTACLE, PlayerProteinStock))
        {
            List<Action> twoMoveActions = GetShortestPathToOpponent(organism, 2, 2, GrowStrategy.ALL_PROTEINS, false, "Two ply search");
            tentacleActions.AddRange(twoMoveActions);

            // If we didn't find a path check we're just not seeing it because it's too close
            // Note these ones are always 2 long
            foreach (Organ organ in organism.Organs)
            {
                foreach (Point dir in _directions)
                {
                    Point checkPoint = new Point(organ.Position.X + dir.X, organ.Position.Y + dir.Y);

                    if (CheckBounds(checkPoint) && MapChecker.CanGrowOn(checkPoint, this, GrowStrategy.ALL_PROTEINS, false))
                    {
                        List<Action> tooShortActions = GetShortestPathToOpponent(checkPoint, 2, 2, GrowStrategy.ALL_PROTEINS, organism.RootId, organ.Id, "Next door search");

                        tentacleActions.AddRange(tooShortActions);
                    }
                }
            }

            if (tentacleActions.Count == 0)
            {
                List<Action> threeMoveActions = GetShortestPathToOpponent(organism, 3, 3, GrowStrategy.ALL_PROTEINS, true, "Three ply search");
                tentacleActions.AddRange(threeMoveActions);
            }

            if (tentacleActions.Count == 0)
            {
                List<Action> fourMoveActions = GetShortestPathToOpponent(organism, 4, 4, GrowStrategy.ALL_PROTEINS, true, "Four ply search");
                tentacleActions.AddRange(fourMoveActions);
            }
        }

        return tentacleActions;
    }

    private List<Action> GetShortestPathToOpponent(Organism organism, 
                                                    int minDistance, 
                                                    int maxDistance, 
                                                    GrowStrategy growStrategy, 
                                                    bool canWalkOnOpponentTentaclePaths,
                                                    string source)
    {
        List<Action> actions = new List<Action>();

        AStar aStar = new AStar(this);

        foreach (var organ in organism.Organs)
        {
            foreach (Organism opponentOrganism in OpponentOrganisms)
            {
                foreach (Organ opponentOrgan in opponentOrganism.Organs)
                {
                    int manhattanDistance = MapChecker.CalculateManhattanDistance(organ.Position, opponentOrgan.Position);

                    if (manhattanDistance > maxDistance)
                    {
                        continue;
                    }

                    List<Point> path = aStar.GetShortestPath(organ.Position, opponentOrgan.Position, maxDistance, growStrategy, canWalkOnOpponentTentaclePaths);
                    
                    if (path.Count >= minDistance && path.Count <= maxDistance && !opponentTentaclePath[path[0].X, path[0].Y])
                    {
                        OrganDirection? direction = null;

                        // If it's a direct attack then face it. Otherwise get the direction right
                        if (path.Count == 2 || path.Count == 3)
                        {
                            direction = _directionCalculator.GetDirection(path[0], path[1]);
                        }
                        else
                        { 
                            direction = _directionCalculator.CalculateClosestOpponentDirection(path[0], path[path.Count - 1]);
                        }

                        Point target = path[path.Count - 1];
                        int childCount = opponentOrganChildren[target.X, target.Y];

                        actions.Add(new Action()
                        {
                            OrganismId = organism.RootId,
                            ActionType = ActionType.GROW,
                            OrganId = organ.Id,
                            TargetPosition = path[0],
                            OrganType = OrganType.TENTACLE,
                            OrganDirection = direction,
                            Score = 500 + childCount,
                            Source = ActionSource.CHECK_FOR_TENTACLES
                        });
                    }   
                }
            }
        }

        return actions;
    }

    private List<Action> GetShortestPathToOpponent(Point point, int minDistance, int maxDistance, GrowStrategy growStrategy, int organismId, int organId, string source)
    {
        List<Action> actions = new List<Action>();

        AStar aStar = new AStar(this);

        foreach (Organism opponentOrganism in OpponentOrganisms)
        {
            foreach (Organ opponentOrgan in opponentOrganism.Organs)
            {
                int manhattanDistance = MapChecker.CalculateManhattanDistance(point, opponentOrgan.Position);

                if (manhattanDistance > maxDistance)
                {
                    continue;
                }

                List<Point> path = aStar.GetShortestPath(point, opponentOrgan.Position, maxDistance, growStrategy, false);

                if (path.Count >= minDistance && path.Count <= maxDistance && opponentTentaclePath[path[0].X, path[0].Y])
                {
                    OrganDirection? direction = null;


                    // If it's a direct attack then face it. Otherwise get the direction right
                    if (path.Count == 2 || path.Count == 3)
                    {
                        direction = _directionCalculator.GetDirection(path[0], path[1]);
                    }
                    else
                    {
                        direction = _directionCalculator.CalculateClosestOpponentDirection(path[0], path[path.Count - 1]);
                    }

                    actions.Add(new Action()
                    {
                        OrganismId = organismId,
                        ActionType = ActionType.GROW,
                        OrganId = organId,
                        TargetPosition = path[0],
                        OrganType = OrganType.TENTACLE,
                        OrganDirection = direction,
                        Score = 500, // Tentacle moves are higher than the rest by default
                        Source = ActionSource.CHECK_FOR_TENTACLES
                    });
                }
            }
        }

        return actions;
    }

    private List<Action> GetHarvestAndConsumeActions(Organism organism, int maxProteinDistance)
    {
        List<Action> proteinActions =
               _pathFinder.GetProteinActions(organism, Proteins);

        if (proteinActions.Count == 0)
        {
            return new List<Action>();
        }

        int notHarvestingScore = 28;
        int noStockScore = 48;
        int harvesterProducingProteinScore = 10;

        foreach (Action proteinAction in proteinActions)
        {
            if (proteinAction.GoalType == GoalType.HARVEST)
            {
                switch (proteinAction.TurnsToGoal)
                {
                    case 1:
                        proteinAction.Score += 50;
                        break;
                    case 2:
                        proteinAction.Score += 40;
                        break;
                    case 3:
                        proteinAction.Score += 30;
                        break;
                    case 4:
                        proteinAction.Score += 20;
                        break;
                    case 5:
                        proteinAction.Score += 10;
                        break;
                }

                if (proteinAction.GoalProteinType == ProteinType.A && _harvestedAProteins < 1)
                {
                    proteinAction.Score += notHarvestingScore;

                    if (PlayerProteinStock.A <= 1)
                    {
                        proteinAction.Score += noStockScore;
                    }
                }
                else if (proteinAction.GoalProteinType == ProteinType.B && _harvestedBProteins < 1)
                {
                    proteinAction.Score += notHarvestingScore;

                    if (PlayerProteinStock.B <= 1)
                    {
                        proteinAction.Score += noStockScore;
                    }
                }
                else if (proteinAction.GoalProteinType == ProteinType.C && _harvestedCProteins < 1)
                {
                    proteinAction.Score += notHarvestingScore;
                    proteinAction.Score += harvesterProducingProteinScore;

                    if (PlayerProteinStock.C <= 1)
                    {
                        proteinAction.Score += noStockScore;
                        proteinAction.BlockC = true;
                    }
                }
                else if (proteinAction.GoalProteinType == ProteinType.D && _harvestedDProteins < 1)
                {
                    proteinAction.Score += notHarvestingScore;
                    proteinAction.Score += harvesterProducingProteinScore;

                    if (PlayerProteinStock.D <= 1)
                    {
                        proteinAction.Score += noStockScore;
                        proteinAction.BlockD = true;
                    }
                }

            }
            else if (proteinAction.GoalType == GoalType.CONSUME)
            {
                proteinAction.Score += 5;

                
                if (proteinAction.GoalProteinType == ProteinType.C && PlayerProteinStock.C < 0)
                {
                    proteinAction.Score += noStockScore;
                }
                else if (proteinAction.GoalProteinType == ProteinType.D && PlayerProteinStock.D < 0)
                {
                    proteinAction.Score += noStockScore;
                }
            }
        }

        proteinActions = proteinActions.OrderByDescending(p => p.Score).ToList();

        if (proteinActions[0].TurnsToGoal > maxProteinDistance && _harvestedCProteins > 0 && _harvestedDProteins > 0)
        {
            return new List<Action>();
        }

        return proteinActions;
    }

    private void UpdateSporerSpawnPoints()
    {
        foreach (Protein protein in Proteins.Where(p => !p.IsHarvested))
        {
            List<Point> possibleRootPoints = MapChecker.GetRootPoints(protein.Position, this);
            foreach (var possPoint in possibleRootPoints)
            {
                int minDistance = 3;

                if (_createdSporer.Any())
                {
                    minDistance = 2;
                }

                
                if (!MapChecker.HasNearbyOrgan(possPoint, PlayerOrganisms, minDistance))
                {
                    _sporerPoints[possPoint.X, possPoint.Y] = true;
                }
            }
        }
    }

    private (Action?, int) CheckForSporeRootAction(Organism organism, int minRootSporerDistance)
    {
        if (organism.Organs.Any(o => o.Type == OrganType.SPORER) &&
                CostCalculator.CanProduceOrgan(OrganType.ROOT, PlayerProteinStock))
        {
            List<Organ> sporers = organism.Organs.Where(o => o.Type == OrganType.SPORER).ToList();

            int furthestDistance = -1;
            int furthestSporerId = -1;
            Point furthestRootPoint = new Point(0, 0);

            foreach (Organ sporer in sporers)
            {
                Point direction = _directionCalculator.GetDelta(sporer.Direction);

                if (direction == new Point(0, 0))
                {
                    Console.Error.WriteLine($"ERROR: Couldn't get sporer direction for {sporer.Position.X}{sporer.Position.Y}");
                }

                Point checkPoint = new Point(sporer.Position.X, sporer.Position.Y);

                int distance = 1;
                bool pathClear = true;
                while (pathClear)
                {
                    checkPoint = new Point(checkPoint.X + direction.X,
                                           checkPoint.Y + direction.Y);

                    if (CheckBounds(checkPoint) == false)
                    {
                        break;
                    }

                    if (distance >= minRootSporerDistance)
                    {
                        if (_sporerPoints[checkPoint.X, checkPoint.Y])
                        {
                            if (distance > furthestDistance)
                            {
                                furthestDistance = distance;
                                furthestSporerId = sporer.Id;
                                furthestRootPoint = checkPoint;
                            }
                        }
                    }

                    if (!MapChecker.CanGrowOn(checkPoint, this, GrowStrategy.ALL_PROTEINS, false))
                    {
                        pathClear = false;
                    }

                    distance++;
                }
            }

            if (furthestDistance != -1)
            {
                Action action = new Action(){
                    OrganismId = organism.RootId,
                    ActionType = ActionType.SPORE,
                    GoalType = GoalType.ROOT,
                    GoalOrganType = OrganType.ROOT,
                    OrganId = furthestSporerId,
                    TargetPosition = furthestRootPoint,
                    TurnsToGoal = 1,
                    Score = 200,
                    OrganType = OrganType.ROOT,

                    Source = ActionSource.CHECK_FOR_ROOT
                };

                return (action, furthestDistance);
            }
        }

        return (null, -1);
    }

    private Action? CheckForSporerAction(Organism organism, int minRootSporerDistance, int extraPriorityScore)
    {
        if (CostCalculator.CanProduceOrgans( new List<OrganType> { OrganType.ROOT, OrganType.SPORER }
        ,
                                             PlayerProteinStock))
        {
            int furthestDistance = -1;
            int furthestOrgan = -1;
            Point furthestSporerPoint = new Point(0, 0);
            OrganDirection? furthestDirection = null;

            // for each organ
            foreach (Organ organ in organism.Organs)
            {
                Point organPoint = organ.Position;
                List<Point> directions = new List<Point>();

                if (organPoint.Y+1 < Height)
                {
                    directions.Add(new Point(0, 1));
                }

                if (organPoint.Y > 0)
                {
                    directions.Add(new Point(0, -1));
                }

                if (organPoint.X+1 < Width)
                {
                    directions.Add(new Point(1, 0));
                }

                if (organPoint.X > 0)
                {
                    directions.Add(new Point(-1, 0));
                }

                // Check the four points around the organ
                foreach (Point side in directions)
                {
                    Point sporerPoint = new Point(organPoint.X + side.X,
                                                  organPoint.Y + side.Y);

                    if (!MapChecker.CanGrowOn(sporerPoint, this, GrowStrategy.NO_PROTEINS, false))
                    {
                        continue;
                    }

                    // Check in all 4 directions
                    foreach (Point direction in directions)
                    {
                        Point checkPoint = new Point(sporerPoint.X,
                                                     sporerPoint.Y);

                        int distance = 1;
                        bool pathClear = true;
                        while (pathClear)
                        {
                            checkPoint = new Point(checkPoint.X + direction.X,
                                                   checkPoint.Y + direction.Y);

                            if (checkPoint.X < 0) { break; }

                            if (checkPoint.X >= Width) { break; }

                            if (checkPoint.Y < 0) { break; }

                            if (checkPoint.Y >= Height) { break; }

                            if (distance >= minRootSporerDistance)
                            {
                                //    if it's on a spawn point 
                                if (_sporerPoints[checkPoint.X, checkPoint.Y])
                                {
                                    OrganDirection? dir = null;

                                    if (direction.X == 1)
                                    {
                                        dir = OrganDirection.E;
                                    }
                                    else if (direction.X == -1)
                                    {
                                        dir = OrganDirection.W;
                                    }
                                    else if (direction.Y == -1)
                                    {
                                        dir = OrganDirection.N;
                                    }
                                    else if (direction.Y == 1)
                                    {
                                        dir = OrganDirection.S;
                                    }

                                    if (distance > furthestDistance)
                                    {
                                        furthestDistance = distance;
                                        furthestOrgan = organ.Id;
                                        furthestSporerPoint = new Point(sporerPoint.X, sporerPoint.Y);
                                        furthestDirection = dir;
                                    }
                                }
                            }

                            if (!MapChecker.CanGrowOn(checkPoint, this, GrowStrategy.ALL_PROTEINS, false))
                            {
                                pathClear = false;
                            }

                            distance++;
                        }
                    }
                }
            }

            if (furthestDistance != -1)
            {
                return new Action()
                {
                    OrganismId = organism.RootId,
                    ActionType = ActionType.GROW,
                    OrganType = OrganType.SPORER,
                    OrganId = furthestOrgan,
                    TargetPosition = furthestSporerPoint,
                    OrganDirection = furthestDirection,
                    GoalType = GoalType.SPORE,
                    TurnsToGoal = 1,
                    Score = 40 + extraPriorityScore,
                    Source = ActionSource.CHECK_FOR_SPORER
                };
            }
        }

        return null;
    }

    private List<Action> GetDesperateDestructiveMove(Organism organism, GrowStrategy growStrategy, int score, ActionSource actionSource)
    {
        List<Action> possibleActions = new List<Action>();

        (int closestOrgan, List<Point> shortestPath) = GetShortestPathToProtein(organism, Proteins, 1, 5, growStrategy);

        if (closestOrgan != -1)
        {
            if (!(hasHarvestedProtein[shortestPath[0].X, shortestPath[0].Y] && !CanFloodFillTo(shortestPath[0], 5)))
            {
                possibleActions.AddRange(CreateGrowActions(organism.RootId,
                                                       closestOrgan,
                                                       shortestPath[0],
                                                       score,
                                                       actionSource));
            }
        }
        return possibleActions;
    }

    private bool CanFloodFillTo(Point startPoint, int minAmount)
    {
        var filledCount = 0;
        var visited = new bool[Width, Height];
        var queue = new Queue<Point>();
        queue.Enqueue(startPoint);
        visited[startPoint.X, startPoint.Y] = true;

        while (queue.Count > 0)
        {
            var current = queue.Dequeue();
            filledCount++;

            if (filledCount >= minAmount)
            {
                return true;
            }

            foreach (Point direction in _directions)
            {
                var nextPoint = new Point(current.X + direction.X, current.Y + direction.Y);

                if (CheckBounds(nextPoint) && !visited[nextPoint.X, nextPoint.Y] && 
                    !isBlocked[nextPoint.X, nextPoint.Y] && 
                    !opponentTentaclePath[nextPoint.X, nextPoint.Y])
                {
                    queue.Enqueue(nextPoint);
                    visited[nextPoint.X, nextPoint.Y] = true;
                }
            }
        }

        return false;
    }

    private IEnumerable<Action> CreateGrowActions(int rootId, int closestOrgan, Point point, int score, ActionSource actionSource)
    {
        List<Action> actions = new List<Action>();

        OrganDirection? closestRootDirection = _directionCalculator.CalculateClosestOpponentDirection(point);

        if (CostCalculator.CanProduceOrgan(OrganType.BASIC, PlayerProteinStock))
        {
            actions.Add(CreateGrowAction(rootId, OrganType.BASIC, closestOrgan, point, null, score + 3, actionSource));
        }

        if (CostCalculator.CanProduceOrgan(OrganType.TENTACLE, PlayerProteinStock))
        {
            actions.Add(CreateGrowAction(rootId, OrganType.TENTACLE, closestOrgan, point, closestRootDirection, score + 2, actionSource));
        }

        if (CostCalculator.CanProduceOrgan(OrganType.SPORER, PlayerProteinStock))
        {
            actions.Add(CreateGrowAction(rootId, OrganType.SPORER, closestOrgan, point, closestRootDirection, score + 1, actionSource));
        }

        if (CostCalculator.CanProduceOrgan(OrganType.HARVESTER, PlayerProteinStock))
        {
            actions.Add(CreateGrowAction(rootId, OrganType.HARVESTER, closestOrgan, point, closestRootDirection, score, actionSource));
        }

        return actions;
    }

    private Action CreateGrowAction(int organismRootId, 
                                    OrganType? organType, 
                                    int organId, 
                                    Point targetPosition, 
                                    OrganDirection? closestRootDirection, 
                                    int score,
                                    ActionSource source)
    {
        return new Action()
        {
            OrganismId = organismRootId,
            GoalType = GoalType.GROW,
            OrganType = organType,
            ActionType = ActionType.GROW,
            OrganId = organId,
            TargetPosition = targetPosition,
            OrganDirection = closestRootDirection,
            Score = score,
            Source = source
        };
    }

    private List<Action> GetRandomGrowActions(Organism organism, bool floodFillScore)
    {
        List<Action> possibleActions = new List<Action>();
        for (int i = organism.Organs.Count - 1; i >= 0; i--)
        {
            Organ current = organism.Organs[i];

            foreach (Point direction in _directions)
            {
                Point checkPoint = new Point(current.Position.X + direction.X, 
                                             current.Position.Y + direction.Y);

                if (checkPoint.X < 0 || checkPoint.X >= Width ||
                    checkPoint.Y < 0 || checkPoint.Y >= Height)
                {
                    continue;
                }

                (OrganType? organType, OrganDirection? organDirection) = GetOrganAction(checkPoint);

                if (organType is null)
                {
                    continue;
                }

                var unharvestedScore = 2;
                var harvestedScore = 1;

                if (floodFillScore)
                {
                    unharvestedScore = 200;
                    harvestedScore = 100;

                    int floodFill = FloodFill(checkPoint);

                    if (floodFill > 80)
                    {
                        floodFill = 80;
                    }
                    unharvestedScore += floodFill;
                    harvestedScore += floodFill;
                }

                List<Action> actions = new List<Action>();
                if (MapChecker.CanGrowOn(checkPoint, this, GrowStrategy.UNHARVESTED, false))
                {
                    if (!(hasHarvestedProtein[checkPoint.X, checkPoint.Y] && !CanFloodFillTo(checkPoint, 5)))
                    {
                        actions.AddRange(CreateGrowActions(organism.RootId, current.Id, checkPoint, unharvestedScore, ActionSource.RANDOM_GROW_ACTIONS));
                        possibleActions.AddRange(actions);
                    }
                }

                if (actions.Count == 0 && MapChecker.CanGrowOn(checkPoint, this, GrowStrategy.ALL_PROTEINS, false))
                {
                    foreach (Point d in _directions)
                    {
                        if (MapChecker.CanGrowOn(new Point(checkPoint.X + d.X, checkPoint.Y + d.Y),
                                                 this,
                                                 GrowStrategy.ALL_PROTEINS,
                                                 false))
                        {
                            if (!(hasHarvestedProtein[checkPoint.X, checkPoint.Y] && !CanFloodFillTo(checkPoint, 5)))
                            {
                                possibleActions.AddRange(CreateGrowActions(organism.RootId, current.Id, checkPoint, harvestedScore, ActionSource.RANDOM_GROW_ACTIONS));

                            }
                        }
                    }
                }
            }
        }

        return possibleActions;
    }

    private int FloodFill(Point checkPoint)
    {
        int score = 0;
        var visited = new bool[Width, Height];
        var queue = new Queue<Point>();
        queue.Enqueue(checkPoint);
        visited[checkPoint.X, checkPoint.Y] = true;
        while (queue.Count > 0)
        {
            var current = queue.Dequeue();
            score++;
            foreach (var direction in _directions)
            {
                var nextPoint = new Point(current.X + direction.X, current.Y + direction.Y);
                if (CheckBounds(nextPoint) && !visited[nextPoint.X, nextPoint.Y] &&
                    !isBlocked[nextPoint.X, nextPoint.Y] &&
                    !opponentTentaclePath[nextPoint.X, nextPoint.Y])
                {
                    queue.Enqueue(nextPoint);
                    visited[nextPoint.X, nextPoint.Y] = true;
                }
            }
        }
        return score;
    }

    private (OrganType?, OrganDirection?) GetOrganAction(Point point)
    {
        OrganDirection? direction = _directionCalculator.CalculateClosestOpponentDirection(point);


        bool hasProtein = hasAnyProtein[point.X, point.Y];
        if (CostCalculator.CanProduceOrgan(OrganType.BASIC, PlayerProteinStock))
        {
            return (OrganType.BASIC, null);
        }
        else if (CostCalculator.CanProduceOrgan(OrganType.SPORER, PlayerProteinStock))
        {
            return (OrganType.SPORER, direction);
        }
        else if (CostCalculator.CanProduceOrgan(OrganType.HARVESTER, PlayerProteinStock))
        {
            return (OrganType.HARVESTER, direction);
        }
        else if (CostCalculator.CanProduceOrgan(OrganType.TENTACLE, PlayerProteinStock))
        {
            return (OrganType.TENTACLE, direction);
        }

        return (null, null);
    }

    private List<Action> PickBestActions(Dictionary<int, List<Action>> allPossibleActions)
    {
        ProteinStock tempProteinStock = new ProteinStock(PlayerProteinStock.A,
                                                         PlayerProteinStock.B,
                                                         PlayerProteinStock.C,
                                                         PlayerProteinStock.D);

        List<Action> chosenActions = new List<Action>();

        bool[] chosen = new bool[PlayerOrganisms.Count];

        List<Point> targetPositions = new List<Point>();
        List<Point> harvestTargetPositions = new List<Point>();

        bool allChosen = false;

        bool blockC = false;
        bool blockD = false;

        bool madeSporer = false;

        List<Point> goalPositions = new List<Point>();

        while (!allChosen)
        { 
            int highestScore = int.MinValue;
            int highestScoreIndex = -1;
            int highestActionIndex = -1;
            int highestOganismIndex = -1;

            for (int i = 0; i < PlayerOrganisms.Count; i++)
            {
                Organism organism = PlayerOrganisms[i];

                if (chosen[i])
                {
                    continue;
                }

                int id = organism.RootId;

                if (allPossibleActions.ContainsKey(id))
                {
                    List<Action> possibleActions = allPossibleActions[id];
                    if (possibleActions.Count > 0)
                    {
                        int actionIndex = 0;

                        bool canCreate = false;

                        while (!canCreate)
                        {
                            Action checkAction = possibleActions[actionIndex];
                            
                            if (checkAction.ActionType == ActionType.WAIT)
                            {
                                canCreate = true;
                            }
                            if (checkAction.ActionType == ActionType.GROW)
                            {
                                if (checkAction.OrganType is null)
                                {
                                    Console.Error.WriteLine("ERROR: Organ type is null");

                                }
                                if (CostCalculator.CanProduceOrgan(checkAction.OrganType.Value, tempProteinStock))
                                {
                                    canCreate = true;
                                }
                            }
                            else if (checkAction.ActionType == ActionType.SPORE)
                            {
                                if (CostCalculator.CanProduceOrgan(OrganType.ROOT, tempProteinStock))
                                {
                                    canCreate = true;
                                }
                            }

                            if (canCreate)
                            {
                                if (targetPositions.Contains(checkAction.TargetPosition))
                                {
                                    canCreate = false;
                                }

                                if (checkAction.OrganType == OrganType.HARVESTER)
                                {
                                    Point delta = _directionCalculator.GetDelta(checkAction.OrganDirection.Value);

                                    if (harvestTargetPositions.Contains(new Point(checkAction.TargetPosition.X + delta.X,
                                                                                  checkAction.TargetPosition.Y + delta.Y)))
                                    {
                                        canCreate = false;
                                    }
                                }

                                if (blockC)
                                {
                                    if (checkAction.OrganType == OrganType.ROOT ||
                                        checkAction.OrganType == OrganType.HARVESTER ||
                                        checkAction.OrganType == OrganType.TENTACLE)
                                    {
                                        canCreate = false;
                                    }
                                }

                                if (blockD)
                                {
                                    if (checkAction.OrganType == OrganType.ROOT ||
                                        checkAction.OrganType == OrganType.HARVESTER ||
                                        checkAction.OrganType == OrganType.SPORER)
                                    {
                                        canCreate = false;
                                    }
                                }

                                if (checkAction.OrganType == OrganType.SPORER && madeSporer)
                                {
                                    canCreate = false; 
                                }

                                if (checkAction.GoalPosition != new Point(-1, -1) && goalPositions.Contains(checkAction.GoalPosition))
                                {
                                    canCreate = false;
                                }                                
                            }

                            if (!canCreate)
                            {
                                actionIndex++;
                                if (actionIndex >= possibleActions.Count)
                                {
                                    actionIndex--;
                                    // We can't create it. Should we do a wait?
                                    break;
                                }
                            }
                        }

                        Action topAction = possibleActions[actionIndex];

                        if (topAction.Score > highestScore)
                        {
                            highestScore = topAction.Score;
                            highestScoreIndex = id;
                            highestActionIndex = actionIndex;
                            highestOganismIndex = i;
                        }
                    }
                    else
                    {
                        Console.Error.WriteLine("ERROR: No possible actions for organism");
                        // THIS SHOULD NEVER HAPPEN. MAYBE THROW A WAIT IN JUST IN CASE
                    }
                }   
            }

            chosen[highestOganismIndex] = true;

            Action chosenAction = allPossibleActions[highestScoreIndex][highestActionIndex];
            
            chosenActions.Add(chosenAction);
            targetPositions.Add(chosenAction.TargetPosition);
            if (chosenAction.OrganType == OrganType.HARVESTER)
            {
                // We don't want to harvest the same protein
                Point delta = _directionCalculator.GetDelta(chosenAction.OrganDirection.Value);
                harvestTargetPositions.Add(new Point(chosenAction.TargetPosition.X + delta.X, 
                                                     chosenAction.TargetPosition.Y + delta.Y));

                // We don't want to land on a harvested protein
                targetPositions.Add(new Point(chosenAction.TargetPosition.X + delta.X,
                                             chosenAction.TargetPosition.Y + delta.Y));
            }

            goalPositions.Add(chosenAction.GoalPosition);

            if (chosenAction.BlockC)
            {
                blockC = true;
            }

            if (chosenAction.BlockD)
            {
                blockD = true;
            }

            if (chosenAction.OrganType == OrganType.SPORER)
            {
                madeSporer = true;
            }

            if (chosenAction.ActionType == ActionType.GROW)
            {
                if (chosenAction.OrganType is null)
                {
                    Console.Error.WriteLine("ERROR: Organ type is null");

                }

                switch (chosenAction.OrganType)
                {
                    case OrganType.BASIC:
                        tempProteinStock.A -= 1;
                        break;
                    case OrganType.HARVESTER:
                        tempProteinStock.C -= 1;
                        tempProteinStock.D -= 1;
                        break;
                    case OrganType.SPORER:
                        tempProteinStock.B -= 1;
                        tempProteinStock.D -= 1;
                        break;
                    case OrganType.TENTACLE:
                        tempProteinStock.B -= 1;
                        tempProteinStock.C -= 1;
                        break;
                }

            }
            else if (chosenAction.ActionType == ActionType.SPORE)
            {
                tempProteinStock.A -= 1;
                tempProteinStock.B -= 1;
                tempProteinStock.C -= 1;
                tempProteinStock.D -= 1;
            }

            allChosen = chosen.All(c => c);
        }

        return chosenActions;
    }
}

internal enum GoalTarget
{
    ORGAN,
    ROOT,
    A_PROTEIN,
    B_PROTEIN,
    C_PROTEIN,
    D_PROTEIN
}



internal enum GoalType
{
    ATTACK,
    CONSUME,
    HARVEST,
    SPORE,
    ROOT,
    GROW,
    WAIT
}

internal enum GrowStrategy
{
    NO_PROTEINS,
    UNHARVESTED,
    ALL_PROTEINS
}

internal static class MapChecker
{
    internal static int CalculateManhattanDistance(Point position1, Point position2)
    {
        return Math.Abs(position1.X - position2.X) + Math.Abs(position1.Y - position2.Y);
    }

    internal static bool CanGrowOn(Point pointToCheck, Game game)
    {
        return CanGrowOn(pointToCheck, game, GrowStrategy.NO_PROTEINS, false);
    }

    internal static bool CanGrowOn(Point pointToCheck, Game game, GrowStrategy growStrategy, bool walkAcrossEnemyTentacles)
    {
        if (pointToCheck.X < 0 || 
            pointToCheck.Y < 0 || 
            pointToCheck.X >= game.Width || 
            pointToCheck.Y >= game.Height) 
        { 
            return false; 
        }

        if (game.isBlocked[pointToCheck.X, pointToCheck.Y])
        {
            return false;
        }

        if (!walkAcrossEnemyTentacles)
        {
            if (game.opponentTentaclePath[pointToCheck.X, pointToCheck.Y])
            {
                return false;
            }
            
        }

        if (growStrategy == GrowStrategy.NO_PROTEINS && game.hasAnyProtein[pointToCheck.X, pointToCheck.Y])
        {
            return false;
        }
        else if (growStrategy == GrowStrategy.UNHARVESTED && game.hasHarvestedProtein[pointToCheck.X, pointToCheck.Y])
        {
            return false;
        }

        return true;
    }

    internal static List<Point> GetRootPoints(Point position, Game game)
    {
        List<Point> rootPoints = new List<Point>();

        bool canGrowNorth = CanGrowOn(new Point(position.X, position.Y - 1), game);
        bool canGrowEast = CanGrowOn(new Point(position.X+1, position.Y), game);
        bool canGrowSouth = CanGrowOn(new Point(position.X, position.Y + 1), game);
        bool canGrowWest = CanGrowOn(new Point(position.X-1, position.Y), game);

        if (canGrowNorth)
        {
            Point farNorth = new Point(position.X, position.Y - 2);
            if (CanGrowOn(farNorth, game))
            {
                rootPoints.Add(farNorth);
            }
        }

        if (canGrowNorth || canGrowEast)
        {
            Point northEast = new Point(position.X + 1, position.Y - 1);
            if (CanGrowOn(northEast, game))
            {
                rootPoints.Add(northEast);
            }
        }

        if (canGrowEast)
        {
            Point farEast = new Point(position.X + 2, position.Y);
            if (CanGrowOn(farEast, game))
            {
                rootPoints.Add(farEast);
            }
        }

        if (canGrowEast ||canGrowSouth)
        {
            Point southEast = new Point(position.X + 1, position.Y + 1);
            if (CanGrowOn(southEast, game))
            {
                rootPoints.Add(southEast);
            }
        }

        if (canGrowSouth)
        {
            Point farSouth = new Point(position.X, position.Y + 2);
            if (CanGrowOn(farSouth, game))
            {
                rootPoints.Add(farSouth);
            }
        }

        if (canGrowSouth || canGrowWest)
        {
            Point southWest = new Point(position.X - 1, position.Y + 1);
            if (CanGrowOn(southWest, game))
            {
                rootPoints.Add(southWest);
            }
        }

        if (canGrowWest)
        {
            Point farWest = new Point(position.X - 2, position.Y);
            if (CanGrowOn(farWest, game))
            {
                rootPoints.Add(farWest);
            }
        }

        if (canGrowWest || canGrowNorth)
        {
            Point northWest = new Point(position.X - 1, position.Y - 1);
            if (CanGrowOn(northWest, game))
            {
                rootPoints.Add(northWest);
            }
        }

        return rootPoints;
    }

    internal static bool HasNearbyOrgan(Point point, List<Organism> playerOrganisms, int minDistance)
    {
        foreach (Organism organism in playerOrganisms)
        {
            foreach (Organ organ in organism.Organs)
            {
                if (Math.Abs(point.X - organ.Position.X) + Math.Abs(point.Y - organ.Position.Y) <= minDistance)
                {
                    return true;
                }
            }
        }

        return false;
    }

    // If we can draw a line from the sporer to a root then it's spored
    internal static bool HasSporerSpored(Organ sporer, Game game)
    {
        int xDelta = 0;
        int yDelta = 0;

        switch(sporer.Direction)
        {
            case OrganDirection.N:
                xDelta = 0;
                yDelta = -1;
                break;
            case OrganDirection.E:
                xDelta = 1;
                yDelta = 0;
                break;
            case OrganDirection.S:
                xDelta = 0;
                yDelta = 1;
                break;
            case OrganDirection.W:
                xDelta = -1;
                yDelta = 0;
                break;
        }

        bool hitSomething = false;

        Point checkPoint = new Point(sporer.Position.X + xDelta, sporer.Position.Y + yDelta);

        while(!hitSomething)
        {
            foreach (Organism organism in game.PlayerOrganisms)
            {
                if(organism.Organs.Any(o => o.Type == OrganType.ROOT &&
                                            o.Position == checkPoint))
                {
                    return true;
                }
            }

            if (!CanGrowOn(checkPoint, game, GrowStrategy.UNHARVESTED, false))
            {
                hitSomething = true;    

            }

            checkPoint = new Point(checkPoint.X + xDelta, checkPoint.Y + yDelta);
        }

        return false;
    }
}


internal sealed class Node
{
    public Point Position { get; set; }

    public Point Parent { get; set; }

    public int G { get; set; }
    public int H { get; set; }
    public int F { get; set; }

    public bool Closed { get; set; }

    public Node(Point position)
    {
            Position = position;
    }
}


internal struct Organ
{
    internal int Id { get; private set; }
    internal int RootId { get; private set; }

    public OrganType Type { get; set; }

    internal Point Position { get; private set; }

    internal int ParentId { get; private set; }

    internal OrganDirection Direction { get; private set; }

    public Organ(int id, int rootId, OrganType type, Point position, int parentId) : this()
    {
        Id = id;
        RootId = rootId;
        Type = type;
        Position = position;
        ParentId = parentId;
    }

    public Organ(int id, int rootId, OrganType type, Point position, int parentId, OrganDirection direction) : this(id, rootId, type, position, parentId)
    {
        Direction = direction;
    }
}

internal enum OrganDirection
{
    N,
    E,
    S,
    W
}

internal class Organism
{
    internal int RootId { get; private set; }

    internal List<Organ> Organs { get; private set; }

    internal Organism(int rootId)
    {
        Organs = new List<Organ>();
        RootId = rootId;
    }

    internal void AddOrgan(Organ organ)
    {
        Organs.Add(organ);
    }


}


internal enum OrganType
{
    BASIC,
    HARVESTER,
    ROOT,
    SPORER,
    TENTACLE,
}

partial class Player
{
    static void Main(string[] args)
    {
        string[] inputs;
        inputs = Console.ReadLine().Split(' ');
        var width = int.Parse(inputs[0]);
        var height = int.Parse(inputs[1]);

        Game game = new Game(width, height);

        while (true)
        {
            var unsortedPlayerOrgans = new List<Organ>();
            var unsortedOpponentOrgans = new List<Organ>();
            var proteins = new List<Protein>();
            var walls = new bool[width, height]; 

            int entityCount = int.Parse(Console.ReadLine());
            for (int i = 0; i < entityCount; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                int x = int.Parse(inputs[0]);
                int y = int.Parse(inputs[1]);
                string type = inputs[2];
                int owner = int.Parse(inputs[3]);
                int organId = int.Parse(inputs[4]); 
                string organDir = inputs[5];
                int organParentId = int.Parse(inputs[6]);
                int organRootId = int.Parse(inputs[7]);

                if (Enum.TryParse(type, out OrganType organTypeEnum))
                {
                    switch (type)
                    {
                        case "BASIC":
                        case "ROOT":
                            if (owner == 1)
                            {
                                unsortedPlayerOrgans.Add(
                                    CreateOrgan(
                                        organId,
                                        organRootId,
                                        organTypeEnum,
                                        new Point(x, y),
                                        organParentId));
                            }
                            else if (owner == 0)
                            {
                                unsortedOpponentOrgans.Add(
                                    CreateOrgan(
                                        organId,
                                        organRootId,
                                        organTypeEnum,
                                        new Point(x, y),
                                        organParentId));
                            }

                            break;

                        case "HARVESTER":
                        case "SPORER":
                        case "TENTACLE":
                            OrganDirection dirEnum;
                            if (Enum.TryParse(organDir, out dirEnum))
                            {
                                if (owner == 1)
                                {
                                    unsortedPlayerOrgans.Add(
                                        CreateDirectionOrgan(
                                            organId,
                                            organRootId,
                                            organTypeEnum,
                                            new Point(x, y),
                                            organParentId,
                                            dirEnum));
                                }
                                else if (owner == 0)
                                {
                                    unsortedOpponentOrgans.Add(
                                        CreateDirectionOrgan(
                                            organId,
                                            organRootId,
                                            organTypeEnum,
                                            new Point(x, y),
                                            organParentId,
                                            dirEnum));
                                }
                            }
                            break;
                    }
                }
                else
                {
                    switch (type)
                    {
                        case "A":
                            proteins.Add(new Protein(ProteinType.A, new Point(x, y)));
                            break;
                        case "B":
                            proteins.Add(new Protein(ProteinType.B, new Point(x, y)));
                            break;
                        case "C":
                            proteins.Add(new Protein(ProteinType.C, new Point(x, y)));
                            break;
                        case "D":
                            proteins.Add(new Protein(ProteinType.D, new Point(x, y)));
                            break;
                        case "WALL":
                            walls[x, y] = true;
                            break;
                    }
                }
            }

            List<Organism> playerOrganisms = SortOrgans(unsortedPlayerOrgans);
            game.SetPlayerOrganisms(playerOrganisms);
            List<Organism> opponentOrganisms = SortOrgans(unsortedOpponentOrgans);
            game.SetOpponentOrganisms(opponentOrganisms);

            game.SetWalls(walls);
            game.SetProteins(proteins);

            ProteinStock playerProteins = GetProteins();
            game.SetPlayerProteinStock(playerProteins);

            ProteinStock opponentProteins = GetProteins();
            game.SetOpponentProteinStock(opponentProteins);

            List<Action> actions = game.GetActions();

            int requiredActionsCount = int.Parse(Console.ReadLine()); 
            for (int i = 0; i < requiredActionsCount; i++)
            {
                Console.WriteLine(actions[i].ToString());
            }
        }
    }

    private static ProteinStock GetProteins()
    {
        string[] inputs = Console.ReadLine().Split(' ');
        int proteinA = int.Parse(inputs[0]);
        int proteinB = int.Parse(inputs[1]);
        int proteinC = int.Parse(inputs[2]);
        int proteinD = int.Parse(inputs[3]);

        ProteinStock proteins = new ProteinStock(proteinA, proteinB, proteinC, proteinD);

        return proteins;
    }

    private static Organ CreateOrgan(int organId, int rootId, OrganType organType, Point point, int parentId)
    {
        return new Organ(organId, rootId, organType, point, parentId);
    }

    private static Organ CreateDirectionOrgan(int organId, int rootId, OrganType organType, Point point, int parentId, OrganDirection direction)
    {
        return new Organ(organId, rootId, organType, point, parentId, direction);
    }

    private static List<Organism> SortOrgans(List<Organ> unsortedOrgans)
    {
        List<Organism> organisms = new List<Organism>();

        unsortedOrgans = unsortedOrgans.OrderBy(o => o.Type != OrganType.ROOT).ToList();

        foreach (Organ organ in unsortedOrgans)
        {
            if (organ.Type == OrganType.ROOT)
            {
                Organism organism = new Organism(organ.Id);
                organism.AddOrgan(organ);
                organisms.Add(new Organism(organ.Id));
            }

            organisms.Single(o => o.RootId == organ.RootId).AddOrgan(organ);
        }

        return organisms;
    }
}

internal class Protein
{
    internal ProteinType Type { get; private set; }
    internal Point Position { get; private set; }

    internal bool IsHarvested { get; set; }

    internal Protein(ProteinType type, Point position)
    {
        Type = type;
        Position = position;
    }

    internal Protein Clone()
    {
        return new Protein(Type, Position)
        {
            IsHarvested = IsHarvested
        };
    }
}


internal struct ProteinStock(int a, int b, int c, int d)
{
    public int A { get; set; } = a;
    public int B { get; set; } = b;
    public int C { get; set; } = c;
    public int D { get; set; } = d;
}

internal enum ProteinType
{
    NONE = 0,
    A,
    B,
    C,
    D
}

