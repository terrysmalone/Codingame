/**************************************************************
  This file was generated by FileConcatenator.
  It combined all classes in the project to work in Codingame.
***************************************************************/

using System.Drawing;
using System.Runtime.CompilerServices;
using System.Net.WebSockets;
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;

class Agent
{
    public int Id { get; private set; }
    public int Player { get; private set; }
    public int ShootCooldown { get; set; }
    public int OptimalRange { get; private set; }
    public int SoakingPower { get; private set; }
    public int SplashBombs { get; set; }

    public int Wetness { get; set; }

    public Point Position { get; private set; } = new Point(-1, -1);

    public bool InGame { get; set; } = false;

    public Agent(int id, int player, int shootCooldown, int optimalRange, int soakingPower, int splashBombs)
    {
        Id = id;
        Player = player;
        ShootCooldown = shootCooldown;
        OptimalRange = optimalRange;
        SoakingPower = soakingPower;
        SplashBombs = splashBombs;
    }

    internal void UpdatePosition(int x, int y)
    {
        Position = new Point(x, y);
    }
}

public class CoverMap
{
    private int width, height;
    public double[,] CreateCoverMap(int xPos, int yPos, int[,] cover)
    {
        width = cover.GetLength(0);
        height = cover.GetLength(1);
        var coverMap = new double[width, height];

        // Populate all elements with 1.0
        for (int i = 0; i < width; i++)
        {
            for (int j = 0; j < height; j++)
            {
                coverMap[i, j] = 1.0;
            }
        }

        // Set the current position to 0.0
        coverMap[xPos, yPos] = 0.0; 

        // Check if north is protected
        if (yPos - 2 >= 0 && cover[xPos, yPos - 1] > 0)
        {
            var fillValue = GetCoverProtectionValue(cover[xPos, yPos - 1]);
                
            // Fill all values to the north
            for (int y = 0; y <= yPos - 2; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    coverMap[x, y] = fillValue;
                }
            }

            // Set adjacent tiles back to 1.0
            if (xPos - 1 >= 0)
            {
                coverMap[xPos - 1, yPos - 2] = 1.0;
            }
            coverMap[xPos, yPos - 2] = 1.0;
            if (xPos + 1 < width)
            {
                coverMap[xPos + 1, yPos - 2] = 1.0;
            }
        }

        // Check if south is protected
        if (yPos + 2 <= height-1 && cover[xPos, yPos + 1] > 0)
        {
            var fillValue = GetCoverProtectionValue(cover[xPos, yPos + 1]);
            // Fill all values to the south
            for (int y = yPos + 2; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    coverMap[x, y] = fillValue;
                }
            }

            // Set adjacent tiles back to 1.0
            if (xPos - 1 >= 0)
            {
                coverMap[xPos - 1, yPos + 2] = 1.0;
            }
            coverMap[xPos, yPos + 2] = 1.0;
            if (xPos + 1 < width)
            {
                coverMap[xPos + 1, yPos + 2] = 1.0;
            }
        }

        // Check if east is protected
        if (xPos + 2 < width && cover[xPos + 1, yPos] > 0)
        {
            var fillValue = GetCoverProtectionValue(cover[xPos + 1, yPos]);
            // Fill all values to the east
            for (int x = xPos + 2; x < width; x++)
            {
                for (int y = 0; y < height; y++)
                {
                    // Don't fill it if it's already covered by large cover
                    if (coverMap[x, y] != 0.25)
                    {
                        coverMap[x, y] = fillValue;
                    }
                }
            }
            // Set adjacent tiles back to 1.0
            if (yPos - 1 >= 0)
            {
                coverMap[xPos + 2, yPos - 1] = 1.0;
            }
            coverMap[xPos + 2, yPos] = 1.0;
            if (yPos + 1 < height)
            {
                coverMap[xPos + 2, yPos + 1] = 1.0;
            }
        }

        // Check if west is protected
        if (xPos - 2 >= 0 && cover[xPos - 1, yPos] > 0)
        {
            var fillValue = GetCoverProtectionValue(cover[xPos - 1, yPos]);
            // Fill all values to the west
            for (int x = 0; x <= xPos - 2; x++)
            {
                for (int y = 0; y < height; y++)
                {
                    // Don't fill it if it's already covered by large cover
                    if (coverMap[x, y] != 0.25)
                    {
                        coverMap[x, y] = fillValue;
                    }
                }
            }
            // Set adjacent tiles back to 1.0
            if (yPos - 1 >= 0)
            {
                coverMap[xPos - 2, yPos - 1] = 1.0;
            }
            coverMap[xPos - 2, yPos] = 1.0;
            if (yPos + 1 < height)
            {
                coverMap[xPos - 2, yPos + 1] = 1.0;
            }
        }

        return coverMap;
    }

    private double GetCoverProtectionValue(int coverType)
    {
        if (coverType == 1)
        {
            return 0.5;
        }
        else if (coverType == 2)
        {
            return 0.25;
        }

        return 1.0;
    }
}

internal static class Display
{
    internal static void CoverMap(double[,] coverMap)
    {
        Console.Error.WriteLine("Cover Map:");
        for (int y = 0; y < coverMap.GetLength(1); y++)
        {
            for (int x = 0; x < coverMap.GetLength(0); x++)
            {
                Console.Error.Write($"{coverMap[x, y]:F2} ");
            }
            Console.Error.WriteLine();
        }
    }

    internal static void SplashMap(int[,] splashMap)
    {
        Console.Error.WriteLine("Splash Map:");
        for (int y = 0; y < splashMap.GetLength(1); y++)
        {
            for (int x = 0; x < splashMap.GetLength(0); x++)
            {
                Console.Error.Write($"{splashMap[x, y]} ");
            }
            Console.Error.WriteLine();
        }
    }
}

class Game
{
    public int Width { get; private set; }
    public int Height { get; private set; }

    public int MyId { get; private set; }

    List<Agent> playerAgents = new List<Agent>();
    List<Agent> opponentAgents = new List<Agent>();

    int[,] cover;

    private CoverMap coverMap;

    public Game(int myId)
    {
        MyId = myId;

        coverMap = new CoverMap();
    }

    public void SetGameSize(int width, int height)
    {
        Width = width;
        Height = height;

        cover = new int[Width, Height];
    }

    internal void AddAgent(int id, int player, int shootCooldown, int optimalRange, int soakingPower, int splashBombs)
    {
        if (player == MyId)
        {
            playerAgents.Add(new Agent(id, player, shootCooldown, optimalRange, soakingPower, splashBombs));
        }
        else
        {
            opponentAgents.Add(new Agent(id, player, shootCooldown, optimalRange, soakingPower, splashBombs));
        }
    }

    internal void MarkAllAgentsForCulling()
    {
        foreach (var agent in playerAgents)
        {
            agent.InGame = false;
        }

        foreach (var agent in opponentAgents)
        {
            agent.InGame = false;
        }
    }

    internal void DestroyMarkedAgents()
    {
        playerAgents.RemoveAll(agent => !agent.InGame);
        opponentAgents.RemoveAll(agent => !agent.InGame);
    }

    internal void UpdateAgent(int agentId, int x, int y, int cooldown, int splashBombs, int wetness)
    {
        Agent agent = playerAgents.FirstOrDefault(a => a.Id == agentId) 
            ?? opponentAgents.FirstOrDefault(a => a.Id == agentId);

        if (agent != null)
        {
            agent.UpdatePosition(x, y);
            agent.ShootCooldown = cooldown;
            agent.SplashBombs = splashBombs;
            agent.Wetness = wetness;
            agent.InGame = true; // Mark it as still in game
        }
    }

    // One line per agent: <agentId>;<action1;action2;...> actions are "MOVE x y | SHOOT id | THROW x y | HUNKER_DOWN | MESSAGE text"
    internal List<string> GetMoves()
    {
        SplashMap splashMap = new SplashMap(Width, Height, playerAgents, opponentAgents);
        int[,] splashDamageMap = splashMap.CreateSplashMap();

        Display.SplashMap(splashDamageMap);

        List<string> moves = new List<string>();

        foreach (var agent in playerAgents)
        {
            moves.Add(GetRunAndThrowMove(agent, splashDamageMap));

            // moves.Add(GetRunAndGunMove(agent));
            // To debug: Console.Error.WriteLine("Debug messages...");
        }

        return moves;
    }

    private string GetRunAndThrowMove(Agent agent, int[,] splashDamageMap)
    {
        // Get position of highest value in splashDamageMap
        int bestX = -1;
        int bestY = -1;
        int bestValue = -1;

        for (int x = 0; x < Width; x++)
        {
            for (int y = 0; y < Height; y++)
            {
                if (splashDamageMap[x, y] > bestValue)
                {
                    bestValue = splashDamageMap[x, y];
                    bestX = x;
                    bestY = y;
                }
            }
        }

        // Get distance from bestX, bestY to agent's position
        int distance = Math.Abs(agent.Position.X - bestX) + Math.Abs(agent.Position.Y - bestY);

        if (distance > 4)
        {
            // If the distance is greater than 4, we need to move closer
            var moveX = agent.Position.X < bestX ? agent.Position.X + 1 : agent.Position.X - 1;
            var moveY = agent.Position.Y < bestY ? agent.Position.Y + 1 : agent.Position.Y - 1;
            return $"{agent.Id}; MOVE {moveX} {moveY}; THROW {bestX} {bestY}";
        }
        else
        {
            // If we are close enough, throw the splash bomb
            return $"{agent.Id}; THROW {bestX} {bestY}";
        }
    }

    private string GetRunAndGunMove(Agent agent)
    {
        // Get highest adjacent protection
        Point bestProtection = GetBestAdjacentProtection(agent.Position);

        var bestAttack = 0.0;
        var bestAttackId = -1;

        foreach (var enemy in opponentAgents)
        {
            var damage = CalculateDamage(
                bestProtection.X,
                bestProtection.Y,
                agent.OptimalRange,
                agent.SoakingPower,
                enemy);

            if (damage > bestAttack)
            {
                bestAttack = damage;
                bestAttackId = enemy.Id;
            }
        }

        return $"{agent.Id}; MOVE {bestProtection.X} {bestProtection.Y}; SHOOT {bestAttackId}";
    }

    private double CalculateDamage(int x, int y, int optimalRange, int soakingPower, Agent enemy)
    {
        double[,] map = coverMap.CreateCoverMap(enemy.Position.X, enemy.Position.Y, cover);

        var damageMultiplier = map[x, y];
        var baseDamage = soakingPower * damageMultiplier;

        int manhattanDistance = Math.Abs(enemy.Position.X - x) + Math.Abs(enemy.Position.Y - y);

        if (manhattanDistance <= optimalRange)
        {
            return baseDamage;
        }
        //else if (manhattanDistance <= optimalRange * 2)
        //{
        //    return baseDamage / 2;
        //}
        else
        {
            return 0;
        }

    }

    // Get the compass pooint square (N,E,S,W) with the best cover
    private Point GetBestAdjacentProtection(Point position)
    {
        var north = GetHighestCover(position.X, position.Y - 1);

        var best = north;
        var bestX = position.X;
        var bestY = position.Y - 1;

        var south = GetHighestCover(position.X, position.Y + 1);

        if (south > best)
        {
            best = south;
            bestX = position.X;
            bestY = position.Y + 1;
        }

        var east = GetHighestCover(position.X + 1, position.Y);

        if (east > best)
        {
            best = east;
            bestX = position.X + 1;
            bestY = position.Y;
        }

        var west = GetHighestCover(position.X - 1, position.Y);

        if (west > best)
        {
            best = west;
            bestX = position.X - 1;
            bestY = position.Y;
        }

        return new Point(bestX, bestY);
    }

    private int GetHighestCover(int x, int y)
    {
        if (x < 0 || x >= Width || y < 0 || y >= Height)
        {
            // Out of bounds
            return 0; 
        }

        var best = 0;

        // Check North
        if (y - 1 >= 0 && cover[x, y - 1] > best)
        {
            best = cover[x, y - 1];
        }

        // Check South
        if (y + 1 < Height && cover[x, y + 1] > best)
        {
            best = cover[x, y + 1];
        }

        // Check east
        if (x + 1 < Width && cover[x + 1, y] > best)
        {
            best = cover[x + 1, y];
        }

        // Check west   
        if (x - 1 >= 0 && cover[x - 1, y] > best)
        {
            best = cover[x - 1, y];
        }

        return best;
    }

    private int GetWettestOpponentId()
    {
        int wettestOpponentId = -1;
        int maxWetness = -1;

        foreach (var agent in opponentAgents)
        {
            if (agent.Wetness > maxWetness)
            {
                maxWetness = agent.Wetness;
                wettestOpponentId = agent.Id;
            }
        }

        return wettestOpponentId;
    }

    internal void SetCover(int x, int y, int tileType)
    {
        if (x < 0 || x >= Width || y < 0 || y >= Height)
        {
            Console.Error.WriteLine($"Cover position {x}, {y} out of bounds");
            return;
        }
        cover[x, y] = tileType;
    }
}


class Player
{
 

    static void Main(string[] args)
    {
        string[] inputs;
        int myId = int.Parse(Console.ReadLine()); // Your player id (0 or 1)
        int agentDataCount = int.Parse(Console.ReadLine()); // Total number of agents in the game

        var game = new Game(myId);

        for (int i = 0; i < agentDataCount; i++)
        {
            inputs = Console.ReadLine().Split(' ');
            int agentId = int.Parse(inputs[0]); // Unique identifier for this agent
            int player = int.Parse(inputs[1]); // Player id of this agent
            int shootCooldown = int.Parse(inputs[2]); // Number of turns between each of this agent's shots
            int optimalRange = int.Parse(inputs[3]); // Maximum manhattan distance for greatest damage output
            int soakingPower = int.Parse(inputs[4]); // Damage output within optimal conditions
            int splashBombs = int.Parse(inputs[5]); // Number of splash bombs this can throw this game

            game.AddAgent(agentId, player, shootCooldown, optimalRange, soakingPower, splashBombs);
        }

        inputs = Console.ReadLine().Split(' ');
        int width = int.Parse(inputs[0]); // Width of the game map
        int height = int.Parse(inputs[1]); // Height of the game map

        game.SetGameSize(width, height);

        for (int i = 0; i < height; i++)
        {
            inputs = Console.ReadLine().Split(' ');
            for (int j = 0; j < width; j++)
            {
                int x = int.Parse(inputs[3 * j]);// X coordinate, 0 is left edge
                int y = int.Parse(inputs[3 * j + 1]);// Y coordinate, 0 is top edge
                int tileType = int.Parse(inputs[3 * j + 2]);

                if (tileType > 0)
                {
                    game.SetCover(x, y, tileType);
                }
            }
        }

        int count = 1;

        // game loop
        while (true)
        {
            // This is a workaround for a weird bug I found. Hopefully They'll fix it
            if (count > 1)
            {
                Console.ReadLine();
            }

            game.MarkAllAgentsForCulling();

            int agentCount = int.Parse(Console.ReadLine()); // Total number of agents still in the game
            
            for (int i = 0; i < agentCount; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                
                int agentId = int.Parse(inputs[0]);
                int x = int.Parse(inputs[1]);
                int y = int.Parse(inputs[2]);
                int cooldown = int.Parse(inputs[3]); // Number of turns before this agent can shoot
                int splashBombs = int.Parse(inputs[4]);
                int wetness = int.Parse(inputs[5]); // Damage (0-100) this agent has taken

                game.UpdateAgent(agentId, x, y, cooldown, splashBombs, wetness);
            }

            game.DestroyMarkedAgents();

            List<string> moves = game.GetMoves();
            foreach (var move in moves)
            {
                Console.WriteLine(move);
            }

            count++;
        }
    }
}


internal class SplashMap
{
    private int width;
    private int height;
    private List<Agent> playerAgents;
    private List<Agent> opponentAgents;

    public SplashMap(int width, int height, List<Agent> playerAgents, List<Agent> opponentAgents)
    {
        this.width = width;
        this.height = height;
        this.playerAgents = playerAgents;
        this.opponentAgents = opponentAgents;
    }

    internal int[,] CreateSplashMap()
    {
        int[,] splashMap = new int[width, height];

        for (int x = 0; x < width; x++)
        {
            for (int y = 0; y < height; y++)
            {
                splashMap[x, y] = CalculateDamage(x, y);
            }
        }

        return splashMap;
    }

    private int CalculateDamage(int x, int y)
    {
        var damage = 0;

        var minX = Math.Max(0, x - 1);
        var maxX = Math.Min(width - 1, x + 1);
        var minY = Math.Max(0, y - 1);
        var maxY = Math.Min(height - 1, y + 1);

        for (int i = minX; i <= maxX; i++)
        {
            for (int j = minY; j <= maxY; j++)
            {
                foreach (var agent in playerAgents)
                {
                    if (agent.Position.X == i && agent.Position.Y == j)
                    {
                        // If we hit an agent we want to return no damage
                        return 0;
                    }
                }

                foreach (var enemy in opponentAgents)
                {
                    if (enemy.Position.X == i && enemy.Position.Y == j)
                    {
                        damage += 30;
                    }
                }
            }
        }

        return damage;
    }
}

