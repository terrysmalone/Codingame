/**************************************************************
  This file was generated by FileConcatenator.
  It combined all classes in the project to work in Codingame.
***************************************************************/

using System.Drawing;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Reflection.Metadata.Ecma335;
using System.Runtime.CompilerServices;
using System.Net.WebSockets;
using System.IO;
using System.Collections;
using System.ComponentModel;

public class ActionIntention
{
    public string Command { get; set; } = "";
    public string Source { get; set; } = "";
}


class Agent
{
    public int Id { get; private set; }
    public int Player { get; private set; }
    public int ShootCooldown { get; set; }
    public int OptimalRange { get; private set; }
    public int SoakingPower { get; private set; }
    public int SplashBombs { get; set; }
    public int Wetness { get; set; }
    public Point Position { get; private set; } = new Point(-1, -1);
    public Priority AgentPriority { get; set; } = Priority.Advancing;
    public MoveIntention MoveIntention { get; set; } = new MoveIntention();
    public ActionIntention ActionIntention { get; set; } = new ActionIntention();

    public int ShootToKillId { get; set; } = -1; // Id of the agent to shoot to kill, -1 if no target
    public int ShootToSoakId { get; set; } = -1; // Id of the agent to shoot to soak, -1 if no target
    public bool InGame { get; set; } = false;

    public Agent(int id, int player, int shootCooldown, int optimalRange, int soakingPower, int splashBombs)
    {
        Id = id;
        Player = player;
        ShootCooldown = shootCooldown;
        OptimalRange = optimalRange;
        SoakingPower = soakingPower;
        SplashBombs = splashBombs;
    }

    internal void UpdatePosition(int x, int y)
    {
        Position = new Point(x, y);
    }

    internal void ResetIntentions()
    {
        MoveIntention = new MoveIntention();
        ActionIntention = new ActionIntention();

        ShootToKillId = -1;
        ShootToSoakId = -1;
    }
}

internal sealed class AStar
{
    private readonly int[,] cover;
    private int _width, _height;

    private List<Node> _nodes = new List<Node>();
    
    internal AStar(int[,] cover)
    {
        this.cover = cover;
        _width = cover.GetLength(0);
        _height = cover.GetLength(1);
    }

    internal List<Point> GetShortestPath(Point startPoint, Point targetPoint)
    {
        return GetShortestPath(startPoint, targetPoint, int.MaxValue);
    }

    internal List<Point> GetShortestPath(Point startPoint, Point targetPoint, int maxDistance)
    {
        _nodes = new List<Node>();

        Node currentNode = new Node(startPoint);

        _nodes.Add(currentNode);

        bool targetFound = false;

        int timeToSearch = 0;
        while (!targetFound)
        {
            if (_nodes.Count(n => n.Closed == false) == 0)
            {
                return new List<Point>();
            }

            Point[] pointsToCheck = new Point[4];

            // Prioritise heading towards the target as the first move
            if (Math.Abs(startPoint.X - targetPoint.X) >  Math.Abs(startPoint.Y - targetPoint.Y))
            {
                pointsToCheck[0] = new Point(Math.Min(_width - 1, currentNode.Position.X + 1), currentNode.Position.Y);
                pointsToCheck[1] = new Point(Math.Max(0, currentNode.Position.X - 1), currentNode.Position.Y);
                pointsToCheck[2] = new Point(currentNode.Position.X, Math.Min(_height - 1, currentNode.Position.Y + 1));
                pointsToCheck[3] = new Point(currentNode.Position.X, Math.Max(0, currentNode.Position.Y - 1));
            }
            else
            {
                pointsToCheck[0] = new Point(currentNode.Position.X, Math.Min(_height - 1, currentNode.Position.Y + 1));
                pointsToCheck[1] = new Point(currentNode.Position.X, Math.Max(0, currentNode.Position.Y - 1));
                pointsToCheck[2] = new Point(Math.Min(_width - 1, currentNode.Position.X + 1), currentNode.Position.Y);
                pointsToCheck[3] = new Point(Math.Max(0, currentNode.Position.X - 1), currentNode.Position.Y);
            }

            foreach (Point pointToCheck in pointsToCheck)
            {
                Node? existingNode = _nodes.SingleOrDefault(n => n.Position == pointToCheck);

                if (existingNode == null)
                {
                    if (pointToCheck == startPoint || pointToCheck == targetPoint || cover[pointToCheck.X, pointToCheck.Y] == 0)
                    {
                        Node node = new Node(pointToCheck);

                        node.Parent = currentNode.Position;

                        node.G = currentNode.G + 1;

                        if (node.G > maxDistance)
                            continue;

                        node.H = CalculationUtil.GetManhattanDistance(pointToCheck, targetPoint);
                        node.F = node.G + node.H;

                        _nodes.Add(node);
                    }
                }
                else
                {
                    if (!existingNode.Closed)
                    {
                        int g = currentNode.G + 1;

                        if (g < existingNode.G)
                        {
                            existingNode.G = g;

                            if (existingNode.G > maxDistance)
                                continue;

                            existingNode.F = existingNode.G + existingNode.H;

                            existingNode.Parent = currentNode.Position;
                        }
                    }
                }
            }

            currentNode.Closed = true;

            if (currentNode.Position == targetPoint)
            {
                targetFound = true;
            }
            else
            {
                _nodes = _nodes.OrderBy(n => n.Closed == true).ThenBy(n => n.F).ToList();

                currentNode = _nodes.First();
            }

            timeToSearch++;

            if (timeToSearch > 1000)
            {
                Console.Error.WriteLine("Warning: Time to search hit 1000");
            }
        }

        int numberOfSteps = currentNode.G;

        List<Point> shortestPath = [currentNode.Position];

        bool atStart = false;

        while (!atStart)
        {
            currentNode = _nodes.Single(n => n.Position == currentNode.Parent);

            if (currentNode.Position == startPoint)
            {
                atStart = true;
            }
            else
            {
                shortestPath.Insert(0, currentNode.Position);
            }
        }

        return shortestPath;
    }
}


public static class CalculationUtil
{
    public static int GetManhattanDistance(Point point1, Point point2)
    {
        return Math.Abs(point1.X - point2.X) + Math.Abs(point1.Y - point2.Y);

    }

    internal static double GetEuclideanDistance(Point point1, Point point2)
    {
        return Math.Sqrt(Math.Pow(point1.X - point2.X, 2) + Math.Pow(point1.Y - point2.Y, 2));
    }
}


public static class ClosestPeakFinder
{
    public static (Point, double) FindClosestPeak(Point position, double[,] damageMap)
    {
        double highestValue = damageMap.Cast<double>().Max();

        Queue<Point> queue = new Queue<Point>();
        HashSet<Point> visited = new HashSet<Point>();
        queue.Enqueue(position);
        visited.Add(position);

        while (queue.Count > 0)
        {
            Point current = queue.Dequeue();
            if (current.X < 0 || current.Y < 0 || current.X >= damageMap.GetLength(0) || current.Y >= damageMap.GetLength(1))
            {
                continue; 
            }

            double value = damageMap[current.X, current.Y];

            if (value == highestValue)
            {
                return (current, value);
            }
            // Add neighbors to the queue
            foreach (Point neighbor in GetNeighbors(current))
            {
                if (!visited.Contains(neighbor))
                {
                    visited.Add(neighbor);
                    queue.Enqueue(neighbor);
                }
            }
        }

        Console.Error.WriteLine("ERROR: No peak found in the damage map.");
        return (new Point(-1, -1), -1);

    }

    private static IEnumerable<Point> GetNeighbors(Point current)
    {
        yield return new Point(current.X - 1, current.Y); // Left
        yield return new Point(current.X + 1, current.Y); // Right
        yield return new Point(current.X, current.Y - 1); // Up
        yield return new Point(current.X, current.Y + 1); // Down
        yield return new Point(current.X - 1, current.Y - 1); // Top-left
        yield return new Point(current.X + 1, current.Y - 1); // Top-right
        yield return new Point(current.X - 1, current.Y + 1); // Bottom-left
        yield return new Point(current.X + 1, current.Y + 1); // Bottom-right
    }
}


public class CoverMapGenerator
{
    private int _width, _height;
    private int[,] _cover;

    public CoverMapGenerator(int[,] cover)
    {
        _width = cover.GetLength(0);
        _height = cover.GetLength(1);
        _cover = cover;
    }

    public double[,] CreateCoverMap(int xPos, int yPos)
    {
        var coverMap = new double[_width, _height];

        // Populate all elements with 1.0
        for (int i = 0; i < _width; i++)
        {
            for (int j = 0; j < _height; j++)
            {
                coverMap[i, j] = 1.0;
            }
        }

        // Set the current position to 0.0
        coverMap[xPos, yPos] = 0.0; 

        // Check if north is protected
        if (yPos - 2 >= 0 && _cover[xPos, yPos - 1] > 0)
        {
            var fillValue = GetCoverProtectionValue(_cover[xPos, yPos - 1]);
                
            // Fill all values to the north
            for (int y = 0; y <= yPos - 2; y++)
            {
                for (int x = 0; x < _width; x++)
                {
                    coverMap[x, y] = fillValue;
                }
            }

            // Set adjacent tiles back to 1.0
            if (xPos - 1 >= 0)
            {
                coverMap[xPos - 1, yPos - 2] = 1.0;
            }
            coverMap[xPos, yPos - 2] = 1.0;
            if (xPos + 1 < _width)
            {
                coverMap[xPos + 1, yPos - 2] = 1.0;
            }
        }

        // Check if south is protected
        if (yPos + 2 <= _height-1 && _cover[xPos, yPos + 1] > 0)
        {
            var fillValue = GetCoverProtectionValue(_cover[xPos, yPos + 1]);
            // Fill all values to the south
            for (int y = yPos + 2; y < _height; y++)
            {
                for (int x = 0; x < _width; x++)
                {
                    coverMap[x, y] = fillValue;
                }
            }

            // Set adjacent tiles back to 1.0
            if (xPos - 1 >= 0)
            {
                coverMap[xPos - 1, yPos + 2] = 1.0;
            }
            coverMap[xPos, yPos + 2] = 1.0;
            if (xPos + 1 < _width)
            {
                coverMap[xPos + 1, yPos + 2] = 1.0;
            }
        }

        // Check if east is protected
        if (xPos + 2 < _width && _cover[xPos + 1, yPos] > 0)
        {
            var fillValue = GetCoverProtectionValue(_cover[xPos + 1, yPos]);
            // Fill all values to the east
            for (int x = xPos + 2; x < _width; x++)
            {
                for (int y = 0; y < _height; y++)
                {
                    // Don't fill it if it's already covered by large cover
                    if (coverMap[x, y] != 0.25)
                    {
                        coverMap[x, y] = fillValue;
                    }
                }
            }
            // Set adjacent tiles back to 1.0
            if (yPos - 1 >= 0)
            {
                coverMap[xPos + 2, yPos - 1] = 1.0;
            }
            coverMap[xPos + 2, yPos] = 1.0;
            if (yPos + 1 < _height)
            {
                coverMap[xPos + 2, yPos + 1] = 1.0;
            }
        }

        // Check if west is protected
        if (xPos - 2 >= 0 && _cover[xPos - 1, yPos] > 0)
        {
            var fillValue = GetCoverProtectionValue(_cover[xPos - 1, yPos]);
            // Fill all values to the west
            for (int x = 0; x <= xPos - 2; x++)
            {
                for (int y = 0; y < _height; y++)
                {
                    // Don't fill it if it's already covered by large cover
                    if (coverMap[x, y] != 0.25)
                    {
                        coverMap[x, y] = fillValue;
                    }
                }
            }
            // Set adjacent tiles back to 1.0
            if (yPos - 1 >= 0)
            {
                coverMap[xPos - 2, yPos - 1] = 1.0;
            }
            coverMap[xPos - 2, yPos] = 1.0;
            if (yPos + 1 < _height)
            {
                coverMap[xPos - 2, yPos + 1] = 1.0;
            }
        }

        return coverMap;
    }

    private double GetCoverProtectionValue(int coverType)
    {
        if (coverType == 1)
        {
            return 0.5;
        }
        else if (coverType == 2)
        {
            return 0.25;
        }

        return 1.0;
    }
}

internal class DamageCalculator
{
    private CoverMapGenerator _coverMapGenerator;

    internal DamageCalculator(CoverMapGenerator coverMapGenerator)
    {
        _coverMapGenerator = coverMapGenerator;
    }

    // Calculates the maximum damage an agent can deal if positioned at (x,y)
    // based on the list of opponentAgents
    internal double CalculateHighestAttackingPlayerDamage(Agent agent, int x, int y, List<Agent> opponentAgents)
    {
        var highestDamage = 0.0;
        foreach (var enemy in opponentAgents)
        {
            var damage = CalculateDamage(
                x,
                y,
                agent.OptimalRange,
                agent.SoakingPower,
                enemy.Position.X,
                enemy.Position.Y);

            if (damage > highestDamage)
            {
                highestDamage = damage;
            }

        }

        return highestDamage;
    }


    // Calculates the total damage the position (x,y) can receive from opponentAgents
    // Note: The total is theoretical and not based on whether they can currently shoot or not
    internal double CalculateTotalReceivingDamage(int x, int y, List<Agent> opponentAgents)
    {
        var stationaryReceivingDamage = 0.0;
        foreach (var opponentAgent in opponentAgents)
        {
            stationaryReceivingDamage += CalculateDamage(
                opponentAgent.Position.X,
                opponentAgent.Position.Y,
                opponentAgent.OptimalRange,
                opponentAgent.SoakingPower,
                x,
                y);
        }

        return stationaryReceivingDamage;
    }

    internal double CalculateHighestReceivingDamage(int x, int y, List<Agent> opponentAgents)
    {
        var highestDamage = 0.0;
        foreach (var opponentAgent in opponentAgents)
        {
            var damage = CalculateDamage(
                opponentAgent.Position.X,
                opponentAgent.Position.Y,
                opponentAgent.OptimalRange,
                opponentAgent.SoakingPower,
                x,
                y);

            if (damage > highestDamage)
            {
                highestDamage = damage;
            }
        }

        return highestDamage;
    }

    internal double CalculateDamage(int fromX, int fromY, int optimalRange, int soakingPower, int targetX, int targetY)
    {
        double[,] map = _coverMapGenerator.CreateCoverMap(targetX, targetY);

        var damageMultiplier = map[fromX, fromY];
        var baseDamage = soakingPower * damageMultiplier;

        int manhattanDistance = CalculationUtil.GetManhattanDistance(
            new Point(targetX, targetY), new Point(fromX, fromY));

        if (manhattanDistance <= optimalRange)
        {
            return baseDamage;
        }
        else if (manhattanDistance <= optimalRange * 2)
        {
            return baseDamage / 2;
        }
        else
        {
            return 0;
        }
    }


}


internal class DamageMapGenerator
{
    const double SPLASH_CUTOFF = 30.0; // Minimum splash damage to consider
    private int width;
    private int height;

    public DamageMapGenerator(int width, int height)
    {
        this.width = width;
        this.height = height;
    }

    internal double[,] CreateDamageMap(Agent agent,
                                       List<Agent> opponentAgents, 
                                       int[,] splashMap, 
                                       Dictionary<int, double[,]> coverMaps,
                                       int[,] cover)
    {
        double[,] damageMap = new double[width, height];

        int maxRange = agent.OptimalRange * 2;

        for (int x = 0; x < width; x++)
        {
            for (int y = 0; y < height; y++)
            {
                if (cover[x, y] > 0)
                {
                    // If there is cover on this spot we can't shoot from here
                    damageMap[x, y] = 0.0;
                    continue;
                }

                var maxDamage = 0.0;

                if (agent.SplashBombs > 0)
                {
                    maxDamage = GetBestBombThrow(x, y, splashMap);
                }

                // Only check for max shoot damage if we haven't already added bomb damage
                if (maxDamage <= 0.0) 
                { 
                    foreach (var opponentAgent in opponentAgents)
                    {
                        // Check if it's within max range
                        if (CalculationUtil.GetManhattanDistance(opponentAgent.Position, new Point(x, y)) <= maxRange)
                        {
                            double damage = agent.SoakingPower / 2;

                            if (CalculationUtil.GetManhattanDistance(opponentAgent.Position, new Point(x, y)) <= agent.OptimalRange)
                            {
                                damage = agent.SoakingPower;
                            }

                            // Deduct points for cover
                            double[,]? opponentCoverMap = coverMaps.GetValueOrDefault(opponentAgent.Id);

                            if (opponentCoverMap == null)
                            {
                                Console.Error.WriteLine($"ERROR: No cover map found for agent {opponentAgent.Id}");
                            }
                            else
                            {
                                var coverValue = opponentCoverMap[x, y];
                                if (coverValue < 1.0)
                                {
                                    damage *= coverValue;
                                }
                            }

                            if (damage > maxDamage)
                            {
                                maxDamage = damage;
                            }
                        }
                    }
                }

                damageMap[x, y] = maxDamage;
            }
        }

        return damageMap;
    }

    private double GetBestBombThrow(int x, int y, int[,] splashMap)
    {
        var maxDamage = 0.0;
        // Get the highest value in splashMap within 4 manhattan distance of x, y
        for (int dx = -4; dx <= 4; dx++)
        {
            for (int dy = -4; dy <= 4; dy++)
            {
                int splashX = x + dx;
                int splashY = y + dy;

                if (splashX >= 0 && splashX < width && splashY >= 0 && splashY < height)
                {
                    if (CalculationUtil.GetManhattanDistance(new Point(splashX, splashY), new Point(x, y)) <= 4)
                    {
                        double splashValue = splashMap[splashX, splashY];
                        if (splashValue > maxDamage && splashValue >= SPLASH_CUTOFF)
                        {
                            maxDamage = splashValue;
                        }
                    }
                }
            }
        }

        return maxDamage;
    }
}

internal static class Display
{
    internal static void Map(double[,] map)
    {
        for (int y = 0; y < map.GetLength(1); y++)
        {
            for (int x = 0; x < map.GetLength(0); x++)
            {
                Console.Error.Write($"{map[x, y]:F2} ");
            }
            Console.Error.WriteLine();
        }
    }

    internal static void Map(int[,] map)
    {
        for (int y = 0; y < map.GetLength(1); y++)
        {
            for (int x = 0; x < map.GetLength(0); x++)
            {
                Console.Error.Write($"{map[x, y]} ");
            }
            Console.Error.WriteLine();
        }
    }

    internal static void Sources(List<Agent> agents)
    {
        Console.Error.WriteLine("Move sources");

        foreach (Agent agent in agents)
        {
            Console.Error.WriteLine($"Agent {agent.Id} - Move: {agent.MoveIntention.Source} - Action:{agent.ActionIntention.Source}");
        }
    }
}

partial class Game
{
    public int Width { get; private set; }
    public int Height { get; private set; }

    public int MyId { get; private set; }

    List<Agent> _playerAgents = new List<Agent>();
    List<Agent> _opponentAgents = new List<Agent>();

    int[,] _cover;

    private int[,] _splashMap;
    Dictionary<int, double[,]> _coverMaps;


    private CoverMapGenerator _coverMapGenerator;
    private DamageMapGenerator _damageMapGenerator;
    private DamageCalculator _damageCalculator;
    private ScoreCalculator _scoreCalculator;

    AStar _aStar;

    private int _moveCount;

    private int _playerScore, _opponentScore = 0;

    private bool _inOpening = true;
    private bool _inEndGame = false;

    public Game(int myId)
    {
        MyId = myId;
    }

    // One line per agent: <agentId>;<action1;action2;...> actions are "MOVE x y | SHOOT id | THROW x y | HUNKER_DOWN | MESSAGE text"
    internal List<string> GetCommands()
    {
        UpdateScores();
        Console.Error.WriteLine($"Player score: {_playerScore}, Opponent score: {_opponentScore}");

        _splashMap = CreateSplashMap();
        _coverMaps = CreateCoverMaps();

        _damageCalculator = new DamageCalculator(_coverMapGenerator);

        UpdatePriorities();

        Dictionary<int, Point> landGrabAssignments = GetBestLandGrabPositions();

        GetMoveCommands(landGrabAssignments);

        GetActionCommands();
        
        Display.Sources(_playerAgents);

        List<string> commands = GetCommandStrings();
        ResetIntentions();

        _moveCount++;

        return commands;
    }

    private Dictionary<int, Point> GetBestLandGrabPositions()
    {
        // count of agents who have InitialLandGrab as their priority
        int initialLandGrabCount = _playerAgents.Count(a => a.AgentPriority == Priority.LandGrab);

        List <Point> landGrabPositions = new List<Point>();

        for (int i = 0; i < initialLandGrabCount; i++)
        {
            var bestPoint = new Point(-1, -1);
            var highestDistance = int.MinValue;

            // for each point on the map
            for (int x = 0; x < Width; x++)
            {
                for (int y = 0; y < Height; y++)
                {
                    if (landGrabPositions.Contains(new Point(x, y)))
                    {
                        continue; // Skip if this point is already in landGrabPositions
                    }

                    (_, var closestEnemyPosition) = GetClosestEnemyPosition(new Point(x, y));

                    // Get the closest player agent distance, excluding any that have priority as InitialLandGrab
                    var closestPlayerAgent = _playerAgents
                        .Where(a => a.AgentPriority != Priority.LandGrab)
                        .Select(a => CalculationUtil.GetManhattanDistance(a.Position, new Point(x, y)))
                        .DefaultIfEmpty(int.MaxValue)
                        .Min();

                    // Get the distance to the closest point in landGrabPositions
                    var closestLandGrabPosition = landGrabPositions
                        .Select(p => CalculationUtil.GetManhattanDistance(p, new Point(x, y)))
                        .DefaultIfEmpty(int.MaxValue)
                        .Min();

                    // Get the distance to the closet Edge of the 4 edges of the map
                    int closestEdge = Math.Min(Math.Min(x, Width - 1 - x), Math.Min(y, Height - 1 - y));


                    var closest = Math.Min(closestEnemyPosition, closestPlayerAgent);
                    closest = Math.Min(closest, closestLandGrabPosition);
                    closest = Math.Min(closest, closestEdge);

                    if (closest > highestDistance)
                    {
                        highestDistance = closest;
                        bestPoint = new Point(x, y);
                    }
                }
            }

            if (bestPoint != new Point(-1, -1))
            {
                landGrabPositions.Add(bestPoint);
                Console.Error.WriteLine($"Land grab position {i + 1}: {bestPoint.X}, {bestPoint.Y} with distance {highestDistance}");
            }
        }

        Dictionary<int, Point> landGrabAssignments = new Dictionary<int, Point>();
        List<int> assignedAgents = new List<int>();
        for (int i = 0; i < landGrabPositions.Count; i++)
        {
            // get the closest agent that isn't already assigned
            var closestAgent = _playerAgents
                .Where(a => !assignedAgents.Contains(a.Id) && a.AgentPriority == Priority.LandGrab)
                .OrderBy(a => CalculationUtil.GetManhattanDistance(a.Position, landGrabPositions[i]))
                .FirstOrDefault();

            if (closestAgent == null)
            {
                Console.Error.WriteLine($"ERROR: Couldn't find agent for land grab position {landGrabPositions[i].X},{landGrabPositions[i].Y}");
            }
            else
            {
                landGrabAssignments.Add(closestAgent.Id, landGrabPositions[i]);
                assignedAgents.Add(closestAgent.Id);
            }
        }


        return landGrabAssignments;
    }

    private void UpdateScores()
    {
        (int player, int opponent) = _scoreCalculator.CalculateScores(_playerAgents, _opponentAgents);

        if (player > opponent)
        {
            _playerScore += (player - opponent);
        }
        else if (player < opponent)
        {
            _opponentScore += (opponent - player);
        }
    }

    private void ResetIntentions()
    {
        foreach (var agent in _playerAgents)
        {
            agent.ResetIntentions();
        }
    }

    private List<string> GetCommandStrings()
    {
        List<string> commands = new List<string>();

        foreach (var agent in _playerAgents)
        {
            string command = $"{agent.Id}; MOVE {agent.MoveIntention.Move.X} {agent.MoveIntention.Move.Y}; {agent.ActionIntention.Command} MESSAGE {agent.AgentPriority}";
            commands.Add(command);
        }

        return commands;
    }

    private int[,] CreateSplashMap()
    {
        SplashMapGenerator splashMapGenerator = new SplashMapGenerator(Width, Height, _playerAgents, _opponentAgents);
        return splashMapGenerator.CreateSplashMap();
    }

    private Dictionary<int, double[,]> CreateCoverMaps()
    {
        var coverMaps = new Dictionary<int, double[,]>();

        foreach (var agent in _playerAgents)
        {
            coverMaps[agent.Id] = _coverMapGenerator.CreateCoverMap(agent.Position.X, agent.Position.Y);
        }
        foreach (var agent in _opponentAgents)
        {
            coverMaps[agent.Id] = _coverMapGenerator.CreateCoverMap(agent.Position.X, agent.Position.Y);
        }

        return coverMaps;
    }

    private void UpdatePriorities()
    {
        foreach (var agent in _playerAgents)
        {
            // Once any player comes out of the opening all players are out of it
            if (_inOpening)
            {
                if (isOpponentSplashBombInRange(6, agent.Position))
                {
                    _inOpening = false;
                }
                else
                {
                    // Currently don't do anything
                    // agent.AgentPriority = Priority.LandGrab;
                    // continue;
                }
            }

            if (!_inEndGame)
            {
                // If there are no more splashbombs 
                if (_opponentAgents.All(a => a.SplashBombs == 0) 
                    && _playerAgents.All(a => a.SplashBombs == 0))
                {
                    _inEndGame = true;
                }
            }
            
            if (_inEndGame)
            {
                // Currently don't do anything
                //agent.AgentPriority = Priority.MaximiseScore;
                //continue;
            }

            (_, var closestEnemyDistance) = GetClosestEnemyPosition(agent);
            (_, var closestBomberDistance) = GetClosestEnemyWithSplashBombsPosition(agent);

            if (closestBomberDistance <= 8)
            {
                agent.AgentPriority = Priority.DodgingBombs;
            }
            //if (isOpponentSplashBombInRange(6, agent.Position)
            //    && _playerAgents.Any(a => a.Id != agent.Id 
            //                         && CalculationUtil.GetEuclideanDistance(a.Position, agent.Position) < 3))
            //{
            //    Console.Error.WriteLine($"Agent {agent.Id} closest enemy distance: {closestEnemyDistance}");
                
            //    agent.AgentPriority = Priority.SpreadingOut;
            //}
            else if (closestEnemyDistance <= agent.OptimalRange)
            {
                agent.AgentPriority = Priority.FindingBestAttackPosition;
            }
            else if (closestEnemyDistance > agent.OptimalRange * 2 || agent.AgentPriority != Priority.FindingBestAttackPosition)
            {
                agent.AgentPriority = Priority.Advancing;
            }
        }
    }

    private bool isOpponentSplashBombInRange(int range, Point position)
    {
        foreach (var agent in _opponentAgents)
        {
            if (agent.SplashBombs > 0
                && CalculationUtil.GetManhattanDistance(agent.Position, position) <= range)
            {
                return true;
            }
        }

        return false;
    }

    private void GetMoveCommands(Dictionary<int, Point> landGrabAssignments)
    {
        List<Move> currentMovePoints = new List<Move>();

        foreach (var agent in _playerAgents)
        {
            // If enemy has a higher score this round maximise score
            (var player, var opponent) = _scoreCalculator.CalculateScores(_playerAgents, _opponentAgents);

            if (player - opponent < -40)
            {
                Console.Error.WriteLine($"Agent {agent.Id} prioritising score maximisation due to negative score difference: {player - opponent}");
                GetScoreMaximisingMove(agent);
            }

            // If opponent still has any splashbombs, spread out any agents that are close to each other
            if (agent.AgentPriority == Priority.SpreadingOut)
            {
                GetSpreadMove(agent);
            }

            if (agent.AgentPriority == Priority.DodgingBombs)
            {
                GetBombDodgeMove(agent);
            }

            if (player - opponent < -20)
            {
                Console.Error.WriteLine($"Agent {agent.Id} prioritising score maximisation due to negative score difference: {player - opponent}");
                GetScoreMaximisingMove(agent);
            }

            if ((agent.AgentPriority == Priority.FindingBestAttackPosition && agent.OptimalRange > 2)
                || (agent.AgentPriority == Priority.SpreadingOut))
            {               
                GetBestAttackPosition(agent);
            }

            // Default to advancing to Enemy

            // If we still don't have a move, look for a score maximising move
            GetScoreMaximisingMove(agent);
                
            // If we still don't have a move, get the best advancing move
            GetBestAdvancingMove(agent);
                
            UpdateForCollisions(agent, currentMovePoints);

            currentMovePoints.Add(new Move(agent.Position, agent.MoveIntention.Move));
        }
    }

    private void GetScoreMaximisingMove(Agent agent)
    {
        if (agent.MoveIntention.Move != new Point(-1, -1))
        {
            // If we already have a move, return
            return;
        }

        int maxScoreDiff = _scoreCalculator.CalculateScoreDiff(_playerAgents, _opponentAgents);

        Point[] pointsToCheck = new Point[4];
        pointsToCheck[0] = new Point(Math.Min(Width - 1, agent.Position.X + 1), agent.Position.Y);
        pointsToCheck[1] = new Point(Math.Max(0, agent.Position.X - 1), agent.Position.Y);
        pointsToCheck[2] = new Point(agent.Position.X, Math.Min(Height - 1, agent.Position.Y + 1));
        pointsToCheck[3] = new Point(agent.Position.X, Math.Max(0, agent.Position.Y - 1));

        foreach (Point point in pointsToCheck)
        {
            // If there is cover at this point , skip it
            if (_cover[point.X, point.Y] > 0)
            {
                continue;
            }

            (var player, var opponent) = _scoreCalculator.CalculateScores(_playerAgents, new Dictionary<int, Point> { { agent.Id, point } }, _opponentAgents);

            int scoreDiff = player - opponent;

            if (scoreDiff > maxScoreDiff)
            {
                maxScoreDiff = scoreDiff;
                agent.MoveIntention.Move = point;
                agent.MoveIntention.Source = "Maximising score";
            }
        }
    }

    private void GetBombDodgeMove(Agent agent)
    {
        if (agent.MoveIntention.Move != new Point(-1, -1))
        {
            // If we already have a move, return
            return;
        }

        (var enemyPosition, var enemyDistance) = GetClosestEnemyWithSplashBombsPosition(agent);

        if (enemyPosition == new Point(-1, -1))
        {
            // No enemies with splash bombs in range
            return;
        }

        // For now, just assume x-axis is more important than y-axis
        // If it turns out it's not we can worry about it later
        if (agent.Position.Y == enemyPosition.Y)
        {
             if (enemyDistance <= 6)
             {
                // move back
                if (agent.Position.X < enemyPosition.X)
                {
                    agent.MoveIntention.Move = new Point(agent.Position.X - 1, agent.Position.Y);
                }
                else
                {
                    agent.MoveIntention.Move = new Point(agent.Position.X + 1, agent.Position.Y);
                }
            }
            else if (enemyDistance <= 7)
            {
                // stay still
                // agent.MoveIntention.Move = new Point(agent.Position.X, agent.Position.Y);
            }
        }
        else if (Math.Abs(agent.Position.Y - enemyPosition.Y) == 1 || Math.Abs(agent.Position.Y - enemyPosition.Y) == 2)
        {
            if (enemyDistance <= 7)
            {
                // move back
                if (agent.Position.X < enemyPosition.X)
                {
                    agent.MoveIntention.Move = new Point(agent.Position.X - 1, agent.Position.Y);
                }
                else
                {
                    agent.MoveIntention.Move = new Point(agent.Position.X + 1, agent.Position.Y);
                }
            }
            else if (enemyDistance <= 8)
            {
                // stay still
                agent.MoveIntention.Move = new Point(agent.Position.X, agent.Position.Y);
            }
        }

        agent.MoveIntention.Source = "Dodging a bomb";
    }

    private void GetSpreadMove(Agent agent)
    {
        if (agent.MoveIntention.Move != new Point(-1, -1))
        {
            // If we already have a move, return
            return;
        }

        // Get the closest agent to this agent
        var closestAgent = _playerAgents
            .Where(a => a.Id != agent.Id)
            .OrderBy(a => CalculationUtil.GetEuclideanDistance(a.Position, agent.Position))
            .FirstOrDefault();

        if (closestAgent != null)
        {
            agent.MoveIntention.Source = "Spreading";
            if (closestAgent.Position.X < agent.Position.X && agent.Position.X + 1 <= Width - 1)
            {
                agent.MoveIntention.Move = new Point(agent.Position.X + 1, agent.Position.Y);
            }
            else if (closestAgent.Position.X > agent.Position.X && agent.Position.X - 1 >= 0)
            {
                agent.MoveIntention.Move = new Point(agent.Position.X - 1, agent.Position.Y);
            }
            else if (closestAgent.Position.Y > agent.Position.Y && agent.Position.Y - 1 >= 0)
            {
                agent.MoveIntention.Move = new Point(agent.Position.X, agent.Position.Y - 1);
            }
            else if (closestAgent.Position.Y < agent.Position.Y && agent.Position.Y + 1 <= Height - 1)
            {
                agent.MoveIntention.Move = new Point(agent.Position.X, agent.Position.Y + 1);
            }
            else
            {
                // If we can't move in any direction, just stay still
                agent.MoveIntention.Move = agent.Position;
            }
        }
    }

    private void GetBestAttackPosition(Agent agent)
    {
        if (agent.MoveIntention.Move != new Point(-1, -1))
        {
            // If we already have a move, return
            return;
        }

        // Look around the agent by optimal range / 2
        var move = new Point(-1, -1);

        var distanceToCheck = agent.OptimalRange / 2;
        int minX = Math.Max(0, agent.Position.X - distanceToCheck);
        int maxX = Math.Min(Width - 1, agent.Position.X + distanceToCheck);
        int minY = Math.Max(0, agent.Position.Y - distanceToCheck);
        int maxY = Math.Min(Height - 1, agent.Position.Y + distanceToCheck);

        double maxDamageScore = double.MinValue;
        int minDistanceToAgent = int.MaxValue;

        (_, var distanceToEnemy) = GetClosestEnemyPosition(agent);

        // For each point calculate Damage - Potential damage
        for (int x = minX; x <= maxX; x++)
        {
            for (int y = minY; y <= maxY; y++)
            {
                (_, var closestEnemyToPoint) = GetClosestEnemyPosition(new Point(x, y));
                if (closestEnemyToPoint > distanceToEnemy)
                {
                    continue;
                }
                

                // If an enemy agent is already at to this point, skip it
                if (_opponentAgents.Any(enemyAgent => enemyAgent.Position.X == x && enemyAgent.Position.Y == y))
                {
                    continue;
                }

                // If there is cover at this point , skip it
                if (_cover[x, y] > 0)
                {
                    continue;
                }

                // Calculate possible damage
                var attackDamage = _damageCalculator.CalculateHighestAttackingPlayerDamage(agent, x, y, _opponentAgents);

                // Calculate possible damage taken
                var receivingDamage = _damageCalculator.CalculateTotalReceivingDamage(x, y, _opponentAgents);

                // Calculate score
                var score = attackDamage - receivingDamage;
                if (score >= maxDamageScore)
                {
                    var distanceToAgent = CalculationUtil.GetManhattanDistance(agent.Position, new Point(x, y));

                    if (score == maxDamageScore)
                    {
                        // If the score is the same, check if it's closer to the agent
                        if (distanceToAgent < minDistanceToAgent)
                        {
                            maxDamageScore = score;
                            minDistanceToAgent = distanceToAgent;
                            move = new Point(x, y);
                        }
                    }
                    else
                    {
                        maxDamageScore = score;
                        minDistanceToAgent = distanceToAgent;
                        move = new Point(x, y);
                    }
                }
            }
        }

        if (move != new Point(-1, -1))
        {
            Point bestPoint = new Point(move.X, move.Y);

            Console.Error.WriteLine($"Agent {agent.Id} found best attack position: {bestPoint.X}, {bestPoint.Y} with score {maxDamageScore} and distance {minDistanceToAgent}");

            if (agent.Position != move)
            {
                List<Point> bestPath = _aStar.GetShortestPath(agent.Position, move);
                bestPoint = bestPath[0];
            }

            agent.MoveIntention.Move = bestPoint;
            agent.MoveIntention.Source = "Moving to best attack position";

            Console.Error.WriteLine($"Agent {agent.Id} moving to best attack position: {bestPoint.X}, {bestPoint.Y} with score {maxDamageScore} and distance {minDistanceToAgent}");
        }
    }

    private void GetBestAdvancingMove(Agent agent)
    {
        if (agent.MoveIntention.Move != new Point(-1, -1))
        {
            // If we already have a move, return
            return;
        }

        double[,] agentDamageMap = _damageMapGenerator.CreateDamageMap(agent, _opponentAgents, _splashMap, _coverMaps, _cover);

        (Point bestAttackPoint, _) = ClosestPeakFinder.FindClosestPeak(
            agent.Position,
            agentDamageMap);

        Point bestPoint = new Point(bestAttackPoint.X, bestAttackPoint.Y);
        
        if (agent.Position != bestAttackPoint)
        {
            // Convert the move to the next adjacent move so we know exactly where we'll be on the next turn
            List<Point> bestPath = _aStar.GetShortestPath(agent.Position, bestAttackPoint);

            bestPoint = bestPath[0];
        }

        agent.MoveIntention.Move = bestPoint;
        agent.MoveIntention.Source = "Moving to best advancing position";
    }

    private void UpdateForCollisions(Agent agent, List<Move> currentMovePoints)
    {
        // If this point is already being moved to by another agent don't move
        if (currentMovePoints.Any(p => p.To.X == agent.MoveIntention.Move.X && p.To.Y == agent.MoveIntention.Move.Y))
        {
            // Simple first pass implementation. Just don't move, allowing the other one to move instead
            agent.MoveIntention.Move = agent.Position;
        }

        // If another agent is moving onto this agent
        if (currentMovePoints.Any(p => p.To.X == agent.Position.X && p.To.Y == agent.Position.Y))
        {
            Move relevantMove = currentMovePoints.First(p => p.To.X == agent.Position.X && p.To.Y == agent.Position.Y);
            //   If this agent is staying still or this agent is moving onto that agent's block
            if (agent.Position == agent.MoveIntention.Move || agent.MoveIntention.Move == relevantMove.From)
            {
                Point[] pointsToCheck = new Point[4];
                pointsToCheck[0] = new Point(Math.Min(Width - 1, agent.Position.X + 1), agent.Position.Y);
                pointsToCheck[1] = new Point(Math.Max(0, agent.Position.X - 1), agent.Position.Y);
                pointsToCheck[2] = new Point(agent.Position.X, Math.Min(Height - 1, agent.Position.Y + 1));
                pointsToCheck[3] = new Point(agent.Position.X, Math.Max(0, agent.Position.Y - 1));

                foreach (var pointToCheck in pointsToCheck)
                {
                    if (_cover[pointToCheck.X, pointToCheck.Y] == 0
                        && relevantMove.From != new Point(pointToCheck.X, pointToCheck.Y))
                    {
                        agent.MoveIntention.Move = new Point(pointToCheck.X, pointToCheck.Y);
                        agent.MoveIntention.Source = "Avoiding a collision";
                        break;
                    }
                }
            }
        }
    }

    private (Point, int) GetClosestEnemyPosition(Agent agent)
    {
        Point closestEnemyPosition = new Point(-1, -1);
        int closestDistance = int.MaxValue;

        foreach (var enemy in _opponentAgents)
        {
            int distance = CalculationUtil.GetManhattanDistance(agent.Position, enemy.Position);

            if (distance < closestDistance)
            {
                closestDistance = distance;
                closestEnemyPosition = enemy.Position;
            }
        }

        return (closestEnemyPosition, closestDistance);
    }

    private (Point, int) GetClosestEnemyWithSplashBombsPosition(Agent agent)
    {
        Point closestEnemyPosition = new Point(-1, -1);
        int closestDistance = int.MaxValue;

        foreach (var enemy in _opponentAgents)
        {
            if (enemy.SplashBombs <= 0)
            {
                continue; // Skip enemies without splash bombs
            }

            int distance = CalculationUtil.GetManhattanDistance(agent.Position, enemy.Position);

            if (distance < closestDistance)
            {
                closestDistance = distance;
                closestEnemyPosition = enemy.Position;
            }
        }

        return (closestEnemyPosition, closestDistance);
    }

    private (Point, double) GetClosestEuclideanEnemyPosition(Agent agent)
    {
        Point closestEnemyPosition = new Point(-1, -1);
        double closestDistance = double.MaxValue;

        foreach (var enemy in _opponentAgents)
        {
            double distance = CalculationUtil.GetEuclideanDistance(agent.Position, enemy.Position);

            if (distance < closestDistance)
            {
                closestDistance = distance;
                closestEnemyPosition = enemy.Position;
            }
        }

        return (closestEnemyPosition, closestDistance);
    }

    private (Point, int) GetClosestEnemyPosition(Point position)
    {
        Point closestEnemyPosition = new Point(-1, -1);
        int closestDistance = int.MaxValue;

        foreach (var enemy in _opponentAgents)
        {
            int distance = CalculationUtil.GetManhattanDistance(position, enemy.Position);

            if (distance < closestDistance)
            {
                closestDistance = distance;
                closestEnemyPosition = enemy.Position;
            }
        }

        return (closestEnemyPosition, closestDistance);
    }

    private void GetActionCommands()
    {

        foreach (var agent in _playerAgents)
        {
            // Within range of a valid throw 
            if (agent.SplashBombs > 0)
            {
                GetThrowAction(agent);
            }

            if (agent.ActionIntention.Command == "" && agent.ShootCooldown <= 0)
            {
                GetShootAction(agent);
            }

            if (agent.ActionIntention.Command == "")
            {
                agent.ActionIntention.Command = "HUNKER_DOWN;";
                agent.ActionIntention.Source = "Hunkering down";
            }
        }
    }

    private void GetThrowAction(Agent agent)
    {
        Point movePoint = agent.MoveIntention.Move;
        // If the movePoint is more than one away from the agents position don't throw
        if (CalculationUtil.GetManhattanDistance(agent.Position, movePoint) > 1)
        {
            Console.Error.WriteLine($"ERROR: WE SHOULD NEVER BE HITTING THIS BECAUSE OF THE A* PATH FINDING");
            return;
        }

        int bestX = -1;
        int bestY = -1;
        int bestValue = 0;
        int bestValueDistance = int.MaxValue;

        Point calculationPoint = new Point(-1, -1);

        // Get highest score from splashDamageMap within 4 
        // Manhattan distance from agent's position

        int distance = 3;
        int minX = Math.Max(0, movePoint.X - distance);
        int maxX = Math.Min(Width - 1, movePoint.X + distance);
        int minY = Math.Max(0, movePoint.Y - distance);
        int maxY = Math.Min(Height - 1, movePoint.Y + distance);

        for (int x = minX; x <= maxX; x++)
        {
            for (int y = minY; y <= maxY; y++)
            {
                if (CalculationUtil.GetManhattanDistance(movePoint, new Point(x, y)) > 3)
                {
                    continue; // Skip points that are more than 4 away
                }

                bool friendlyFire = false;
                // We don't want to throw a bomb if it would damage a point any of our agents are moving to
                foreach (var playerAgent in _playerAgents)
                {                    
                    if (CalculationUtil.GetEuclideanDistance(playerAgent.MoveIntention.Move, new Point(x, y)) < 2)
                    {
                        friendlyFire = true;
                    }
                }

                if (friendlyFire)
                {
                    continue;
                }

                var manhattanDistance = CalculationUtil.GetManhattanDistance(
                    movePoint, new Point(x, y));

                if (manhattanDistance <= 4 && _splashMap[x, y] >= bestValue)
                {
                    (_, var closestEnemyDistance) =  GetClosestEnemyPosition(new Point(x, y));
                    if (_splashMap[x, y] == bestValue)
                    {
                        if (closestEnemyDistance < bestValueDistance)
                        {
                            bestValue = _splashMap[x, y];
                            bestX = x;
                            bestY = y;
                            bestValueDistance = closestEnemyDistance;
                        }
                    }
                    else
                    {

                        bestValue = _splashMap[x, y];
                        bestX = x;
                        bestY = y;
                        bestValueDistance = closestEnemyDistance;
                    }
                }
            }
        }

        if (bestValue > 0)
        {
            agent.ActionIntention.Source = "Throwing a bomb";
            agent.ActionIntention.Command = $"THROW {bestX} {bestY};";
        }
    }

    private void GetShootAction(Agent agent)
    {
        Point movePoint = agent.MoveIntention.Move;

        // Get target
        var mostDamage = 0.0;
        var mostDamageId = -1;

        var killId = -1;
        var soakId = -1;

        foreach (var enemy in _opponentAgents)
        {
            // If enemy is not in range of agent, skip it
            if (CalculationUtil.GetManhattanDistance(enemy.Position, agent.Position) - 1 > agent.OptimalRange * 2)
            {
                continue;
            }

            var damage = _damageCalculator.CalculateDamage(
                movePoint.X,
                movePoint.Y,
                agent.OptimalRange,
                agent.SoakingPower,
                enemy.Position.X,
                enemy.Position.Y);

            if (enemy.Wetness + damage >= 100 && !isAnyOneKilling())
            {
                killId = enemy.Id;
            }
            else if (enemy.Wetness < 50 && enemy.Wetness + damage >= 50 && !isAnyOneSoaking())
            {
                soakId = enemy.Id;
            }

            if (damage > mostDamage && !isAnyOneKilling())
            {
                mostDamage = damage;
                mostDamageId = enemy.Id;
            }
        }

        if (killId != -1)
        {
            agent.ActionIntention.Command = $"SHOOT {killId};";
            agent.ActionIntention.Source = "Shooting to kill";
            agent.ShootToKillId = killId;
            return;
        }
        else if (soakId != -1)
        {
            agent.ActionIntention.Command = $"SHOOT {soakId};";
            agent.ActionIntention.Source = "Shooting to soak";
            agent.ShootToSoakId = soakId;
            return;
        }


        if (mostDamage <= 0.0)
        {
            return;
        }

        agent.ActionIntention.Command = $"SHOOT {mostDamageId};";
        agent.ActionIntention.Source = "Shooting to damage";
    }

    private bool isAnyOneKilling()
    {
        foreach (var agent in _playerAgents)
        {
            if (agent.ShootToKillId != -1)
            {
                return true;
            }
        }

        return false;
    }

    private bool isAnyOneSoaking()
    {
        foreach (var agent in _playerAgents)
        {
            if (agent.ShootToSoakId != -1)
            {
                return true;
            }
        }

        return false;
    }

    public void SetGameSize(int width, int height)
    {
        Width = width;
        Height = height;

        _cover = new int[Width, Height];
        
        _damageMapGenerator = new DamageMapGenerator(width, height);
        _scoreCalculator = new ScoreCalculator(width, height);
    }

    internal void AddAgent(int id, int player, int shootCooldown, int optimalRange, int soakingPower, int splashBombs)
    {
        if (player == MyId)
        {
            _playerAgents.Add(new Agent(id, player, shootCooldown, optimalRange, soakingPower, splashBombs));
        }
        else
        {
            _opponentAgents.Add(new Agent(id, player, shootCooldown, optimalRange, soakingPower, splashBombs));
        }
    }

    internal void MarkAllAgentsForCulling()
    {
        foreach (var agent in _playerAgents)
        {
            agent.InGame = false;
        }

        foreach (var agent in _opponentAgents)
        {
            agent.InGame = false;
        }
    }

    internal void DestroyMarkedAgents()
    {
        _playerAgents.RemoveAll(agent => !agent.InGame);
        _opponentAgents.RemoveAll(agent => !agent.InGame);
    }

    internal void UpdateAgent(int agentId, int x, int y, int cooldown, int splashBombs, int wetness)
    {
        Agent agent = _playerAgents.FirstOrDefault(a => a.Id == agentId) 
            ?? _opponentAgents.FirstOrDefault(a => a.Id == agentId);

        if (agent != null)
        {
            agent.UpdatePosition(x, y);
            agent.ShootCooldown = cooldown;
            agent.SplashBombs = splashBombs;
            agent.Wetness = wetness;
            agent.InGame = true;
        }
    }

    internal void SetCover(int x, int y, int tileType)
    {
        if (x < 0 || x >= Width || y < 0 || y >= Height)
        {
            Console.Error.WriteLine($"Cover position {x}, {y} out of bounds");
            return;
        }
        _cover[x, y] = tileType;
    }

    internal void UpdateCoverRelatedMaps()
    {
        _coverMapGenerator = new CoverMapGenerator(_cover);
        _aStar = new AStar(_cover);
    }
}


public class Move
{
    public Point From { get; }
    public Point To { get; }

    public Move(Point from, Point to)
    {
        From = from;
        To = to;
    }
}
    



public class MoveIntention
{
    public Point Move { get; set; } = new Point(-1, -1);
    public string Source { get; set; } = "";
}


internal sealed class Node
{
    public Point Position { get; set; }

    public Point Parent { get; set; }

    public int G { get; set; }
    public int H { get; set; }
    public int F { get; set; }

    public bool Closed { get; set; }

    public Node(Point position)
    {
        Position = position;
    }
}


class Player
{
    static void Main(string[] args)
    {
        string[] inputs;
        int myId = int.Parse(Console.ReadLine()); // Your player id (0 or 1)
        int agentDataCount = int.Parse(Console.ReadLine()); // Total number of agents in the game

        var game = new Game(myId);

        for (int i = 0; i < agentDataCount; i++)
        {
            inputs = Console.ReadLine().Split(' ');
            int agentId = int.Parse(inputs[0]); // Unique identifier for this agent
            int player = int.Parse(inputs[1]); // Player id of this agent
            int shootCooldown = int.Parse(inputs[2]); // Number of turns between each of this agent's shots
            int optimalRange = int.Parse(inputs[3]); // Maximum manhattan distance for greatest damage output
            int soakingPower = int.Parse(inputs[4]); // Damage output within optimal conditions
            int splashBombs = int.Parse(inputs[5]); // Number of splash bombs this can throw this game

            game.AddAgent(agentId, player, shootCooldown, optimalRange, soakingPower, splashBombs);
        }

        inputs = Console.ReadLine().Split(' ');
        int width = int.Parse(inputs[0]); // Width of the game map
        int height = int.Parse(inputs[1]); // Height of the game map

        game.SetGameSize(width, height);

        for (int i = 0; i < height; i++)
        {
            inputs = Console.ReadLine().Split(' ');
            for (int j = 0; j < width; j++)
            {
                int x = int.Parse(inputs[3 * j]);// X coordinate, 0 is left edge
                int y = int.Parse(inputs[3 * j + 1]);// Y coordinate, 0 is top edge
                int tileType = int.Parse(inputs[3 * j + 2]);

                if (tileType > 0)
                {
                    game.SetCover(x, y, tileType);
                }
            }
        }

        game.UpdateCoverRelatedMaps();

        int count = 1;

        // game loop
        while (true)
        {
            // This is a workaround for a weird bug I found. Hopefully They'll fix it
            if (count > 1)
            {
                Console.ReadLine();
            }

            game.MarkAllAgentsForCulling();

            int agentCount = int.Parse(Console.ReadLine()); // Total number of agents still in the game
            
            for (int i = 0; i < agentCount; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                
                int agentId = int.Parse(inputs[0]);
                int x = int.Parse(inputs[1]);
                int y = int.Parse(inputs[2]);
                int cooldown = int.Parse(inputs[3]); // Number of turns before this agent can shoot
                int splashBombs = int.Parse(inputs[4]);
                int wetness = int.Parse(inputs[5]); // Damage (0-100) this agent has taken

                game.UpdateAgent(agentId, x, y, cooldown, splashBombs, wetness);
            }

            game.DestroyMarkedAgents();

            List<string> moves = game.GetCommands();
            foreach (var move in moves)
            {
                Console.WriteLine(move);
            }

            count++;
        }
    }
}


public enum Priority
{
    Advancing,
    FindingBestAttackPosition,
    SpreadingOut,
    LandGrab,
    MaximiseScore,
    DodgingBombs,
}

internal class ScoreCalculator
{
    private int _width;
    private int _height;

    public ScoreCalculator(int width, int height)
    {
        _width = width;
        _height = height;
    }

    internal int CalculateScoreDiff(List<Agent> playerAgents, List<Agent> opponentAgents)
    {
        (var player, var opponent) = CalculateScores(playerAgents, opponentAgents);
        return player - opponent;
    }

    internal (int player, int opponent) CalculateScores(List<Agent> playerAgents, List<Agent> opponentAgents)
    {
        List<(Point, int)> players = playerAgents.Select(a => (a.Position, a.Wetness)).ToList();
        List<(Point, int)> opponents = opponentAgents.Select(a => (a.Position, a.Wetness)).ToList();

        return CalculateScores(players, opponents);
    }

    internal (int player, int opponent) CalculateScores(List<Agent> playerAgents, Dictionary<int, Point> playerChanges, List<Agent> opponentAgents)
    {
        List<(Point, int)> players = new List<(Point, int)>();
        foreach (var agent in playerAgents)
        {
            if (playerChanges.TryGetValue(agent.Id, out var newPosition))
            {
                players.Add((newPosition, agent.Wetness));
            }
            else
            {
                players.Add((agent.Position, agent.Wetness));
            }
        }

        List<(Point, int)> opponents = opponentAgents.Select(a => (a.Position, a.Wetness)).ToList();

        return CalculateScores(players, opponents);
    }

    internal (int player, int opponent) CalculateScores(List<(Point, int)> playerAgents, List<(Point, int)> opponentAgents)
    {
        var player = 0;
        var opponent = 0;

        for (var y = 0; y < _height; y++)
        {
            for (var x = 0; x < _width; x++)
            {
                int closestPlayerDistance = GetClosestAgentDistance(playerAgents, x, y);
                int closestOpponentDistance = GetClosestAgentDistance(opponentAgents, x, y);

                if (closestPlayerDistance < closestOpponentDistance)
                {
                    player++;
                }
                else if (closestPlayerDistance > closestOpponentDistance)
                {
                    opponent++;
                }
            }
        }

        return (player, opponent);
    }

    private int GetClosestAgentDistance(List<(Point, int)> agents, int x, int y)
    {
        var closest = int.MaxValue;
        foreach (var agent in agents)
        {
            var distance = CalculationUtil.GetManhattanDistance(agent.Item1, new Point(x, y));

            if (agent.Item2 >= 50)
            {
                distance *= 2;
            }

            if (distance < closest)
            {
                closest = distance;
            }
        }

        return closest;
    }
}

internal class SplashMapGenerator
{
    private readonly int width;
    private readonly int height;
    private List<Agent> playerAgents;
    private List<Agent> opponentAgents;

    public SplashMapGenerator(int width, int height, List<Agent> playerAgents, List<Agent> opponentAgents)
    {
        this.width = width;
        this.height = height;
        this.playerAgents = playerAgents;
        this.opponentAgents = opponentAgents;
    }

    internal int[,] CreateSplashMap()
    {
        int[,] splashMap = new int[width, height];

        for (int x = 0; x < width; x++)
        {
            for (int y = 0; y < height; y++)
            {
                splashMap[x, y] = CalculateDamage(x, y);
            }
        }

        return splashMap;
    }

    private int CalculateDamage(int x, int y)
    {
        var damage = 0;

        var minX = Math.Max(0, x - 1);
        var maxX = Math.Min(width - 1, x + 1);
        var minY = Math.Max(0, y - 1);
        var maxY = Math.Min(height - 1, y + 1);

        for (int i = minX; i <= maxX; i++)
        {
            for (int j = minY; j <= maxY; j++)
            {
                foreach (var agent in playerAgents)
                {
                    if (agent.Position.X == i && agent.Position.Y == j)
                    {
                        // If we hit our own agent we want to return no damage
                        return -1;
                    }
                }

                foreach (var enemy in opponentAgents)
                {
                    if (enemy.Position.X == i && enemy.Position.Y == j)
                    {
                        damage += 30;
                    }
                }
            }
        }

        return damage;
    }
}

