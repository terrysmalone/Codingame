/**************************************************************
  This file was generated by FileConcatenator.
  It combined all classes in the project to work in Codingame.
***************************************************************/

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

internal class Cell
{
    internal int Index { get; private set; }
    internal int[] NeighbourIds { get; private set; }
    internal CellType CellType { get; private set; }
    internal int EggCount { get; set; }
    internal int CrystalCount { get; set; }

    internal int playerAntsCount { get; set; } = 0;
    internal int opponentAntsCount { get; set; } = 0;

    internal Cell(int index, int[] neighbourIds, CellType cellType, int eggCount, int crystalCount)
    {
        Index = index;
        NeighbourIds = neighbourIds;
        CellType = cellType;
        EggCount = eggCount;
        CrystalCount = crystalCount;
    }
}


internal enum CellType
{
    Empty = 0,
    Egg = 1,
    Crystal = 2
}


internal static class Display
{
    internal static void Path(string message, List<int> path)
    {
        if (path.Count == 0)
        {
            return;
        }

        Console.Error.WriteLine(message);
        Console.Error.WriteLine($"Path to {path[path.Count - 1]}: {string.Join("->", path)}");
    }

    internal static void Paths(string message, List<List<int>> paths)
    {
        Console.Error.WriteLine(message);
        foreach (var path in paths)
        {
            if (path.Count == 0)
            {
                continue;
            }

            Console.Error.WriteLine($"Path to {path[path.Count-1]}: {string.Join("->", path)}");
        }
    }
}




internal class Game
{
    private readonly int _numberOfCells;

    private List<int> _playerBases = new List<int>();
    private List<int> _opponentBases = new List<int>();

    private Dictionary<int, Cell> _cells = new Dictionary<int, Cell>();

    private PathFinder _pathFinder;

    // Keep track of cell counts at the start of every loop for fast search
    private Dictionary<int, int> _eggCells = new Dictionary<int, int>();
    private Dictionary<int, int> _crystalCells = new Dictionary<int, int>();


    private int _totalEggCount = 0;
    private int _totalCrystalCount = 0;

    private int _playerAntCount = 0;
    private int _opponentAntCount = 0;

    public Game(int numberOfCells)
    {
        this._numberOfCells = numberOfCells;
        _pathFinder = new PathFinder(_cells);
    }

    internal void AddCell(int index, Cell cell)
    {
        _cells.Add(index, cell);
    }

    internal void AddPlayerBase(int myBaseIndex)
    {
        _playerBases.Add(myBaseIndex);
    }

    internal void AddOpponentBase(int oppBaseIndex)
    {
        _opponentBases.Add(oppBaseIndex);
    }

    internal void UpdateCell(int i, int resources, int myAnts, int oppAnts)
    {
        if (_cells.ContainsKey(i))
        {
            var cell = _cells[i];

            if (cell.CellType == CellType.Egg)
            {
                cell.EggCount = resources;
                if (resources > 0)
                {
                    _eggCells.Add(i, resources);
                    _totalEggCount += resources;
                }
            }
            else if (cell.CellType == CellType.Crystal)
            {
                cell.CrystalCount = resources;
                if (resources > 0)
                {
                    _crystalCells.Add(i, resources);
                    _totalCrystalCount += resources;
                }
            }

            cell.playerAntsCount = myAnts;
            cell.opponentAntsCount = oppAnts;
        }
        else
        {
            Console.Error.WriteLine($"ERROR: Cell {i} not found");
        }
    }

    internal void ResetCounts()
    {
        _eggCells.Clear();
        _crystalCells.Clear();

        _playerAntCount = 0;
        _opponentAntCount = 0;
        _totalEggCount = 0;
        _totalCrystalCount = 0;
    }

    internal List<string> GetActions()
    {
        var eggPathLimit = 5;
        var crystalPathLimit = 5;

        var actions = new List<string>();

        // For each base reserve half for collecting crystals and half ants for collecting eggs
        var currentEggSeekingAnts = _playerAntCount / 2;
        var currentCrystalSeekingAnts = _playerAntCount - currentEggSeekingAnts;

        var antsPerBase = _playerAntCount / _playerBases.Count;

        var targetedCells = new Dictionary<int, int>();

        foreach (int playerBase in _playerBases)
        {
            var startPoints = new List<int> { playerBase };

            var availableAnts = antsPerBase;

            var availableEggAnts = availableAnts / 2;            
            Dictionary<int, int> targetedEggCells = CalculateCellTargets(startPoints, _eggCells, availableEggAnts, eggPathLimit);

            var availableCrystalAnts = availableAnts - targetedEggCells.Count; // TODO: We need to count actual amounts here
            Dictionary<int, int> targetedCrystalCells = CalculateCellTargets(startPoints, _crystalCells, availableCrystalAnts, crystalPathLimit);

            AddToTargetedCells(targetedCells, targetedEggCells);
            AddToTargetedCells(targetedCells, targetedCrystalCells);
        }

        actions = GetBeaconActions(targetedCells);

        return actions;
    }

    private Dictionary<int, int> CalculateCellTargets(List<int> startPoints, Dictionary<int, int> resourceCells, int availableResourceAnts, int resourcePathLimit)
    {
        var resourcePathCount = 0;

        var targetedResourceCells = new Dictionary<int, int>();

        // Get resource paths
        var targetedResource = new List<int>();
        var targetedResourceCount = 0;
        while (availableResourceAnts > targetedResourceCount && resourcePathCount <= resourcePathLimit)
        {
            var targetAmount = 1;

            List<List<int>> pathsToResources = _pathFinder.GetShortestPaths(startPoints, resourceCells, targetedResource);

            List<int> shortestResourcePath = GetShortestPath(pathsToResources);

            if (shortestResourcePath.Count == 0)
            {
                break; // No path found, stop looking
            }

            startPoints.Add(shortestResourcePath[shortestResourcePath.Count - 1]);
            targetedResource.Add(shortestResourcePath[shortestResourcePath.Count - 1]);

            foreach (var cell in shortestResourcePath)
            {
                if (targetedResourceCells.ContainsKey(cell))
                {
                    // If the cell is already targeted check if we're now targeting it for more
                    if (targetedResourceCells[cell] < targetAmount)
                    {
                        var increaseAmount = targetAmount - targetedResourceCells[cell];
                        targetedResourceCells[cell] = targetAmount;
                        targetedResourceCount += increaseAmount;
                    }
                }
                else
                {
                    targetedResourceCells.Add(cell, targetAmount);
                    targetedResourceCount += targetAmount;
                }
            }

            resourcePathCount++;
        }

        return targetedResourceCells;
    }

    private static List<int> GetShortestPath(List<List<int>> paths)
    {
        if (paths.Count == 0)
        {
            return new List<int>();
        }
        // Find the shortest path
        List<int> shortestPath = paths[0];
        foreach (var path in paths)
        {
            if (path.Count < shortestPath.Count)
            {
                shortestPath = path;
            }
        }
        return shortestPath;
    }

    private static void AddToTargetedCells(Dictionary<int, int> targetedCells, Dictionary<int, int> targetedResourceCells)
    {
        foreach (var cell in targetedResourceCells)
        {
            if (targetedCells.ContainsKey(cell.Key))
            {
                // If the cell is already targeted check if we're now targeting it for more
                if (targetedCells[cell.Key] < cell.Value)
                {
                    targetedCells[cell.Key] = cell.Value;
                }
            }
            else
            {
                targetedCells.Add(cell.Key, cell.Value);
            }
        }
    }

    private static List<string> GetBeaconActions(Dictionary<int, int> targetedCells)
    {
        var actions = new List<string>();

        foreach (KeyValuePair<int, int> targetedCell in targetedCells)
        {
            actions.Add($"BEACON {targetedCell.Key} {targetedCell.Value}");
        }

        return actions;
    }    

    internal void IncreasePlayerAntCount(int count)
    {
        _playerAntCount += count;
    }

    internal void IncreaseOpponentAntCount(int count)
    {
        _opponentAntCount += count;
    }
}





internal class PathFinder
{
    private readonly Dictionary<int, Cell> _cells;    

    public PathFinder(Dictionary<int, Cell> cells)
    {
        _cells = cells;
    }

    internal List<List<int>> GetShortestPaths(List<int> startCells, Dictionary<int, int> targetCells)
    {
        return GetShortestPaths(startCells, targetCells, new List<int>());
    }

    internal List<List<int>> GetShortestPaths(List<int> startCells, Dictionary<int, int> targetCells, List<int> targetCellsToExclude)
    {
        var paths = new List<List<int>>();

        foreach (int startCell in startCells)
        {
            foreach (var targetCell in targetCells)
            {
                if (startCell == targetCell.Key)
                {
                    continue; // Skip if start and target are the same
                }

                if (targetCellsToExclude.Contains(targetCell.Key))
                {
                    continue; // Skip excluded target cells
                }

                List<int> path = FindShortestPath(startCell, targetCell.Key);
                if (path.Count > 0)
                {
                    paths.Add(path);
                }
            }
        }

        return paths;
    }

    internal List<int> FindShortestPath(int start, int target)
    {
        var path = new List<int>();
        var visited = new HashSet<int>();
        var parent = new Dictionary<int, int>();

        var queue = new Queue<int>();
        queue.Enqueue(start);
        visited.Add(start);
        
        while (queue.Count > 0)
        {
            var current = queue.Dequeue();
            if (current == target)
            {
                while (current != start)
                {
                    path.Add(current);
                    current = parent[current];
                }

                path.Add(start);
                path.Reverse();

                return path;
            }
            if (_cells.ContainsKey(current))
            {
                foreach (var neighbourId in _cells[current].NeighbourIds)
                {
                    if (!visited.Contains(neighbourId))
                    {
                        visited.Add(neighbourId);
                        queue.Enqueue(neighbourId);
                        parent[neighbourId] = current;
                    }
                }
            }
        }

        Console.Error.WriteLine($"ERROR: No path found from {start} to {target}");
        return new List<int>();
    }
}





class Player
{
    static void Main(string[] args)
    {
        string[] inputs;
        int numberOfCells = int.Parse(Console.ReadLine()); // amount of hexagonal cells in this map
                
        Game game = new Game(numberOfCells);

        for (int i = 0; i < numberOfCells; i++)
        {
            inputs = Console.ReadLine().Split(' ');
            int type = int.Parse(inputs[0]); // 0 for empty, 1 for eggs, 2 for crystal
            int initialResources = int.Parse(inputs[1]); // the initial amount of eggs/crystals on this cell
            int neigh0 = int.Parse(inputs[2]); // the index of the neighbouring cell for each direction
            int neigh1 = int.Parse(inputs[3]);
            int neigh2 = int.Parse(inputs[4]);
            int neigh3 = int.Parse(inputs[5]);
            int neigh4 = int.Parse(inputs[6]);
            int neigh5 = int.Parse(inputs[7]);

            int[] neighbourIds = new int[] { neigh0, neigh1, neigh2, neigh3, neigh4, neigh5 };

            var cellType = (CellType)type;

            var eggCount = 0;
            var crystalCount = 0;

            if (cellType == CellType.Egg)
            {
                eggCount = initialResources;
            }
            else if (cellType == CellType.Crystal)
            {
                crystalCount = initialResources;
            }

            var cell = new Cell(i, neighbourIds, cellType, eggCount, crystalCount);

            game.AddCell(i, cell);

        }

        int numberOfBases = int.Parse(Console.ReadLine());
        inputs = Console.ReadLine().Split(' ');
        for (int i = 0; i < numberOfBases; i++)
        {
            int myBaseIndex = int.Parse(inputs[i]);
            game.AddPlayerBase(myBaseIndex);
        }
        inputs = Console.ReadLine().Split(' ');
        for (int i = 0; i < numberOfBases; i++)
        {
            int oppBaseIndex = int.Parse(inputs[i]);
            game.AddOpponentBase(oppBaseIndex);
        }

        // game loop
        while (true)
        {
            Console.Error.WriteLine(Console.ReadLine());

            game.ResetCounts();

            for (int i = 0; i < numberOfCells; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                int resources = int.Parse(inputs[0]); // the current amount of eggs/crystals on this cell
                int myAnts = int.Parse(inputs[1]); // the amount of your ants on this cell
                int oppAnts = int.Parse(inputs[2]); // the amount of opponent ants on this cell

                game.UpdateCell(i, resources, myAnts, oppAnts);
                game.IncreasePlayerAntCount(myAnts);
                game.IncreaseOpponentAntCount(oppAnts);
            }

            List<string> actions = game.GetActions();

            // Write an action using Console.WriteLine()
            // To debug: Console.Error.WriteLine("Debug messages...");


            // WAIT | LINE <sourceIdx> <targetIdx> <strength> | BEACON <cellIdx> <strength> | MESSAGE <text>
            var actionList = String.Join("; ", actions);
            Console.WriteLine(actionList);
        }
    }
}

