/**************************************************************
  This file was generated by FileConcatenator.
  It combined all classes in the project to work in Codingame.
***************************************************************/

using System.Drawing;
using System.Runtime.CompilerServices;
using System.Net.WebSockets;
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;

class Agent
{
    public int Id { get; private set; }
    public int Player { get; private set; }
    public int ShootCooldown { get; set; }
    public int OptimalRange { get; private set; }
    public int SoakingPower { get; private set; }
    public int SplashBombs { get; set; }

    public int Wetness { get; set; }

    public Point Position { get; private set; } = new Point(-1, -1);

    public bool InGame { get; set; } = false;

    public Agent(int id, int player, int shootCooldown, int optimalRange, int soakingPower, int splashBombs)
    {
        Id = id;
        Player = player;
        ShootCooldown = shootCooldown;
        OptimalRange = optimalRange;
        SoakingPower = soakingPower;
        SplashBombs = splashBombs;
    }

    internal void UpdatePosition(int x, int y)
    {
        Position = new Point(x, y);
    }
}

public class CoverMap
{
    private int width, height;
    public double[,] CreateCoverMap(int xPos, int yPos, int[,] cover)
    {
        width = cover.GetLength(0);
        height = cover.GetLength(1);
        var coverMap = new double[width, height];

        // Populate all elements with 1.0
        for (int i = 0; i < width; i++)
        {
            for (int j = 0; j < height; j++)
            {
                coverMap[i, j] = 1.0;
            }
        }

        // Set the current position to 0.0
        coverMap[xPos, yPos] = 0.0; 

        // Check if north is protected
        if (yPos - 2 >= 0 && cover[xPos, yPos - 1] > 0)
        {
            var fillValue = GetCoverProtectionValue(cover[xPos, yPos - 1]);
                
            // Fill all values to the north
            for (int y = 0; y <= yPos - 2; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    coverMap[x, y] = fillValue;
                }
            }

            // Set adjacent tiles back to 1.0
            if (xPos - 1 >= 0)
            {
                coverMap[xPos - 1, yPos - 2] = 1.0;
            }
            coverMap[xPos, yPos - 2] = 1.0;
            if (xPos + 1 < width)
            {
                coverMap[xPos + 1, yPos - 2] = 1.0;
            }
        }

        // Check if south is protected
        if (yPos + 2 <= height-1 && cover[xPos, yPos + 1] > 0)
        {
            var fillValue = GetCoverProtectionValue(cover[xPos, yPos + 1]);
            // Fill all values to the south
            for (int y = yPos + 2; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    coverMap[x, y] = fillValue;
                }
            }

            // Set adjacent tiles back to 1.0
            if (xPos - 1 >= 0)
            {
                coverMap[xPos - 1, yPos + 2] = 1.0;
            }
            coverMap[xPos, yPos + 2] = 1.0;
            if (xPos + 1 < width)
            {
                coverMap[xPos + 1, yPos + 2] = 1.0;
            }
        }

        // Check if east is protected
        if (xPos + 2 < width && cover[xPos + 1, yPos] > 0)
        {
            var fillValue = GetCoverProtectionValue(cover[xPos + 1, yPos]);
            // Fill all values to the east
            for (int x = xPos + 2; x < width; x++)
            {
                for (int y = 0; y < height; y++)
                {
                    // Don't fill it if it's already covered by large cover
                    if (coverMap[x, y] != 0.25)
                    {
                        coverMap[x, y] = fillValue;
                    }
                }
            }
            // Set adjacent tiles back to 1.0
            if (yPos - 1 >= 0)
            {
                coverMap[xPos + 2, yPos - 1] = 1.0;
            }
            coverMap[xPos + 2, yPos] = 1.0;
            if (yPos + 1 < height)
            {
                coverMap[xPos + 2, yPos + 1] = 1.0;
            }
        }

        // Check if west is protected
        if (xPos - 2 >= 0 && cover[xPos - 1, yPos] > 0)
        {
            var fillValue = GetCoverProtectionValue(cover[xPos - 1, yPos]);
            // Fill all values to the west
            for (int x = 0; x <= xPos - 2; x++)
            {
                for (int y = 0; y < height; y++)
                {
                    // Don't fill it if it's already covered by large cover
                    if (coverMap[x, y] != 0.25)
                    {
                        coverMap[x, y] = fillValue;
                    }
                }
            }
            // Set adjacent tiles back to 1.0
            if (yPos - 1 >= 0)
            {
                coverMap[xPos - 2, yPos - 1] = 1.0;
            }
            coverMap[xPos - 2, yPos] = 1.0;
            if (yPos + 1 < height)
            {
                coverMap[xPos - 2, yPos + 1] = 1.0;
            }
        }

        return coverMap;
    }

    private double GetCoverProtectionValue(int coverType)
    {
        if (coverType == 1)
        {
            return 0.5;
        }
        else if (coverType == 2)
        {
            return 0.25;
        }

        return 1.0;
    }
}

internal static class Display
{
    internal static void CoverMap(double[,] coverMap)
    {
        Console.Error.WriteLine("Cover Map:");
        for (int y = 0; y < coverMap.GetLength(1); y++)
        {
            for (int x = 0; x < coverMap.GetLength(0); x++)
            {
                Console.Error.Write($"{coverMap[x, y]:F2} ");
            }
            Console.Error.WriteLine();
        }
    }

    internal static void SplashMap(int[,] splashMap)
    {
        Console.Error.WriteLine("Splash Map:");
        for (int y = 0; y < splashMap.GetLength(1); y++)
        {
            for (int x = 0; x < splashMap.GetLength(0); x++)
            {
                Console.Error.Write($"{splashMap[x, y]} ");
            }
            Console.Error.WriteLine();
        }
    }
}

class Game
{
    public int Width { get; private set; }
    public int Height { get; private set; }

    public int MyId { get; private set; }

    List<Agent> playerAgents = new List<Agent>();
    List<Agent> opponentAgents = new List<Agent>();

    int[,] cover;

    private CoverMap coverMap;

    public Game(int myId)
    {
        MyId = myId;

        coverMap = new CoverMap();
    }

    public void SetGameSize(int width, int height)
    {
        Width = width;
        Height = height;

        cover = new int[Width, Height];
    }

    internal void AddAgent(int id, int player, int shootCooldown, int optimalRange, int soakingPower, int splashBombs)
    {
        if (player == MyId)
        {
            playerAgents.Add(new Agent(id, player, shootCooldown, optimalRange, soakingPower, splashBombs));
        }
        else
        {
            opponentAgents.Add(new Agent(id, player, shootCooldown, optimalRange, soakingPower, splashBombs));
        }
    }

    internal void MarkAllAgentsForCulling()
    {
        foreach (var agent in playerAgents)
        {
            agent.InGame = false;
        }

        foreach (var agent in opponentAgents)
        {
            agent.InGame = false;
        }
    }

    internal void DestroyMarkedAgents()
    {
        playerAgents.RemoveAll(agent => !agent.InGame);
        opponentAgents.RemoveAll(agent => !agent.InGame);
    }

    internal void UpdateAgent(int agentId, int x, int y, int cooldown, int splashBombs, int wetness)
    {
        Agent agent = playerAgents.FirstOrDefault(a => a.Id == agentId) 
            ?? opponentAgents.FirstOrDefault(a => a.Id == agentId);

        if (agent != null)
        {
            agent.UpdatePosition(x, y);
            agent.ShootCooldown = cooldown;
            agent.SplashBombs = splashBombs;
            agent.Wetness = wetness;
            agent.InGame = true; // Mark it as still in game
        }
    }

    // One line per agent: <agentId>;<action1;action2;...> actions are "MOVE x y | SHOOT id | THROW x y | HUNKER_DOWN | MESSAGE text"
    internal List<string> GetMoves()
    {
        SplashMap splashMap = new SplashMap(Width, Height, playerAgents, opponentAgents);
        int[,] splashDamageMap = splashMap.CreateSplashMap();

        List<string> moves = new List<string>();

        // In a very naive attempt to spread out more have no two agents target
        // the same enemy.
        List<Point> usedMoves = new List<Point>();

        foreach (var agent in playerAgents)
        {
            string move = "";

            // If we can hit with a splash bomb without moving, do that
            if (agent.SplashBombs > 0)
            {
                move = GetBestThrowMove(agent, splashDamageMap);
            }

            if (move== "")
            {
                if (agent.ShootCooldown <= 0)
                {
                    Console.Error.WriteLine($"Agent {agent.Id} can shoot, checking for targets...");
                    move = GetRunAndGunMove(agent);
                }
            }

            if (move == "")
            {
                // If we can't shoot or throw, we need to move
                Point closestEnemyPosition = GetClosestEnemyPosition(agent, usedMoves);
                usedMoves.Add(closestEnemyPosition);
                move = $"{agent.Id}; MOVE {closestEnemyPosition.X} {closestEnemyPosition.Y}; HUNKER_DOWN";
            }

            moves.Add(move);

            // To debug: Console.Error.WriteLine("Debug messages...");
        }

        return moves;
    }

    private Point GetClosestEnemyPosition(Agent agent, List<Point> excludingMoves)
    {
        Point closestEnemyPosition = new Point(-1, -1);
        int closestDistance = int.MaxValue;

        foreach (var enemy in opponentAgents)
        {
            if (excludingMoves.Count < opponentAgents.Count &&
                excludingMoves.Contains(enemy.Position))
            {
                // Skip enemies that are already targeted by another agent
                continue;
            }

            int distance = Math.Abs(agent.Position.X - enemy.Position.X) + Math.Abs(agent.Position.Y - enemy.Position.Y);
            if (distance < closestDistance)
            {
                closestDistance = distance;
                closestEnemyPosition = enemy.Position;
            }
        }

        return closestEnemyPosition;
    }

    private string GetBestThrowMove(Agent agent, int[,] splashDamageMap)
    {
        int bestX = -1;
        int bestY = -1;
        int bestValue = 0;

        // Get highest score from splashDamageMap within 4 
        // Manhattan distance from agent's position
        int minX = Math.Max(0, agent.Position.X - 4);
        int maxX = Math.Min(Width - 1, agent.Position.X + 4);
        int minY = Math.Max(0, agent.Position.Y - 4);
        int maxY = Math.Min(Height - 1, agent.Position.Y + 4);

        for (int x = minX; x <= maxX; x++)
        {
            for (int y = minY; y <= maxY; y++)
            {
                var manhattanDistance = Math.Abs(agent.Position.X - x) + Math.Abs(agent.Position.Y - y);
                if (manhattanDistance <= 4 && splashDamageMap[x, y] > bestValue)
                {
                    bestValue = splashDamageMap[x, y];
                    bestX = x;
                    bestY = y;
                }
            }
        }

        if (bestValue > 0)
        {
            return $"{agent.Id}; THROW {bestX} {bestY}";
        }

        return "";
    }

    private string GetRunAndGunMove(Agent agent)
    {
        Console.Error.WriteLine($"Calculating run and gun move for agent {agent.Id}");
        // get best protection (including current space)
        double stationaryReceivingDamage = CalculateReceivingPlayerDamage(agent.Position.X, agent.Position.Y);

        double northReceivingDamage = CalculateReceivingPlayerDamage(agent.Position.X, agent.Position.Y-1);

        var minReceivingDamage = northReceivingDamage;
        var minReceivingDamagePosition = new Point(agent.Position.X, agent.Position.Y - 1);

        double southReceivingDamage = CalculateReceivingPlayerDamage(agent.Position.X, agent.Position.Y + 1);
        if (southReceivingDamage < minReceivingDamage)
        {
            minReceivingDamage = southReceivingDamage;
            minReceivingDamagePosition = new Point(agent.Position.X, agent.Position.Y + 1);
        }

        double eastReceivingDamage = CalculateReceivingPlayerDamage(agent.Position.X + 1, agent.Position.Y);
        if (eastReceivingDamage < minReceivingDamage)
        {
            minReceivingDamage = eastReceivingDamage;
            minReceivingDamagePosition = new Point(agent.Position.X + 1, agent.Position.Y);
        }

        double westReceivingDamage = CalculateReceivingPlayerDamage(agent.Position.X - 1, agent.Position.Y);
        if (westReceivingDamage < minReceivingDamage)
        {
            minReceivingDamage = westReceivingDamage;
            minReceivingDamagePosition = new Point(agent.Position.X - 1, agent.Position.Y);
        }

        Console.Error.WriteLine($"North damage: {northReceivingDamage}");
        Console.Error.WriteLine($"South damage: {southReceivingDamage}");
        Console.Error.WriteLine($"East damage: {eastReceivingDamage}");
        Console.Error.WriteLine($"West damage: {westReceivingDamage}");
        Console.Error.WriteLine($"Stationary damage: {stationaryReceivingDamage}");

        var attackPoint = new Point(-1, -1);

        if (stationaryReceivingDamage <= minReceivingDamage)
        {
            // Stay in place
            attackPoint = new Point(agent.Position.X, agent.Position.Y);
        }
        else
        {
            // Move to the position with the least damage
            attackPoint = minReceivingDamagePosition;
        }

        // Get target
        var bestAttack = 0.0;
        var bestAttackId = -1;

        foreach (var enemy in opponentAgents)
        {
            var damage = CalculateDamage(
                attackPoint.X,
                attackPoint.Y,
                agent.OptimalRange,
                agent.SoakingPower,
                enemy.Position.X,
                enemy.Position.Y);

            if (damage > bestAttack)
            {
                bestAttack = damage;
                bestAttackId = enemy.Id;
            }
        }

        if (bestAttack <= 0.0)
        {
            Console.Error.WriteLine($"No valid attack found for agent {agent.Id} at position {attackPoint.X}, {attackPoint.Y}");
            // No valid attack found, return empty move
            return "";
        }

        if (stationaryReceivingDamage <= minReceivingDamage)
        {
            return $"{agent.Id}; SHOOT {bestAttackId}";
        }

        return $"{agent.Id}; MOVE {attackPoint.X} {attackPoint.Y}; SHOOT {bestAttackId}";
    }

    private double CalculateReceivingPlayerDamage(int x, int y)
    {
        // Check bounds
        if (x < 0 || x >= Width || y < 0 || y >= Height)
        {
            return Double.MaxValue;
        }

        var stationaryReceivingDamage = 0.0;
        foreach (var enemy in opponentAgents)
        {
            if (enemy.ShootCooldown <= 0)
            {
                stationaryReceivingDamage += CalculateDamage(
                    enemy.Position.X,
                    enemy.Position.Y,
                    enemy.OptimalRange,
                    enemy.SoakingPower,
                    x,
                    y);
            }
        }

        return stationaryReceivingDamage;
    }

    private double CalculateDamage(int fromX, int fromY, int optimalRange, int soakingPower, int targetX, int targetY)
    {
        double[,] map = coverMap.CreateCoverMap(targetX, targetY, cover);
        // Display.CoverMap(map);

        var damageMultiplier = map[fromX, fromY];
        var baseDamage = soakingPower * damageMultiplier;

        int manhattanDistance = Math.Abs(targetX - fromX) + Math.Abs(targetY - fromY);

        Console.Error.WriteLine($"Manhattan Distance from ({fromX}, {fromY}) to ({targetX}, {targetY}): {manhattanDistance}");
        Console.Error.WriteLine($"Base Damage: {baseDamage}, Optimal Range: {optimalRange}, Damage Multiplier: {damageMultiplier}");
        if (manhattanDistance <= optimalRange)
        {
            Console.Error.WriteLine($"Returning {baseDamage} for target at ({targetX}, {targetY})");
            return baseDamage;
        }
        //else if (manhattanDistance <= optimalRange * 2)
        //{
        //    return baseDamage / 2;
        //}
        else
        {
            Console.Error.WriteLine($"Returning 0 for target at ({targetX}, {targetY})");
            return 0;
        }
    }

    private int GetWettestOpponentId()
    {
        int wettestOpponentId = -1;
        int maxWetness = -1;

        foreach (var agent in opponentAgents)
        {
            if (agent.Wetness > maxWetness)
            {
                maxWetness = agent.Wetness;
                wettestOpponentId = agent.Id;
            }
        }

        return wettestOpponentId;
    }

    internal void SetCover(int x, int y, int tileType)
    {
        if (x < 0 || x >= Width || y < 0 || y >= Height)
        {
            Console.Error.WriteLine($"Cover position {x}, {y} out of bounds");
            return;
        }
        cover[x, y] = tileType;
    }
}


class Player
{
 

    static void Main(string[] args)
    {
        string[] inputs;
        int myId = int.Parse(Console.ReadLine()); // Your player id (0 or 1)
        int agentDataCount = int.Parse(Console.ReadLine()); // Total number of agents in the game

        var game = new Game(myId);

        for (int i = 0; i < agentDataCount; i++)
        {
            inputs = Console.ReadLine().Split(' ');
            int agentId = int.Parse(inputs[0]); // Unique identifier for this agent
            int player = int.Parse(inputs[1]); // Player id of this agent
            int shootCooldown = int.Parse(inputs[2]); // Number of turns between each of this agent's shots
            int optimalRange = int.Parse(inputs[3]); // Maximum manhattan distance for greatest damage output
            int soakingPower = int.Parse(inputs[4]); // Damage output within optimal conditions
            int splashBombs = int.Parse(inputs[5]); // Number of splash bombs this can throw this game

            game.AddAgent(agentId, player, shootCooldown, optimalRange, soakingPower, splashBombs);
        }

        inputs = Console.ReadLine().Split(' ');
        int width = int.Parse(inputs[0]); // Width of the game map
        int height = int.Parse(inputs[1]); // Height of the game map

        game.SetGameSize(width, height);

        for (int i = 0; i < height; i++)
        {
            inputs = Console.ReadLine().Split(' ');
            for (int j = 0; j < width; j++)
            {
                int x = int.Parse(inputs[3 * j]);// X coordinate, 0 is left edge
                int y = int.Parse(inputs[3 * j + 1]);// Y coordinate, 0 is top edge
                int tileType = int.Parse(inputs[3 * j + 2]);

                if (tileType > 0)
                {
                    game.SetCover(x, y, tileType);
                }
            }
        }

        int count = 1;

        // game loop
        while (true)
        {
            // This is a workaround for a weird bug I found. Hopefully They'll fix it
            if (count > 1)
            {
                Console.ReadLine();
            }

            game.MarkAllAgentsForCulling();

            int agentCount = int.Parse(Console.ReadLine()); // Total number of agents still in the game
            
            for (int i = 0; i < agentCount; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                
                int agentId = int.Parse(inputs[0]);
                int x = int.Parse(inputs[1]);
                int y = int.Parse(inputs[2]);
                int cooldown = int.Parse(inputs[3]); // Number of turns before this agent can shoot
                int splashBombs = int.Parse(inputs[4]);
                int wetness = int.Parse(inputs[5]); // Damage (0-100) this agent has taken

                game.UpdateAgent(agentId, x, y, cooldown, splashBombs, wetness);
            }

            game.DestroyMarkedAgents();

            List<string> moves = game.GetMoves();
            foreach (var move in moves)
            {
                Console.WriteLine(move);
            }

            count++;
        }
    }
}


internal class SplashMap
{
    private int width;
    private int height;
    private List<Agent> playerAgents;
    private List<Agent> opponentAgents;

    public SplashMap(int width, int height, List<Agent> playerAgents, List<Agent> opponentAgents)
    {
        this.width = width;
        this.height = height;
        this.playerAgents = playerAgents;
        this.opponentAgents = opponentAgents;
    }

    internal int[,] CreateSplashMap()
    {
        int[,] splashMap = new int[width, height];

        for (int x = 0; x < width; x++)
        {
            for (int y = 0; y < height; y++)
            {
                splashMap[x, y] = CalculateDamage(x, y);
            }
        }

        return splashMap;
    }

    private int CalculateDamage(int x, int y)
    {
        var damage = 0;

        var minX = Math.Max(0, x - 1);
        var maxX = Math.Min(width - 1, x + 1);
        var minY = Math.Max(0, y - 1);
        var maxY = Math.Min(height - 1, y + 1);

        for (int i = minX; i <= maxX; i++)
        {
            for (int j = minY; j <= maxY; j++)
            {
                foreach (var agent in playerAgents)
                {
                    if (agent.Position.X == i && agent.Position.Y == j)
                    {
                        // If we hit an agent we want to return no damage
                        return 0;
                    }
                }

                foreach (var enemy in opponentAgents)
                {
                    if (enemy.Position.X == i && enemy.Position.Y == j)
                    {
                        damage += 30;
                    }
                }
            }
        }

        return damage;
    }
}

