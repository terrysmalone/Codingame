/**************************************************************
  This file was generated by FileConcatenator.
  It combined all classes in the project to work in Codingame.
***************************************************************/

using System.Drawing;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Runtime.CompilerServices;
using System.Net.WebSockets;
using System.IO;
using System.Collections;

class Agent
{
    public int Id { get; private set; }
    public int Player { get; private set; }
    public int ShootCooldown { get; set; }
    public int OptimalRange { get; private set; }
    public int SoakingPower { get; private set; }
    public int SplashBombs { get; set; }
    public int Wetness { get; set; }
    public Point Position { get; private set; } = new Point(-1, -1);
    public Priority AgentPriority { get; set; } = Priority.MovingToEnemy;
    public string MoveSource { get; set; } 
    public string ActionSource { get; set; }

    public bool InGame { get; set; } = false;

    public Agent(int id, int player, int shootCooldown, int optimalRange, int soakingPower, int splashBombs)
    {
        Id = id;
        Player = player;
        ShootCooldown = shootCooldown;
        OptimalRange = optimalRange;
        SoakingPower = soakingPower;
        SplashBombs = splashBombs;
    }

    internal void UpdatePosition(int x, int y)
    {
        Position = new Point(x, y);
    }
}

public enum Priority
{
    MovingToEnemy,
    FindingBestAttackPosition,
}

internal sealed class AStar
{
    private readonly int[,] cover;
    private int _width, _height;

    private List<Node> _nodes = new List<Node>();
    
    internal AStar(int[,] cover)
    {
        this.cover = cover;
        _width = cover.GetLength(0);
        _height = cover.GetLength(1);
    }

    internal List<Point> GetShortestPath(Point startPoint, Point targetPoint)
    {
        return GetShortestPath(startPoint, targetPoint, int.MaxValue);
    }

    internal List<Point> GetShortestPath(Point startPoint, Point targetPoint, int maxDistance)
    {
        _nodes = new List<Node>();

        Node currentNode = new Node(startPoint);

        _nodes.Add(currentNode);

        bool targetFound = false;

        int timeToSearch = 0;
        while (!targetFound)
        {
            if (_nodes.Count(n => n.Closed == false) == 0)
            {
                return new List<Point>();
            }

            Point[] pointsToCheck = new Point[4];

            // Prioritise heading towards the target as the first move
            if (Math.Abs(startPoint.X - targetPoint.X) >  Math.Abs(startPoint.Y - targetPoint.Y))
            {
                pointsToCheck[0] = new Point(Math.Min(_width - 1, currentNode.Position.X + 1), currentNode.Position.Y);
                pointsToCheck[1] = new Point(Math.Max(0, currentNode.Position.X - 1), currentNode.Position.Y);
                pointsToCheck[2] = new Point(currentNode.Position.X, Math.Min(_height - 1, currentNode.Position.Y + 1));
                pointsToCheck[3] = new Point(currentNode.Position.X, Math.Max(0, currentNode.Position.Y - 1));
            }
            else
            {
                pointsToCheck[0] = new Point(currentNode.Position.X, Math.Min(_height - 1, currentNode.Position.Y + 1));
                pointsToCheck[1] = new Point(currentNode.Position.X, Math.Max(0, currentNode.Position.Y - 1));
                pointsToCheck[2] = new Point(Math.Min(_width - 1, currentNode.Position.X + 1), currentNode.Position.Y);
                pointsToCheck[3] = new Point(Math.Max(0, currentNode.Position.X - 1), currentNode.Position.Y);
            }

            foreach (Point pointToCheck in pointsToCheck)
            {
                Node? existingNode = _nodes.SingleOrDefault(n => n.Position == pointToCheck);

                if (existingNode == null)
                {
                    if (pointToCheck == startPoint || pointToCheck == targetPoint || cover[pointToCheck.X, pointToCheck.Y] == 0)
                    {
                        Node node = new Node(pointToCheck);

                        node.Parent = currentNode.Position;

                        node.G = currentNode.G + 1;

                        if (node.G > maxDistance)
                            continue;

                        node.H = CalculationUtil.GetManhattanDistance(pointToCheck, targetPoint);
                        node.F = node.G + node.H;

                        _nodes.Add(node);
                    }
                }
                else
                {
                    if (!existingNode.Closed)
                    {
                        int g = currentNode.G + 1;

                        if (g < existingNode.G)
                        {
                            existingNode.G = g;

                            if (existingNode.G > maxDistance)
                                continue;

                            existingNode.F = existingNode.G + existingNode.H;

                            existingNode.Parent = currentNode.Position;
                        }
                    }
                }
            }

            currentNode.Closed = true;

            if (currentNode.Position == targetPoint)
            {
                targetFound = true;
            }
            else
            {
                _nodes = _nodes.OrderBy(n => n.Closed == true).ThenBy(n => n.F).ToList();

                currentNode = _nodes.First();
            }

            timeToSearch++;

            if (timeToSearch > 1000)
            {
                Console.Error.WriteLine("Warning: Time to search hit 1000");
            }
        }

        int numberOfSteps = currentNode.G;

        List<Point> shortestPath = [currentNode.Position];

        bool atStart = false;

        while (!atStart)
        {
            currentNode = _nodes.Single(n => n.Position == currentNode.Parent);

            if (currentNode.Position == startPoint)
            {
                atStart = true;
            }
            else
            {
                shortestPath.Insert(0, currentNode.Position);
            }
        }

        return shortestPath;
    }
}


public static class CalculationUtil
{
    public static int GetManhattanDistance(Point point1, Point point2)
    {
        return Math.Abs(point1.X - point2.X) + Math.Abs(point1.Y - point2.Y);

    }

    internal static double GetEuclideanDistance(Point point1, Point point2)
    {
        return Math.Sqrt(Math.Pow(point1.X - point2.X, 2) + Math.Pow(point1.Y - point2.Y, 2));
    }
}


public static class ClosestPeakFinder
{
    public static (Point, double) FindClosestPeak(Point position, double[,] damageMap)
    {
        double highestValue = damageMap.Cast<double>().Max();

        Queue<Point> queue = new Queue<Point>();
        HashSet<Point> visited = new HashSet<Point>();
        queue.Enqueue(position);
        visited.Add(position);

        while (queue.Count > 0)
        {
            Point current = queue.Dequeue();
            if (current.X < 0 || current.Y < 0 || current.X >= damageMap.GetLength(0) || current.Y >= damageMap.GetLength(1))
            {
                continue; 
            }

            double value = damageMap[current.X, current.Y];

            if (value == highestValue)
            {
                return (current, value);
            }
            // Add neighbors to the queue
            foreach (Point neighbor in GetNeighbors(current))
            {
                if (!visited.Contains(neighbor))
                {
                    visited.Add(neighbor);
                    queue.Enqueue(neighbor);
                }
            }
        }

        Console.Error.WriteLine("ERROR: No peak found in the damage map.");
        return (new Point(-1, -1), -1);

    }

    private static IEnumerable<Point> GetNeighbors(Point current)
    {
        yield return new Point(current.X - 1, current.Y); // Left
        yield return new Point(current.X + 1, current.Y); // Right
        yield return new Point(current.X, current.Y - 1); // Up
        yield return new Point(current.X, current.Y + 1); // Down
        yield return new Point(current.X - 1, current.Y - 1); // Top-left
        yield return new Point(current.X + 1, current.Y - 1); // Top-right
        yield return new Point(current.X - 1, current.Y + 1); // Bottom-left
        yield return new Point(current.X + 1, current.Y + 1); // Bottom-right
    }
}


public class CoverMapGenerator
{
    private int _width, _height;
    private int[,] _cover;

    public CoverMapGenerator(int[,] cover)
    {
        _width = cover.GetLength(0);
        _height = cover.GetLength(1);
        _cover = cover;
    }

    public double[,] CreateCoverMap(int xPos, int yPos)
    {
        var coverMap = new double[_width, _height];

        // Populate all elements with 1.0
        for (int i = 0; i < _width; i++)
        {
            for (int j = 0; j < _height; j++)
            {
                coverMap[i, j] = 1.0;
            }
        }

        // Set the current position to 0.0
        coverMap[xPos, yPos] = 0.0; 

        // Check if north is protected
        if (yPos - 2 >= 0 && _cover[xPos, yPos - 1] > 0)
        {
            var fillValue = GetCoverProtectionValue(_cover[xPos, yPos - 1]);
                
            // Fill all values to the north
            for (int y = 0; y <= yPos - 2; y++)
            {
                for (int x = 0; x < _width; x++)
                {
                    coverMap[x, y] = fillValue;
                }
            }

            // Set adjacent tiles back to 1.0
            if (xPos - 1 >= 0)
            {
                coverMap[xPos - 1, yPos - 2] = 1.0;
            }
            coverMap[xPos, yPos - 2] = 1.0;
            if (xPos + 1 < _width)
            {
                coverMap[xPos + 1, yPos - 2] = 1.0;
            }
        }

        // Check if south is protected
        if (yPos + 2 <= _height-1 && _cover[xPos, yPos + 1] > 0)
        {
            var fillValue = GetCoverProtectionValue(_cover[xPos, yPos + 1]);
            // Fill all values to the south
            for (int y = yPos + 2; y < _height; y++)
            {
                for (int x = 0; x < _width; x++)
                {
                    coverMap[x, y] = fillValue;
                }
            }

            // Set adjacent tiles back to 1.0
            if (xPos - 1 >= 0)
            {
                coverMap[xPos - 1, yPos + 2] = 1.0;
            }
            coverMap[xPos, yPos + 2] = 1.0;
            if (xPos + 1 < _width)
            {
                coverMap[xPos + 1, yPos + 2] = 1.0;
            }
        }

        // Check if east is protected
        if (xPos + 2 < _width && _cover[xPos + 1, yPos] > 0)
        {
            var fillValue = GetCoverProtectionValue(_cover[xPos + 1, yPos]);
            // Fill all values to the east
            for (int x = xPos + 2; x < _width; x++)
            {
                for (int y = 0; y < _height; y++)
                {
                    // Don't fill it if it's already covered by large cover
                    if (coverMap[x, y] != 0.25)
                    {
                        coverMap[x, y] = fillValue;
                    }
                }
            }
            // Set adjacent tiles back to 1.0
            if (yPos - 1 >= 0)
            {
                coverMap[xPos + 2, yPos - 1] = 1.0;
            }
            coverMap[xPos + 2, yPos] = 1.0;
            if (yPos + 1 < _height)
            {
                coverMap[xPos + 2, yPos + 1] = 1.0;
            }
        }

        // Check if west is protected
        if (xPos - 2 >= 0 && _cover[xPos - 1, yPos] > 0)
        {
            var fillValue = GetCoverProtectionValue(_cover[xPos - 1, yPos]);
            // Fill all values to the west
            for (int x = 0; x <= xPos - 2; x++)
            {
                for (int y = 0; y < _height; y++)
                {
                    // Don't fill it if it's already covered by large cover
                    if (coverMap[x, y] != 0.25)
                    {
                        coverMap[x, y] = fillValue;
                    }
                }
            }
            // Set adjacent tiles back to 1.0
            if (yPos - 1 >= 0)
            {
                coverMap[xPos - 2, yPos - 1] = 1.0;
            }
            coverMap[xPos - 2, yPos] = 1.0;
            if (yPos + 1 < _height)
            {
                coverMap[xPos - 2, yPos + 1] = 1.0;
            }
        }

        return coverMap;
    }

    private double GetCoverProtectionValue(int coverType)
    {
        if (coverType == 1)
        {
            return 0.5;
        }
        else if (coverType == 2)
        {
            return 0.25;
        }

        return 1.0;
    }
}

internal class DamageCalculator
{
    private CoverMapGenerator _coverMapGenerator;

    internal DamageCalculator(CoverMapGenerator coverMapGenerator)
    {
        _coverMapGenerator = coverMapGenerator;
    }

    // Calculates the maximum damage an agent can deal if positioned at (x,y)
    // based on the list of opponentAgents
    internal double CalculateHighestAttackingPlayerDamage(Agent agent, int x, int y, List<Agent> opponentAgents)
    {
        var highestDamage = 0.0;
        foreach (var enemy in opponentAgents)
        {
            var damage = CalculateDamage(
                x,
                y,
                agent.OptimalRange,
                agent.SoakingPower,
                enemy.Position.X,
                enemy.Position.Y);

            if (damage > highestDamage)
            {
                highestDamage = damage;
            }

        }

        return highestDamage;
    }


    // Calculates the total damage the position (x,y) can receive from opponentAgents
    // Note: The total is theoretical and not based on whether they can currently shoot or not
    internal double CalculateReceivingDamage(int x, int y, List<Agent> opponentAgents)
    {
        var stationaryReceivingDamage = 0.0;
        foreach (var opponentAgent in opponentAgents)
        {
            stationaryReceivingDamage += CalculateDamage(
                opponentAgent.Position.X,
                opponentAgent.Position.Y,
                opponentAgent.OptimalRange,
                opponentAgent.SoakingPower,
                x,
                y);
        }

        return stationaryReceivingDamage;
    }

    internal double CalculateDamage(int fromX, int fromY, int optimalRange, int soakingPower, int targetX, int targetY)
    {
        double[,] map = _coverMapGenerator.CreateCoverMap(targetX, targetY);

        var damageMultiplier = map[fromX, fromY];
        var baseDamage = soakingPower * damageMultiplier;

        int manhattanDistance = CalculationUtil.GetManhattanDistance(
            new Point(targetX, targetY), new Point(fromX, fromY));

        if (manhattanDistance <= optimalRange)
        {
            return baseDamage;
        }
        else if (manhattanDistance <= optimalRange * 2)
        {
            return baseDamage / 2;
        }
        else
        {
            return 0;
        }
    }


}


internal class DamageMapGenerator
{
    const double SPLASH_CUTOFF = 30.0; // Minimum splash damage to consider
    private int width;
    private int height;

    public DamageMapGenerator(int width, int height)
    {
        this.width = width;
        this.height = height;
    }

    internal double[,] CreateDamageMap(Agent agent,
                                       List<Agent> opponentAgents, 
                                       int[,] splashMap, 
                                       Dictionary<int, double[,]> coverMaps,
                                       int[,] cover)
    {
        double[,] damageMap = new double[width, height];

        int maxRange = agent.OptimalRange * 2;

        for (int x = 0; x < width; x++)
        {
            for (int y = 0; y < height; y++)
            {
                if (cover[x, y] > 0)
                {
                    // If there is cover on this spot we can't shoot from here
                    damageMap[x, y] = 0.0;
                    continue;
                }

                var maxDamage = 0.0;

                if (agent.SplashBombs > 0)
                {
                    maxDamage = GetBestBombThrow(x, y, splashMap);
                }

                // Only check for max shoot damage if we haven't already added bomb damage
                if (maxDamage <= 0.0) 
                { 
                    foreach (var opponentAgent in opponentAgents)
                    {
                        // Check if it's within max range
                        if (CalculationUtil.GetManhattanDistance(opponentAgent.Position, new Point(x, y)) <= maxRange)
                        {
                            double damage = agent.SoakingPower / 2;

                            if (CalculationUtil.GetManhattanDistance(opponentAgent.Position, new Point(x, y)) <= agent.OptimalRange)
                            {
                                damage = agent.SoakingPower;
                            }

                            // Deduct points for cover
                            double[,]? opponentCoverMap = coverMaps.GetValueOrDefault(opponentAgent.Id);

                            if (opponentCoverMap == null)
                            {
                                Console.Error.WriteLine($"ERROR: No cover map found for agent {opponentAgent.Id}");
                            }
                            else
                            {
                                var coverValue = opponentCoverMap[x, y];
                                if (coverValue < 1.0)
                                {
                                    damage *= coverValue;
                                }
                            }

                            if (damage > maxDamage)
                            {
                                maxDamage = damage;
                            }
                        }
                    }
                }

                damageMap[x, y] = maxDamage;
            }
        }

        return damageMap;
    }

    private double GetBestBombThrow(int x, int y, int[,] splashMap)
    {
        var maxDamage = 0.0;
        // Get the highest value in splashMap within 4 manhattan distance of x, y
        for (int dx = -4; dx <= 4; dx++)
        {
            for (int dy = -4; dy <= 4; dy++)
            {
                int splashX = x + dx;
                int splashY = y + dy;

                if (splashX >= 0 && splashX < width && splashY >= 0 && splashY < height)
                {
                    if (CalculationUtil.GetManhattanDistance(new Point(splashX, splashY), new Point(x, y)) <= 4)
                    {
                        double splashValue = splashMap[splashX, splashY];
                        if (splashValue > maxDamage && splashValue >= SPLASH_CUTOFF)
                        {
                            maxDamage = splashValue;
                        }
                    }
                }
            }
        }

        return maxDamage;
    }
}

internal static class Display
{
    internal static void Map(double[,] map)
    {
        for (int y = 0; y < map.GetLength(1); y++)
        {
            for (int x = 0; x < map.GetLength(0); x++)
            {
                Console.Error.Write($"{map[x, y]:F2} ");
            }
            Console.Error.WriteLine();
        }
    }

    internal static void Map(int[,] map)
    {
        for (int y = 0; y < map.GetLength(1); y++)
        {
            for (int x = 0; x < map.GetLength(0); x++)
            {
                Console.Error.Write($"{map[x, y]} ");
            }
            Console.Error.WriteLine();
        }
    }

    internal static void Sources(List<Agent> agents)
    {
        Console.Error.WriteLine("Move sources");

        foreach (Agent agent in agents)
        {
            Console.Error.WriteLine($"Agent {agent.Id} - Move: {agent.MoveSource} - Action:{agent.ActionSource}");
        }
    }
}

partial class Game
{
    public int Width { get; private set; }
    public int Height { get; private set; }

    public int MyId { get; private set; }

    List<Agent> _playerAgents = new List<Agent>();
    List<Agent> _opponentAgents = new List<Agent>();

    int[,] cover;

    private int[,] _splashMap;
    Dictionary<int, double[,]> _coverMaps;


    private CoverMapGenerator _coverMapGenerator;
    private DamageMapGenerator _damageMapGenerator;
    private DamageCalculator _damageCalculator;

    AStar _aStar;

    private int _moveCount;

    public Game(int myId)
    {
        MyId = myId;
    }

    // One line per agent: <agentId>;<action1;action2;...> actions are "MOVE x y | SHOOT id | THROW x y | HUNKER_DOWN | MESSAGE text"
    internal List<string> GetMoves()
    {
        _splashMap = CreateSplashMap();
        _coverMaps = CreateCoverMaps();

        _damageCalculator = new DamageCalculator(_coverMapGenerator);

        var moves = new List<string>();
        var currentMovePoints = new List<Move>();

        foreach (Agent agent in _playerAgents)
        {
            string fullMove = $"{agent.Id}; ";

            (var move, Point nextMove) = GetBestMove(agent, currentMovePoints);
            fullMove += move;

            fullMove += GetBestAction(agent, nextMove);

            moves.Add(fullMove);
        }

        Display.Sources(_playerAgents);

        _moveCount++;

        return moves;
    }

    private int[,] CreateSplashMap()
    {
        SplashMapGenerator splashMapGenerator = new SplashMapGenerator(Width, Height, _playerAgents, _opponentAgents);
        return splashMapGenerator.CreateSplashMap();
    }

    private Dictionary<int, double[,]> CreateCoverMaps()
    {
        var coverMaps = new Dictionary<int, double[,]>();

        foreach (var agent in _playerAgents)
        {
            coverMaps[agent.Id] = _coverMapGenerator.CreateCoverMap(agent.Position.X, agent.Position.Y);
        }
        foreach (var agent in _opponentAgents)
        {
            coverMaps[agent.Id] = _coverMapGenerator.CreateCoverMap(agent.Position.X, agent.Position.Y);
        }

        return coverMaps;
    }

    private (string move, Point nextMove) GetBestMove(Agent agent,
                                                      List<Move> currentMovePoints)
    {
        // If opponent still has any splashboms, spread out any agents that are close to each other
        if (_moveCount > 2 && _opponentAgents.Any(a => a.SplashBombs > 0))
        {
            // If this agent is less than 2 euclidean distance from another agent
            if (_playerAgents.Any(a => a.Id != agent.Id &&
                                      CalculationUtil.GetEuclideanDistance(a.Position, agent.Position) < 3))
            {
                // Get the closest agent to this agent
                var closestAgent = _playerAgents
                    .Where(a => a.Id != agent.Id)
                    .OrderBy(a => CalculationUtil.GetEuclideanDistance(a.Position, agent.Position))
                    .FirstOrDefault();

                if (closestAgent != null)
                {
                    agent.MoveSource = "Spreading";
                    if (closestAgent.Position.X < agent.Position.X && agent.Position.X + 1 <= Width - 1)
                    {
                        return ($"MOVE {agent.Position.X + 1} {agent.Position.Y}; ", new Point(agent.Position.X + 1, agent.Position.Y));
                    }
                    else if (closestAgent.Position.X > agent.Position.X && agent.Position.X - 1 >= 0)
                    {
                        return ($"MOVE {agent.Position.X - 1} {agent.Position.Y}; ", new Point(agent.Position.X - 1, agent.Position.Y));
                    }
                    else if (closestAgent.Position.Y > agent.Position.Y && agent.Position.Y - 1 >= 0)
                    {
                        return ($"MOVE {agent.Position.X} {agent.Position.Y - 1}; ", new Point(agent.Position.X, agent.Position.Y - 1));
                    }
                    else if (closestAgent.Position.Y < agent.Position.Y && agent.Position.Y + 1 <= Height - 1)
                    {
                        return ($"MOVE {agent.Position.X} {agent.Position.Y + 1}; ", new Point(agent.Position.X, agent.Position.Y + 1));
                    }

                    return ($"MOVE {agent.Position.X} {agent.Position.Y}; ", agent.Position);

                }
            }
        }

        var move = "";
        var nextMove = new Point(-1, -1);

        // If the nearest enemy is more than two times the agent's optimal range away
        // then we should move towards the nearest high damage spot
        (_, var closestEnemyDistance) = GetClosestEnemyPosition(agent);

        // Update Priority
        if (agent.AgentPriority == Priority.MovingToEnemy)
        {
            if (closestEnemyDistance <= agent.OptimalRange)
            {
                agent.AgentPriority = Priority.FindingBestAttackPosition;
            }
        }
        else if(agent.AgentPriority == Priority.FindingBestAttackPosition)
        {
            if (closestEnemyDistance > agent.OptimalRange * 2)
            {
                agent.AgentPriority = Priority.MovingToEnemy;
            }
        }

        if (agent.AgentPriority == Priority.FindingBestAttackPosition && agent.OptimalRange > 2)
        {
            (var coverMove, nextMove) = GetBestAttackPoint(agent);

            if (nextMove != new Point(-1, -1))
            {
                move = coverMove;
                agent.MoveSource = "Moving to best defended attack position";
            }
        }

        if (nextMove == new Point(-1, -1))
        {
            double[,] agentDamageMap = _damageMapGenerator.CreateDamageMap(agent, _opponentAgents, _splashMap, _coverMaps, cover);

            (Point bestAttackPoint, _) = ClosestPeakFinder.FindClosestPeak(
                agent.Position,
                agentDamageMap);

            Point bestPoint = new Point(bestAttackPoint.X, bestAttackPoint.Y);

            if (agent.Position != bestAttackPoint)
            {
                // Convert the move to the next adjacent move so we know exactly where we'll be on the next turn
                List<Point> bestPath = _aStar.GetShortestPath(agent.Position, bestAttackPoint);
                bestPoint = bestPath[0];
            }

            move = $"MOVE {bestPoint.X} {bestPoint.Y}; ";
            nextMove = bestPoint;

            agent.MoveSource = "Moving to best attack position";
        }

        // If this point is already being moved to by another agent don't move
        if (currentMovePoints.Any(p => p.To.X == nextMove.X && p.To.Y == nextMove.Y))
        {
            // Simple first pass implementation. Just don't move, allowing the other one to move instead
            nextMove = agent.Position;
        }

        // If another agent is moving onto this agent
        if (currentMovePoints.Any(p => p.To.X == agent.Position.X && p.To.Y == agent.Position.Y))
        {
            Move relevantMove = currentMovePoints.First(p => p.To.X == agent.Position.X && p.To.Y == agent.Position.Y);
            //   If this agent is staying still or this agent is moving onto that agent's block
            if (agent.Position == nextMove || nextMove == relevantMove.From)
            {
                Point[] pointsToCheck = new Point[4];
                pointsToCheck[0] = new Point(Math.Min(Width - 1, agent.Position.X + 1), agent.Position.Y);
                pointsToCheck[1] = new Point(Math.Max(0, agent.Position.X - 1), agent.Position.Y);
                pointsToCheck[2] = new Point(agent.Position.X, Math.Min(Height - 1, agent.Position.Y + 1));
                pointsToCheck[3] = new Point(agent.Position.X, Math.Max(0, agent.Position.Y - 1));

                foreach (var pointToCheck in pointsToCheck)
                {
                    if (cover[pointToCheck.X, pointToCheck.Y] == 0
                        && relevantMove.From != new Point(pointToCheck.X, pointToCheck.Y))
                    {
                        nextMove = new Point(pointToCheck.X, pointToCheck.Y);
                        agent.MoveSource = "Avoiding a collision";
                        break;
                    }
                }
            }
        }

        currentMovePoints.Add(new Move(agent.Position, nextMove));
        move = $"MOVE {nextMove.X} {nextMove.Y}; ";

        return (move, nextMove);
    }

    private (Point, int) GetClosestEnemyPosition(Agent agent)
    {
        Point closestEnemyPosition = new Point(-1, -1);
        int closestDistance = int.MaxValue;

        foreach (var enemy in _opponentAgents)
        {
            int distance = CalculationUtil.GetManhattanDistance(agent.Position, enemy.Position);

            if (distance < closestDistance)
            {
                closestDistance = distance;
                closestEnemyPosition = enemy.Position;
            }
        }

        return (closestEnemyPosition, closestDistance);
    }

    private (string, Point) GetBestAttackPoint(Agent agent)
    {
        // Look around the agent by optimal range / 2
        var move = new Point(-1, -1);

        var distanceToCheck = agent.OptimalRange / 2;
        int minX = Math.Max(0, agent.Position.X - distanceToCheck);
        int maxX = Math.Min(Width - 1, agent.Position.X + distanceToCheck);
        int minY = Math.Max(0, agent.Position.Y - distanceToCheck);
        int maxY = Math.Min(Height - 1, agent.Position.Y + distanceToCheck);

        double maxDamageScore = double.MinValue;
        int minDistanceToAgent = int.MaxValue;

        // For each point calculate Damage - Potential damage
        for (int x = minX; x <= maxX; x++)
        {
            for (int y = minY; y <= maxY; y++)
            { 
                // Calculate possible damage
                var attackDamage = _damageCalculator.CalculateHighestAttackingPlayerDamage(agent, x, y, _opponentAgents);

                // Calculate possible damage taken
                var receivingDamage = _damageCalculator.CalculateReceivingDamage(x, y, _opponentAgents);

                // Calculate score
                var score = attackDamage - receivingDamage;
                if (score >= maxDamageScore)
                {
                    var distanceToAgent = CalculationUtil.GetManhattanDistance(agent.Position, new Point(x, y));

                    if (score == maxDamageScore)
                    {
                        // If the score is the same, check if it's closer to the agent
                        if (distanceToAgent < minDistanceToAgent)
                        {
                            maxDamageScore = score;
                            minDistanceToAgent = distanceToAgent;
                            move = new Point(x, y);
                        }
                    }
                    else
                    {
                        maxDamageScore = score;
                        minDistanceToAgent = distanceToAgent;
                        move = new Point(x, y);
                    }
                }
            }
        }

        if (move != new Point(-1, -1))
        {
            Point bestPoint = new Point(move.X, move.Y);

            if (agent.Position != move)
            {
                List<Point> bestPath = _aStar.GetShortestPath(agent.Position, move);
                bestPoint = bestPath[0];
            }

            return ($"MOVE {bestPoint.X} {bestPoint.Y}; ", bestPoint);
        }

        return ("", move);
    }

    private string GetBestAction(Agent agent, Point nextMove)
    {
        var move = "";
        var throwAction = "";

        // Within range of a valid throw 
        if (agent.SplashBombs > 0)
        {
            throwAction += GetThrowAction(agent, nextMove);

            if (throwAction != "")
            {
                move += throwAction;
                agent.ActionSource = "Throwing a bomb";
            }
        }

        var shootAction = "";
        if (throwAction == "" && agent.ShootCooldown <= 0)
        {
            shootAction = GetShootAction(agent, nextMove);

            if (shootAction != "")
            {
                move += shootAction;
                agent.ActionSource = "Shooting";
            }
        }

        if (shootAction == "" && throwAction == "")
        {
            move += "HUNKER_DOWN;";
            agent.ActionSource = "Hunkering down";
        }

        return move;
    }

    private string GetThrowAction(Agent agent, Point movePoint)
    {
        // If the movePoint is more than one away from the agents position don't throw
        if (CalculationUtil.GetManhattanDistance(agent.Position, movePoint) > 1)
        {
            Console.Error.WriteLine($"ERROR: WE SHOULD NEVER BE HITTING THIS BECAUSE OF THE A* PATH FINDING");
            return "";
        }

        int bestX = -1;
        int bestY = -1;
        int bestValue = 0;

        Point calculationPoint = new Point(-1, -1);

        // Get highest score from splashDamageMap within 4 
        // Manhattan distance from agent's position
        int minX = Math.Max(0, movePoint.X - 4);
        int maxX = Math.Min(Width - 1, movePoint.X + 4);
        int minY = Math.Max(0, movePoint.Y - 4);
        int maxY = Math.Min(Height - 1, movePoint.Y + 4);

        for (int x = minX; x <= maxX; x++)
        {
            for (int y = minY; y <= maxY; y++)
            {
                // We don't want to throw a bomb if it would hit the point we're moving to (movePoint)
                if (Math.Abs(x - movePoint.X) <= 1 && Math.Abs(y - movePoint.Y) <= 1)
                {
                    continue;
                }

                var manhattanDistance = CalculationUtil.GetManhattanDistance(
                    movePoint, new Point(x, y));

                if (manhattanDistance <= 4 && _splashMap[x, y] > bestValue)
                {
                    bestValue = _splashMap[x, y];
                    bestX = x;
                    bestY = y;
                }
            }
        }

        if (bestValue > 0)
        {
            return $"THROW {bestX} {bestY}";
        }

        return "";
    }

    private string GetShootAction(Agent agent, Point movePoint)
    {
        // Get target
        var bestAttack = 0.0;
        var bestAttackId = -1;

        foreach (var enemy in _opponentAgents)
        {
            // If enemy is not in range of agent, skip it
            if (CalculationUtil.GetManhattanDistance(enemy.Position, agent.Position) - 1 > agent.OptimalRange * 2)
            {
                continue;
            }

            var damage = _damageCalculator.CalculateDamage(
                movePoint.X,
                movePoint.Y,
                agent.OptimalRange,
                agent.SoakingPower,
                enemy.Position.X,
                enemy.Position.Y);

            if (damage > bestAttack)
            {
                bestAttack = damage;
                bestAttackId = enemy.Id;
            }
        }


        if (bestAttack <= 0.0)
        {
            return "";
        }

        return $"SHOOT {bestAttackId}";
    }

    public void SetGameSize(int width, int height)
    {
        Width = width;
        Height = height;

        cover = new int[Width, Height];
        
        _damageMapGenerator = new DamageMapGenerator(width, height);
    }

    internal void AddAgent(int id, int player, int shootCooldown, int optimalRange, int soakingPower, int splashBombs)
    {
        if (player == MyId)
        {
            _playerAgents.Add(new Agent(id, player, shootCooldown, optimalRange, soakingPower, splashBombs));
        }
        else
        {
            _opponentAgents.Add(new Agent(id, player, shootCooldown, optimalRange, soakingPower, splashBombs));
        }
    }

    internal void MarkAllAgentsForCulling()
    {
        foreach (var agent in _playerAgents)
        {
            agent.InGame = false;
        }

        foreach (var agent in _opponentAgents)
        {
            agent.InGame = false;
        }
    }

    internal void DestroyMarkedAgents()
    {
        _playerAgents.RemoveAll(agent => !agent.InGame);
        _opponentAgents.RemoveAll(agent => !agent.InGame);
    }

    internal void UpdateAgent(int agentId, int x, int y, int cooldown, int splashBombs, int wetness)
    {
        Agent agent = _playerAgents.FirstOrDefault(a => a.Id == agentId) 
            ?? _opponentAgents.FirstOrDefault(a => a.Id == agentId);

        if (agent != null)
        {
            agent.UpdatePosition(x, y);
            agent.ShootCooldown = cooldown;
            agent.SplashBombs = splashBombs;
            agent.Wetness = wetness;
            agent.InGame = true;
        }
    }

    internal void SetCover(int x, int y, int tileType)
    {
        if (x < 0 || x >= Width || y < 0 || y >= Height)
        {
            Console.Error.WriteLine($"Cover position {x}, {y} out of bounds");
            return;
        }
        cover[x, y] = tileType;
    }

    internal void UpdateCoverRelatedMaps()
    {
        _coverMapGenerator = new CoverMapGenerator(cover);
        _aStar = new AStar(cover);
    }
}


public class Move
{
    public Point From { get; }
    public Point To { get; }

    public Move(Point from, Point to)
    {
        From = from;
        To = to;
    }
}
    



internal sealed class Node
{
    public Point Position { get; set; }

    public Point Parent { get; set; }

    public int G { get; set; }
    public int H { get; set; }
    public int F { get; set; }

    public bool Closed { get; set; }

    public Node(Point position)
    {
        Position = position;
    }
}


class Player
{
    static void Main(string[] args)
    {
        string[] inputs;
        int myId = int.Parse(Console.ReadLine()); // Your player id (0 or 1)
        int agentDataCount = int.Parse(Console.ReadLine()); // Total number of agents in the game

        var game = new Game(myId);

        for (int i = 0; i < agentDataCount; i++)
        {
            inputs = Console.ReadLine().Split(' ');
            int agentId = int.Parse(inputs[0]); // Unique identifier for this agent
            int player = int.Parse(inputs[1]); // Player id of this agent
            int shootCooldown = int.Parse(inputs[2]); // Number of turns between each of this agent's shots
            int optimalRange = int.Parse(inputs[3]); // Maximum manhattan distance for greatest damage output
            int soakingPower = int.Parse(inputs[4]); // Damage output within optimal conditions
            int splashBombs = int.Parse(inputs[5]); // Number of splash bombs this can throw this game

            game.AddAgent(agentId, player, shootCooldown, optimalRange, soakingPower, splashBombs);
        }

        inputs = Console.ReadLine().Split(' ');
        int width = int.Parse(inputs[0]); // Width of the game map
        int height = int.Parse(inputs[1]); // Height of the game map

        game.SetGameSize(width, height);

        for (int i = 0; i < height; i++)
        {
            inputs = Console.ReadLine().Split(' ');
            for (int j = 0; j < width; j++)
            {
                int x = int.Parse(inputs[3 * j]);// X coordinate, 0 is left edge
                int y = int.Parse(inputs[3 * j + 1]);// Y coordinate, 0 is top edge
                int tileType = int.Parse(inputs[3 * j + 2]);

                if (tileType > 0)
                {
                    game.SetCover(x, y, tileType);
                }
            }
        }

        game.UpdateCoverRelatedMaps();

        int count = 1;

        // game loop
        while (true)
        {
            // This is a workaround for a weird bug I found. Hopefully They'll fix it
            if (count > 1)
            {
                Console.ReadLine();
            }

            game.MarkAllAgentsForCulling();

            int agentCount = int.Parse(Console.ReadLine()); // Total number of agents still in the game
            
            for (int i = 0; i < agentCount; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                
                int agentId = int.Parse(inputs[0]);
                int x = int.Parse(inputs[1]);
                int y = int.Parse(inputs[2]);
                int cooldown = int.Parse(inputs[3]); // Number of turns before this agent can shoot
                int splashBombs = int.Parse(inputs[4]);
                int wetness = int.Parse(inputs[5]); // Damage (0-100) this agent has taken

                game.UpdateAgent(agentId, x, y, cooldown, splashBombs, wetness);
            }

            game.DestroyMarkedAgents();

            List<string> moves = game.GetMoves();
            foreach (var move in moves)
            {
                Console.WriteLine(move);
            }

            count++;
        }
    }
}


internal class SplashMapGenerator
{
    private readonly int width;
    private readonly int height;
    private List<Agent> playerAgents;
    private List<Agent> opponentAgents;

    public SplashMapGenerator(int width, int height, List<Agent> playerAgents, List<Agent> opponentAgents)
    {
        this.width = width;
        this.height = height;
        this.playerAgents = playerAgents;
        this.opponentAgents = opponentAgents;
    }

    internal int[,] CreateSplashMap()
    {
        int[,] splashMap = new int[width, height];

        for (int x = 0; x < width; x++)
        {
            for (int y = 0; y < height; y++)
            {
                splashMap[x, y] = CalculateDamage(x, y);
            }
        }

        return splashMap;
    }

    private int CalculateDamage(int x, int y)
    {
        var damage = 0;

        var minX = Math.Max(0, x - 1);
        var maxX = Math.Min(width - 1, x + 1);
        var minY = Math.Max(0, y - 1);
        var maxY = Math.Min(height - 1, y + 1);

        for (int i = minX; i <= maxX; i++)
        {
            for (int j = minY; j <= maxY; j++)
            {
                foreach (var agent in playerAgents)
                {
                    if (agent.Position.X == i && agent.Position.Y == j)
                    {
                        // If we hit our own agent we want to return no damage
                        return -1;
                    }
                }

                foreach (var enemy in opponentAgents)
                {
                    if (enemy.Position.X == i && enemy.Position.Y == j)
                    {
                        damage += 30;
                    }
                }
            }
        }

        return damage;
    }
}

