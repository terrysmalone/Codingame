/**************************************************************
  This file was generated by FileConcatenator.
  It combined all classes in the project to work in Codingame.
  This hasn't been put in a namespace to allow for class 
  name duplicates.
***************************************************************/
using System.Drawing;
using System;

    internal class Cell
    {
        public Content CellContent { get; set; }
        public bool Explored { get; set; }
    }

    internal enum Content
    {
        Unknown,
        Wall,
        Hollow,
        ControlRoom,
        StartPosition
    }

    internal static class ContentConverter
    {
        internal static char[,] ToCharacterGrid(Content[,] worldGrid)
        {
            var characterGrid = new char[worldGrid.GetLength(0), worldGrid.GetLength(1)];

            for (var y = 0; y < worldGrid.GetLength(1); y++)
            {
                for (var x = 0; x < worldGrid.GetLength(0); x++)
                {
                    characterGrid[x, y] = ToCharacter(worldGrid[x, y]);
                }
            }

            return characterGrid;
        }

        private static char ToCharacter(Content content)
        {
            return content switch
            {
                Content.Unknown       => '?',
                Content.Wall          => '#',
                Content.StartPosition => 'T',
                Content.Hollow        => '.',
                Content.ControlRoom   => 'C',
                _                     => '?'
            };
        }

        internal static Content ToContent(char contentChar)
        {
            return contentChar switch
            {
                '?' => Content.Unknown,
                '#' => Content.Wall,
                'T' => Content.StartPosition,
                '.' => Content.Hollow,
                'C' => Content.ControlRoom,
                _   => Content.Unknown
            };
        }
    }

    internal static class DebugViewer
    {
        internal static void PrintWorld(Content[,] worldGrid, Point characterLocation)
        {
            var characterView = ContentConverter.ToCharacterGrid(worldGrid);
            for (var y = 0; y < worldGrid.GetLength(1); y++)
            {
                for (var x = 0; x < worldGrid.GetLength(0); x++)
                {
                    if (characterLocation.X == x && characterLocation.Y == y)
                    {
                        Console.Error.Write('+');
                    }
                    else
                    {
                        Console.Error.Write(characterView[x, y]);
                    }
                }

                Console.Error.WriteLine();
            }
        }
    }


    internal sealed class Game
    {
        private int _worldWidth;
        private int _worldHeight;

        private Content[,] _worldGrid;
        private bool[,] _visited;
        private Point _characterLocation;

        private readonly int _alarmCountDown;

        private readonly Size _leftMove = new Size(-1, 0);
        private readonly Size _rightMove = new Size(1, 0);
        private readonly Size _upMove = new Size(0, -1);
        private readonly Size _downMove = new Size(0, 1);

        private readonly Size _leftLook = new Size(-3, 0);
        private readonly Size _rightLook = new Size(3, 0);
        private readonly Size _upLook = new Size(0, -3);
        private readonly Size _downLook = new Size(0, 3);

        private Point _lastVisited = new Point(-1, -1);

        public Game(int worldWidth, int worldHeight, int alarmCountDown)
        {
            _worldWidth = worldWidth;
            _worldHeight = worldHeight;

            _alarmCountDown = alarmCountDown;
            _worldGrid = new Content[worldWidth, worldHeight];
            _visited = new bool[worldWidth, worldHeight];
        }

        internal void UpdateCharacterLocation(int xPos, int yPos)
        {
            Console.Error.WriteLine($"Updating character location to {xPos},{yPos}");
            _characterLocation = new Point(xPos, yPos);
            _visited[xPos, yPos] = true;
        }

        internal void UpdateWorld(Content[,] world)
        {
             _worldGrid = world.Clone() as Content[,];
        }

        public MoveDirection GetMove()
        {
             DebugViewer.PrintWorld(_worldGrid, _characterLocation);

             // if we know where the control room is
                // if we have a path back faster than the timer
                    // move back on that path
            // else

            // move to an unexplored area
            var exploreMove = GetExploreMove();

            _lastVisited = new Point(_characterLocation.X, _characterLocation.Y);

            return exploreMove;
        }
        private MoveDirection GetExploreMove()
        {
            // first try to move in the direction of an unexplored area
            var unVisitedDirection = GetUnvisitedMove();

            if (unVisitedDirection != MoveDirection.None)
            {
                Console.Error.WriteLine($"Unvisited direction {unVisitedDirection} found.");

                _lastVisited = new Point(_characterLocation.X, _characterLocation.Y);
                return unVisitedDirection;
            }

            Console.Error.WriteLine($"Unvisited direction not found. Looking for other move");

            // We didn't find an unvisited spot
            // Move to any spot except the last
            var possibleDirection = MoveDirection.None;

            if (CanMove(_characterLocation + _leftMove))
            {
                possibleDirection = MoveDirection.Left;

                Console.Error.WriteLine("We can move left");
                Console.Error.WriteLine($"last visited: {_lastVisited.X}, {_lastVisited.Y}");
                Console.Error.WriteLine($"left move: {(_characterLocation + _leftMove).X}, {(_characterLocation + _leftMove).Y}");

                if (!WasLastMove(_characterLocation + _leftMove))
                {
                    return MoveDirection.Left;
                }
            }

            if (CanMove(_characterLocation + _rightMove))
            {
                possibleDirection = MoveDirection.Right;

                Console.Error.WriteLine("We can move right");
                Console.Error.WriteLine($"last visited: {_lastVisited.X}, {_lastVisited.Y}");
                Console.Error.WriteLine($"right move: {(_characterLocation + _rightMove).X}, {(_characterLocation + _rightMove).Y}");

                if (!WasLastMove(_characterLocation + _rightMove))
                {
                    return MoveDirection.Right;
                }
            }

            if (CanMove(_characterLocation + _upMove))
            {
                possibleDirection = MoveDirection.Up;

                Console.Error.WriteLine("We can move up");

                if (!WasLastMove(_characterLocation + _upMove))
                {
                    return MoveDirection.Up;
                }
            }

            if (CanMove(_characterLocation + _downMove))
            {
                Console.Error.WriteLine("We can move down");

                possibleDirection = MoveDirection.Down;

                if (!WasLastMove(_characterLocation + _downMove))
                {
                    return MoveDirection.Down;
                }
            }

            Console.Error.WriteLine($"No new move. Falling back to {possibleDirection}");

            return possibleDirection;
        }

        private MoveDirection GetUnvisitedMove()
        {
            if (Unvisited(_characterLocation + _leftMove))
            {
                Console.Error.WriteLine("WE HAVEN'T VISITED LEFT");
                return MoveDirection.Left;
            }

            if (Unvisited(_characterLocation + _rightMove))
            {
                Console.Error.WriteLine("WE HAVEN'T VISITED RIGHT");
                return MoveDirection.Right;
            }

            if (Unvisited(_characterLocation + _upMove))
            {
                Console.Error.WriteLine("WE HAVEN'T VISITED UP");
                return MoveDirection.Up;
            }

            if (Unvisited(_characterLocation + _downMove))
            {
                Console.Error.WriteLine("WE HAVEN'T VISITED DOWN");
                return MoveDirection.Down;
            }

            return MoveDirection.None;
        }

        private bool Unvisited(Point location)
        {
            // If we can go here
            if (CanMove(location))
            {
                if (!_visited[location.X, location.Y])
                {
                    return true;
                }
            }

            return false;
        }

        private bool CanMove(Point location)
        {
            // If we can go here
            if (location.X >= 0 && location.X <= _worldWidth - 1 && location.Y >= 0 && location.Y <= _worldHeight - 1
                && _worldGrid[location.X, location.Y] == Content.Hollow)
            {
                Console.Error.WriteLine($"Can move to {location.X},{location.Y}");
                return true;
            }

            return false;
        }

        private bool ShouldMove(Point lookPoint, Point movePoint)
        {
            // If we havent explored here
            if (lookPoint.X >= 0 && lookPoint.X <= _worldWidth-1 && lookPoint.Y >= 0 && lookPoint.Y <= _worldHeight-1
                && _worldGrid[lookPoint.X, lookPoint.Y] == Content.Unknown)
            {
                // If we can move here
                if (_worldGrid[movePoint.X, movePoint.Y] == Content.Hollow)
                {
                    return true;
                }
            }

            return false;
        }

        private bool WasLastMove(Point movePoint)
        {
            if (movePoint.X == _lastVisited.X && movePoint.Y == _lastVisited.Y)
            {
                Console.Error.Write("This was the last move");
                return true;
            }

            return false;
        }
    }

    internal enum MoveDirection
    {
        Left,
        Right,
        Up,
        Down,
        None
    }

    internal class Player
    {
        static void Main(string[] args)
        {
            string[] inputs;
            inputs = Console.ReadLine().Split(' ');
            var rows = int.Parse(inputs[0]); // number of rows.
            var columns = int.Parse(inputs[1]); // number of columns.
            var alarmCountdown = int.Parse(inputs[2]); // number of rounds between the time the alarm countdown is activated and the time the alarm goes off.

            var game = new Game(columns, rows, alarmCountdown);

            // game loop
            while (true)
            {
                inputs = Console.ReadLine().Split(' ');
                var characterLocationRow = int.Parse(inputs[0]); // row where Rick is located.
                var characterColumn = int.Parse(inputs[1]); // column where Rick is located.

                game.UpdateCharacterLocation(characterColumn, characterLocationRow);

                var world = new Content[columns, rows];

                for (var y = 0; y < rows; y++)
                {
                    var row = Console.ReadLine().ToCharArray(); // C of the characters in '#.TC?' (i.e. one line of the ASCII maze).

                    for (var x = 0; x < columns; x++)
                    {
                        world[x, y] = ContentConverter.ToContent(row[x]);
                    }
                }

                game.UpdateWorld(world);

                var moveDirection = game.GetMove() switch
                {
                    MoveDirection.Right => "RIGHT",
                    MoveDirection.Left => "LEFT",
                    MoveDirection.Up => "UP",
                    MoveDirection.Down => "DOWN",
                    _ => "UP"
                };

                // Write an action using Console.WriteLine()
                // To debug: Console.Error.WriteLine("Debug messages...");

                Console.WriteLine(moveDirection); // Rick's next move (UP DOWN LEFT or RIGHT).
            }
        }
    }
